/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "t_test_debug_proto_test_types.h"
#include <thrift/c_glib/thrift.h>

/* return the name of the constant */
const char *
toString_SomeEnum(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case T_TEST_SOME_ENUM_ONE:return "T_TEST_SOME_ENUM_ONE";
  case T_TEST_SOME_ENUM_TWO:return "T_TEST_SOME_ENUM_TWO";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

enum _TTestDoublesProperties
{
  PROP_T_TEST_DOUBLES_0,
  PROP_T_TEST_DOUBLES_NAN,
  PROP_T_TEST_DOUBLES_INF,
  PROP_T_TEST_DOUBLES_NEGINF,
  PROP_T_TEST_DOUBLES_REPEATING,
  PROP_T_TEST_DOUBLES_BIG,
  PROP_T_TEST_DOUBLES_TINY,
  PROP_T_TEST_DOUBLES_ZERO,
  PROP_T_TEST_DOUBLES_NEGZERO
};

/* reads a doubles object */
static gint32
t_test_doubles_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestDoubles * this_object = T_TEST_DOUBLES(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->nan, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_nan = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->inf, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_inf = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->neginf, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_neginf = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->repeating, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_repeating = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->big, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_big = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->tiny, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_tiny = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->zero, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_zero = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->negzero, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_negzero = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_doubles_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestDoubles * this_object = T_TEST_DOUBLES(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Doubles", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "nan", T_DOUBLE, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->nan, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "inf", T_DOUBLE, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->inf, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "neginf", T_DOUBLE, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->neginf, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "repeating", T_DOUBLE, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->repeating, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "big", T_DOUBLE, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->big, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tiny", T_DOUBLE, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->tiny, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "zero", T_DOUBLE, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->zero, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "negzero", T_DOUBLE, 8, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->negzero, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_doubles_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  TTestDoubles *self = T_TEST_DOUBLES (object);

  switch (property_id)
  {
    case PROP_T_TEST_DOUBLES_NAN:
      self->nan = g_value_get_double (value);
      self->__isset_nan = TRUE;
      break;

    case PROP_T_TEST_DOUBLES_INF:
      self->inf = g_value_get_double (value);
      self->__isset_inf = TRUE;
      break;

    case PROP_T_TEST_DOUBLES_NEGINF:
      self->neginf = g_value_get_double (value);
      self->__isset_neginf = TRUE;
      break;

    case PROP_T_TEST_DOUBLES_REPEATING:
      self->repeating = g_value_get_double (value);
      self->__isset_repeating = TRUE;
      break;

    case PROP_T_TEST_DOUBLES_BIG:
      self->big = g_value_get_double (value);
      self->__isset_big = TRUE;
      break;

    case PROP_T_TEST_DOUBLES_TINY:
      self->tiny = g_value_get_double (value);
      self->__isset_tiny = TRUE;
      break;

    case PROP_T_TEST_DOUBLES_ZERO:
      self->zero = g_value_get_double (value);
      self->__isset_zero = TRUE;
      break;

    case PROP_T_TEST_DOUBLES_NEGZERO:
      self->negzero = g_value_get_double (value);
      self->__isset_negzero = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_doubles_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  TTestDoubles *self = T_TEST_DOUBLES (object);

  switch (property_id)
  {
    case PROP_T_TEST_DOUBLES_NAN:
      g_value_set_double (value, self->nan);
      break;

    case PROP_T_TEST_DOUBLES_INF:
      g_value_set_double (value, self->inf);
      break;

    case PROP_T_TEST_DOUBLES_NEGINF:
      g_value_set_double (value, self->neginf);
      break;

    case PROP_T_TEST_DOUBLES_REPEATING:
      g_value_set_double (value, self->repeating);
      break;

    case PROP_T_TEST_DOUBLES_BIG:
      g_value_set_double (value, self->big);
      break;

    case PROP_T_TEST_DOUBLES_TINY:
      g_value_set_double (value, self->tiny);
      break;

    case PROP_T_TEST_DOUBLES_ZERO:
      g_value_set_double (value, self->zero);
      break;

    case PROP_T_TEST_DOUBLES_NEGZERO:
      g_value_set_double (value, self->negzero);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_doubles_instance_init (TTestDoubles * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->nan = 0;
  object->__isset_nan = FALSE;
  object->inf = 0;
  object->__isset_inf = FALSE;
  object->neginf = 0;
  object->__isset_neginf = FALSE;
  object->repeating = 0;
  object->__isset_repeating = FALSE;
  object->big = 0;
  object->__isset_big = FALSE;
  object->tiny = 0;
  object->__isset_tiny = FALSE;
  object->zero = 0;
  object->__isset_zero = FALSE;
  object->negzero = 0;
  object->__isset_negzero = FALSE;
}

static void 
t_test_doubles_finalize (GObject *object)
{
  TTestDoubles *tobject = T_TEST_DOUBLES (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_doubles_class_init (TTestDoublesClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_doubles_read;
  struct_class->write = t_test_doubles_write;

  gobject_class->finalize = t_test_doubles_finalize;
  gobject_class->get_property = t_test_doubles_get_property;
  gobject_class->set_property = t_test_doubles_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_DOUBLES_NAN,
     g_param_spec_double ("nan",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_DOUBLES_INF,
     g_param_spec_double ("inf",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_DOUBLES_NEGINF,
     g_param_spec_double ("neginf",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_DOUBLES_REPEATING,
     g_param_spec_double ("repeating",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_DOUBLES_BIG,
     g_param_spec_double ("big",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_DOUBLES_TINY,
     g_param_spec_double ("tiny",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_DOUBLES_ZERO,
     g_param_spec_double ("zero",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_DOUBLES_NEGZERO,
     g_param_spec_double ("negzero",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));
}

GType
t_test_doubles_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestDoublesClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_doubles_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestDoubles),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_doubles_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestDoublesType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestOneOfEachProperties
{
  PROP_T_TEST_ONE_OF_EACH_0,
  PROP_T_TEST_ONE_OF_EACH_IM_TRUE,
  PROP_T_TEST_ONE_OF_EACH_IM_FALSE,
  PROP_T_TEST_ONE_OF_EACH_A_BITE,
  PROP_T_TEST_ONE_OF_EACH_INTEGER16,
  PROP_T_TEST_ONE_OF_EACH_INTEGER32,
  PROP_T_TEST_ONE_OF_EACH_INTEGER64,
  PROP_T_TEST_ONE_OF_EACH_DOUBLE_PRECISION,
  PROP_T_TEST_ONE_OF_EACH_SOME_CHARACTERS,
  PROP_T_TEST_ONE_OF_EACH_ZOMG_UNICODE,
  PROP_T_TEST_ONE_OF_EACH_WHAT_WHO,
  PROP_T_TEST_ONE_OF_EACH_BASE64,
  PROP_T_TEST_ONE_OF_EACH_BYTE_LIST,
  PROP_T_TEST_ONE_OF_EACH_I16_LIST,
  PROP_T_TEST_ONE_OF_EACH_I64_LIST
};

/* reads a one_of_each object */
static gint32
t_test_one_of_each_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestOneOfEach * this_object = T_TEST_ONE_OF_EACH(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->im_true, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_im_true = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->im_false, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_im_false = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->a_bite, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_a_bite = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->integer16, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_integer16 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->integer32, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_integer32 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->integer64, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_integer64 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->double_precision, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_double_precision = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRING)
        {
          if (this_object->some_characters != NULL)
          {
            g_free(this_object->some_characters);
            this_object->some_characters = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->some_characters, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_some_characters = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_STRING)
        {
          if (this_object->zomg_unicode != NULL)
          {
            g_free(this_object->zomg_unicode);
            this_object->zomg_unicode = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->zomg_unicode, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_zomg_unicode = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->what_who, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_what_who = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_STRING)
        {
          if (this_object->base64 != NULL)
          {
            g_free(this_object->base64);
            this_object->base64 = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->base64 = g_byte_array_new();
          g_byte_array_append (this_object->base64, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_base64 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint8* _elem0 = g_new (gint8, 1);
              if ((ret = thrift_protocol_read_byte (protocol, &*_elem0, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->byte_list, _elem0, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_byte_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 13:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint16* _elem1 = g_new (gint16, 1);
              if ((ret = thrift_protocol_read_i16 (protocol, &*_elem1, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->i16_list, _elem1, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_i16_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 14:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint64* _elem2 = g_new (gint64, 1);
              if ((ret = thrift_protocol_read_i64 (protocol, &*_elem2, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->i64_list, _elem2, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_i64_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_one_of_each_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestOneOfEach * this_object = T_TEST_ONE_OF_EACH(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "OneOfEach", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "im_true", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->im_true, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "im_false", T_BOOL, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->im_false, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "a_bite", T_BYTE, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->a_bite, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "integer16", T_I16, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->integer16, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "integer32", T_I32, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->integer32, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "integer64", T_I64, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->integer64, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "double_precision", T_DOUBLE, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->double_precision, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "some_characters", T_STRING, 8, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->some_characters, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "zomg_unicode", T_STRING, 9, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->zomg_unicode, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "what_who", T_BOOL, 10, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->what_who, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "base64", T_STRING, 11, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->base64)->data, ((GByteArray *) this_object->base64)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_list", T_LIST, 12, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i3;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_BYTE, (gint32) this_object->byte_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i3 = 0; i3 < this_object->byte_list->len; i3++)
    {
      if ((ret = thrift_protocol_write_byte (protocol, (g_array_index (this_object->byte_list, gint8, i3)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i16_list", T_LIST, 13, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i4;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I16, (gint32) this_object->i16_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i4 = 0; i4 < this_object->i16_list->len; i4++)
    {
      if ((ret = thrift_protocol_write_i16 (protocol, (g_array_index (this_object->i16_list, gint16, i4)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i64_list", T_LIST, 14, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i5;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I64, (gint32) this_object->i64_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i5 = 0; i5 < this_object->i64_list->len; i5++)
    {
      if ((ret = thrift_protocol_write_i64 (protocol, (g_array_index (this_object->i64_list, gint64, i5)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_one_of_each_set_property (GObject *object,
                                 guint property_id,
                                 const GValue *value,
                                 GParamSpec *pspec)
{
  TTestOneOfEach *self = T_TEST_ONE_OF_EACH (object);

  switch (property_id)
  {
    case PROP_T_TEST_ONE_OF_EACH_IM_TRUE:
      self->im_true = g_value_get_boolean (value);
      self->__isset_im_true = TRUE;
      break;

    case PROP_T_TEST_ONE_OF_EACH_IM_FALSE:
      self->im_false = g_value_get_boolean (value);
      self->__isset_im_false = TRUE;
      break;

    case PROP_T_TEST_ONE_OF_EACH_A_BITE:
      self->a_bite = g_value_get_int (value);
      self->__isset_a_bite = TRUE;
      break;

    case PROP_T_TEST_ONE_OF_EACH_INTEGER16:
      self->integer16 = g_value_get_int (value);
      self->__isset_integer16 = TRUE;
      break;

    case PROP_T_TEST_ONE_OF_EACH_INTEGER32:
      self->integer32 = g_value_get_int (value);
      self->__isset_integer32 = TRUE;
      break;

    case PROP_T_TEST_ONE_OF_EACH_INTEGER64:
      self->integer64 = g_value_get_int64 (value);
      self->__isset_integer64 = TRUE;
      break;

    case PROP_T_TEST_ONE_OF_EACH_DOUBLE_PRECISION:
      self->double_precision = g_value_get_double (value);
      self->__isset_double_precision = TRUE;
      break;

    case PROP_T_TEST_ONE_OF_EACH_SOME_CHARACTERS:
      if (self->some_characters != NULL)
        g_free (self->some_characters);
      self->some_characters = g_value_dup_string (value);
      self->__isset_some_characters = TRUE;
      break;

    case PROP_T_TEST_ONE_OF_EACH_ZOMG_UNICODE:
      if (self->zomg_unicode != NULL)
        g_free (self->zomg_unicode);
      self->zomg_unicode = g_value_dup_string (value);
      self->__isset_zomg_unicode = TRUE;
      break;

    case PROP_T_TEST_ONE_OF_EACH_WHAT_WHO:
      self->what_who = g_value_get_boolean (value);
      self->__isset_what_who = TRUE;
      break;

    case PROP_T_TEST_ONE_OF_EACH_BASE64:
      if (self->base64 != NULL)
        g_byte_array_unref (self->base64);
      self->base64 = g_value_dup_boxed (value);
      self->__isset_base64 = TRUE;
      break;

    case PROP_T_TEST_ONE_OF_EACH_BYTE_LIST:
      if (self->byte_list != NULL)
        g_array_unref (self->byte_list);
      self->byte_list = g_value_dup_boxed (value);
      self->__isset_byte_list = TRUE;
      break;

    case PROP_T_TEST_ONE_OF_EACH_I16_LIST:
      if (self->i16_list != NULL)
        g_array_unref (self->i16_list);
      self->i16_list = g_value_dup_boxed (value);
      self->__isset_i16_list = TRUE;
      break;

    case PROP_T_TEST_ONE_OF_EACH_I64_LIST:
      if (self->i64_list != NULL)
        g_array_unref (self->i64_list);
      self->i64_list = g_value_dup_boxed (value);
      self->__isset_i64_list = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_one_of_each_get_property (GObject *object,
                                 guint property_id,
                                 GValue *value,
                                 GParamSpec *pspec)
{
  TTestOneOfEach *self = T_TEST_ONE_OF_EACH (object);

  switch (property_id)
  {
    case PROP_T_TEST_ONE_OF_EACH_IM_TRUE:
      g_value_set_boolean (value, self->im_true);
      break;

    case PROP_T_TEST_ONE_OF_EACH_IM_FALSE:
      g_value_set_boolean (value, self->im_false);
      break;

    case PROP_T_TEST_ONE_OF_EACH_A_BITE:
      g_value_set_int (value, self->a_bite);
      break;

    case PROP_T_TEST_ONE_OF_EACH_INTEGER16:
      g_value_set_int (value, self->integer16);
      break;

    case PROP_T_TEST_ONE_OF_EACH_INTEGER32:
      g_value_set_int (value, self->integer32);
      break;

    case PROP_T_TEST_ONE_OF_EACH_INTEGER64:
      g_value_set_int64 (value, self->integer64);
      break;

    case PROP_T_TEST_ONE_OF_EACH_DOUBLE_PRECISION:
      g_value_set_double (value, self->double_precision);
      break;

    case PROP_T_TEST_ONE_OF_EACH_SOME_CHARACTERS:
      g_value_set_string (value, self->some_characters);
      break;

    case PROP_T_TEST_ONE_OF_EACH_ZOMG_UNICODE:
      g_value_set_string (value, self->zomg_unicode);
      break;

    case PROP_T_TEST_ONE_OF_EACH_WHAT_WHO:
      g_value_set_boolean (value, self->what_who);
      break;

    case PROP_T_TEST_ONE_OF_EACH_BASE64:
      g_value_set_boxed (value, self->base64);
      break;

    case PROP_T_TEST_ONE_OF_EACH_BYTE_LIST:
      g_value_set_boxed (value, self->byte_list);
      break;

    case PROP_T_TEST_ONE_OF_EACH_I16_LIST:
      g_value_set_boxed (value, self->i16_list);
      break;

    case PROP_T_TEST_ONE_OF_EACH_I64_LIST:
      g_value_set_boxed (value, self->i64_list);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_one_of_each_instance_init (TTestOneOfEach * object)
{
  static const gint8 __default_byte_list[3] = 
    { 1, 2, 3 };
  static const gint16 __default_i16_list[3] = 
    { 1, 2, 3 };
  static const gint64 __default_i64_list[3] = 
    { 1, 2, 3 };

  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->im_true = 0;
  object->__isset_im_true = FALSE;
  object->im_false = 0;
  object->__isset_im_false = FALSE;
  object->a_bite = 127;
  object->__isset_a_bite = FALSE;
  object->integer16 = 32767;
  object->__isset_integer16 = FALSE;
  object->integer32 = 0;
  object->__isset_integer32 = FALSE;
  object->integer64 = 10000000000;
  object->__isset_integer64 = FALSE;
  object->double_precision = 0;
  object->__isset_double_precision = FALSE;
  object->some_characters = NULL;
  object->__isset_some_characters = FALSE;
  object->zomg_unicode = NULL;
  object->__isset_zomg_unicode = FALSE;
  object->what_who = 0;
  object->__isset_what_who = FALSE;
  object->base64 = NULL;
  object->__isset_base64 = FALSE;
  object->byte_list = g_array_new (0, 1, sizeof (gint8));
  g_array_append_vals (object->byte_list, &__default_byte_list, 3);
  object->__isset_byte_list = FALSE;
  object->i16_list = g_array_new (0, 1, sizeof (gint16));
  g_array_append_vals (object->i16_list, &__default_i16_list, 3);
  object->__isset_i16_list = FALSE;
  object->i64_list = g_array_new (0, 1, sizeof (gint64));
  g_array_append_vals (object->i64_list, &__default_i64_list, 3);
  object->__isset_i64_list = FALSE;
}

static void 
t_test_one_of_each_finalize (GObject *object)
{
  TTestOneOfEach *tobject = T_TEST_ONE_OF_EACH (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->some_characters != NULL)
  {
    g_free(tobject->some_characters);
    tobject->some_characters = NULL;
  }
  if (tobject->zomg_unicode != NULL)
  {
    g_free(tobject->zomg_unicode);
    tobject->zomg_unicode = NULL;
  }
  if (tobject->base64 != NULL)
  {
    thrift_string_free(tobject->base64);
    tobject->base64 = NULL;
  }
  if (tobject->byte_list != NULL)
  {
    g_array_unref (tobject->byte_list);
    tobject->byte_list = NULL;
  }
  if (tobject->i16_list != NULL)
  {
    g_array_unref (tobject->i16_list);
    tobject->i16_list = NULL;
  }
  if (tobject->i64_list != NULL)
  {
    g_array_unref (tobject->i64_list);
    tobject->i64_list = NULL;
  }
}

static void
t_test_one_of_each_class_init (TTestOneOfEachClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_one_of_each_read;
  struct_class->write = t_test_one_of_each_write;

  gobject_class->finalize = t_test_one_of_each_finalize;
  gobject_class->get_property = t_test_one_of_each_get_property;
  gobject_class->set_property = t_test_one_of_each_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_ONE_OF_EACH_IM_TRUE,
     g_param_spec_boolean ("im_true",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_ONE_OF_EACH_IM_FALSE,
     g_param_spec_boolean ("im_false",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_ONE_OF_EACH_A_BITE,
     g_param_spec_int ("a_bite",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       127,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_ONE_OF_EACH_INTEGER16,
     g_param_spec_int ("integer16",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       32767,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_ONE_OF_EACH_INTEGER32,
     g_param_spec_int ("integer32",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_ONE_OF_EACH_INTEGER64,
     g_param_spec_int64 ("integer64",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         1e+10,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_ONE_OF_EACH_DOUBLE_PRECISION,
     g_param_spec_double ("double_precision",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_ONE_OF_EACH_SOME_CHARACTERS,
     g_param_spec_string ("some_characters",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_ONE_OF_EACH_ZOMG_UNICODE,
     g_param_spec_string ("zomg_unicode",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_ONE_OF_EACH_WHAT_WHO,
     g_param_spec_boolean ("what_who",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_ONE_OF_EACH_BASE64,
     g_param_spec_boxed ("base64",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_ONE_OF_EACH_BYTE_LIST,
     g_param_spec_boxed ("byte_list",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_ONE_OF_EACH_I16_LIST,
     g_param_spec_boxed ("i16_list",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_ONE_OF_EACH_I64_LIST,
     g_param_spec_boxed ("i64_list",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_test_one_of_each_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestOneOfEachClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_one_of_each_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestOneOfEach),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_one_of_each_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestOneOfEachType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestBonkProperties
{
  PROP_T_TEST_BONK_0,
  PROP_T_TEST_BONK_TYPE,
  PROP_T_TEST_BONK_MESSAGE
};

/* reads a bonk object */
static gint32
t_test_bonk_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestBonk * this_object = T_TEST_BONK(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->type, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->message != NULL)
          {
            g_free(this_object->message);
            this_object->message = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->message, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_message = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_bonk_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestBonk * this_object = T_TEST_BONK(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Bonk", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->type, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->message, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_bonk_set_property (GObject *object,
                          guint property_id,
                          const GValue *value,
                          GParamSpec *pspec)
{
  TTestBonk *self = T_TEST_BONK (object);

  switch (property_id)
  {
    case PROP_T_TEST_BONK_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    case PROP_T_TEST_BONK_MESSAGE:
      if (self->message != NULL)
        g_free (self->message);
      self->message = g_value_dup_string (value);
      self->__isset_message = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_bonk_get_property (GObject *object,
                          guint property_id,
                          GValue *value,
                          GParamSpec *pspec)
{
  TTestBonk *self = T_TEST_BONK (object);

  switch (property_id)
  {
    case PROP_T_TEST_BONK_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_T_TEST_BONK_MESSAGE:
      g_value_set_string (value, self->message);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_bonk_instance_init (TTestBonk * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->type = 0;
  object->__isset_type = FALSE;
  object->message = NULL;
  object->__isset_message = FALSE;
}

static void 
t_test_bonk_finalize (GObject *object)
{
  TTestBonk *tobject = T_TEST_BONK (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->message != NULL)
  {
    g_free(tobject->message);
    tobject->message = NULL;
  }
}

static void
t_test_bonk_class_init (TTestBonkClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_bonk_read;
  struct_class->write = t_test_bonk_write;

  gobject_class->finalize = t_test_bonk_finalize;
  gobject_class->get_property = t_test_bonk_get_property;
  gobject_class->set_property = t_test_bonk_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_BONK_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_BONK_MESSAGE,
     g_param_spec_string ("message",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
t_test_bonk_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestBonkClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_bonk_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestBonk),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_bonk_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestBonkType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestNestingProperties
{
  PROP_T_TEST_NESTING_0,
  PROP_T_TEST_NESTING_MY_BONK,
  PROP_T_TEST_NESTING_MY_OOE
};

/* reads a nesting object */
static gint32
t_test_nesting_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestNesting * this_object = T_TEST_NESTING(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->my_bonk), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_my_bonk = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->my_ooe), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_my_ooe = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_nesting_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestNesting * this_object = T_TEST_NESTING(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Nesting", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "my_bonk", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->my_bonk), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "my_ooe", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->my_ooe), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_nesting_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  TTestNesting *self = T_TEST_NESTING (object);

  switch (property_id)
  {
    case PROP_T_TEST_NESTING_MY_BONK:
      if (self->my_bonk != NULL)
        g_object_unref (self->my_bonk);
      self->my_bonk = g_value_dup_object (value);
      self->__isset_my_bonk = TRUE;
      break;

    case PROP_T_TEST_NESTING_MY_OOE:
      if (self->my_ooe != NULL)
        g_object_unref (self->my_ooe);
      self->my_ooe = g_value_dup_object (value);
      self->__isset_my_ooe = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_nesting_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  TTestNesting *self = T_TEST_NESTING (object);

  switch (property_id)
  {
    case PROP_T_TEST_NESTING_MY_BONK:
      g_value_set_object (value, self->my_bonk);
      break;

    case PROP_T_TEST_NESTING_MY_OOE:
      g_value_set_object (value, self->my_ooe);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_nesting_instance_init (TTestNesting * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->my_bonk = g_object_new (T_TEST_TYPE_BONK, NULL);
  object->__isset_my_bonk = FALSE;
  object->my_ooe = g_object_new (T_TEST_TYPE_ONE_OF_EACH, NULL);
  object->__isset_my_ooe = FALSE;
}

static void 
t_test_nesting_finalize (GObject *object)
{
  TTestNesting *tobject = T_TEST_NESTING (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->my_bonk != NULL)
  {
    g_object_unref(tobject->my_bonk);
    tobject->my_bonk = NULL;
  }
  if (tobject->my_ooe != NULL)
  {
    g_object_unref(tobject->my_ooe);
    tobject->my_ooe = NULL;
  }
}

static void
t_test_nesting_class_init (TTestNestingClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_nesting_read;
  struct_class->write = t_test_nesting_write;

  gobject_class->finalize = t_test_nesting_finalize;
  gobject_class->get_property = t_test_nesting_get_property;
  gobject_class->set_property = t_test_nesting_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_NESTING_MY_BONK,
     g_param_spec_object ("my_bonk",
                         NULL,
                         NULL,
                         T_TEST_TYPE_BONK,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_NESTING_MY_OOE,
     g_param_spec_object ("my_ooe",
                         NULL,
                         NULL,
                         T_TEST_TYPE_ONE_OF_EACH,
                         G_PARAM_READWRITE));
}

GType
t_test_nesting_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestNestingClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_nesting_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestNesting),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_nesting_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestNestingType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestHolyMoleyProperties
{
  PROP_T_TEST_HOLY_MOLEY_0,
  PROP_T_TEST_HOLY_MOLEY_BIG,
  PROP_T_TEST_HOLY_MOLEY_CONTAIN,
  PROP_T_TEST_HOLY_MOLEY_BONKS
};

/* reads a holy_moley object */
static gint32
t_test_holy_moley_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestHolyMoley * this_object = T_TEST_HOLY_MOLEY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TTestOneOfEach * _elem6 = NULL;
              if ( _elem6 != NULL)
              {
                g_object_unref (_elem6);
              }
              _elem6 = g_object_new (T_TEST_TYPE_ONE_OF_EACH, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem6), protocol, error)) < 0)
              {
                g_object_unref (_elem6);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->big, _elem6);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_big = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            for (i = 0; i < size; ++i)
            {
              GPtrArray * _elem7 = g_ptr_array_new_with_free_func (g_free);
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                for (i = 0; i < size; i++)
                {
                  gchar * _elem8 = NULL;
                  if (_elem8 != NULL)
                  {
                    g_free(_elem8);
                    _elem8 = NULL;
                  }

                  if ((ret = thrift_protocol_read_string (protocol, &_elem8, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_ptr_array_add (_elem7, _elem8);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              g_hash_table_insert ((GHashTable *) this_object->contain, (gpointer) _elem7, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_contain = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key9 = NULL;
              GPtrArray * val10 = g_ptr_array_new_with_free_func (g_object_unref);
              if (key9 != NULL)
              {
                g_free(key9);
                key9 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key9, error)) < 0)
                return -1;
              xfer += ret;
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                for (i = 0; i < size; i++)
                {
                  TTestBonk * _elem11 = NULL;
                  if ( _elem11 != NULL)
                  {
                    g_object_unref (_elem11);
                  }
                  _elem11 = g_object_new (T_TEST_TYPE_BONK, NULL);
                  if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem11), protocol, error)) < 0)
                  {
                    g_object_unref (_elem11);
                    return -1;
                  }
                  xfer += ret;
                  g_ptr_array_add (val10, _elem11);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              g_hash_table_insert ((GHashTable *)this_object->bonks, (gpointer) key9, (gpointer) val10);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_bonks = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_holy_moley_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestHolyMoley * this_object = T_TEST_HOLY_MOLEY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HolyMoley", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "big", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i12;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->big->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i12 = 0; i12 < this_object->big->len; i12++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->big, i12))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "contain", T_SET, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    GList *key_list = NULL, *iter = NULL;
    GPtrArray ** keys;
    int i = 0, key_count;
    GPtrArray * elem;
    gpointer value;
    THRIFT_UNUSED_VAR (value);

    if ((ret = thrift_protocol_write_set_begin (protocol, T_LIST, (gint32) g_hash_table_size ((GHashTable *) this_object->contain), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->contain, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (GPtrArray *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (GPtrArray *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      elem = keys[i];
      value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->contain), (gpointer) elem);

      {
        guint i13;

        if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) elem->len, error)) < 0)
          return -1;
        xfer += ret;
        for (i13 = 0; i13 < elem->len; i13++)
        {
          if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) elem, i13)), error)) < 0)
            return -1;
        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "bonks", T_MAP, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    gchar * key14 = NULL;
    GPtrArray * val15 = g_ptr_array_new_with_free_func (g_object_unref);
    GList *key_list = NULL, *iter = NULL;
    gchar ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_LIST, (gint32) g_hash_table_size ((GHashTable *) this_object->bonks), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->bonks, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gchar *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gchar *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key14 = keys[i];
      val15 = (GPtrArray *) g_hash_table_lookup (((GHashTable *) this_object->bonks), (gpointer) key14);

      if ((ret = thrift_protocol_write_string (protocol,  key14, error)) < 0)
        return -1;
      {
        guint i16;

        if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32)  val15->len, error)) < 0)
          return -1;
        xfer += ret;
        for (i16 = 0; i16 <  val15->len; i16++)
        {
          if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *)  val15, i16))), protocol, error)) < 0)
            return -1;
          xfer += ret;

        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_holy_moley_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  TTestHolyMoley *self = T_TEST_HOLY_MOLEY (object);

  switch (property_id)
  {
    case PROP_T_TEST_HOLY_MOLEY_BIG:
      if (self->big != NULL)
        g_ptr_array_unref (self->big);
      self->big = g_value_dup_boxed (value);
      self->__isset_big = TRUE;
      break;

    case PROP_T_TEST_HOLY_MOLEY_CONTAIN:
      if (self->contain != NULL)
        g_hash_table_unref (self->contain);
      self->contain = g_value_dup_boxed (value);
      self->__isset_contain = TRUE;
      break;

    case PROP_T_TEST_HOLY_MOLEY_BONKS:
      if (self->bonks != NULL)
        g_hash_table_unref (self->bonks);
      self->bonks = g_value_dup_boxed (value);
      self->__isset_bonks = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_holy_moley_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  TTestHolyMoley *self = T_TEST_HOLY_MOLEY (object);

  switch (property_id)
  {
    case PROP_T_TEST_HOLY_MOLEY_BIG:
      g_value_set_boxed (value, self->big);
      break;

    case PROP_T_TEST_HOLY_MOLEY_CONTAIN:
      g_value_set_boxed (value, self->contain);
      break;

    case PROP_T_TEST_HOLY_MOLEY_BONKS:
      g_value_set_boxed (value, self->bonks);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_holy_moley_instance_init (TTestHolyMoley * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->big = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_big = FALSE;
  object->contain = g_hash_table_new_full (g_direct_hash, g_direct_equal, (GDestroyNotify) g_ptr_array_unref, NULL);
  object->__isset_contain = FALSE;
  object->bonks = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, (GDestroyNotify) g_ptr_array_unref);
  object->__isset_bonks = FALSE;
}

static void 
t_test_holy_moley_finalize (GObject *object)
{
  TTestHolyMoley *tobject = T_TEST_HOLY_MOLEY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->big != NULL)
  {
    g_ptr_array_unref (tobject->big);
    tobject->big = NULL;
  }
  if (tobject->contain != NULL)
  {
    g_hash_table_destroy (tobject->contain);
    tobject->contain = NULL;
  }
  if (tobject->bonks != NULL)
  {
    g_hash_table_destroy (tobject->bonks);
    tobject->bonks = NULL;
  }
}

static void
t_test_holy_moley_class_init (TTestHolyMoleyClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_holy_moley_read;
  struct_class->write = t_test_holy_moley_write;

  gobject_class->finalize = t_test_holy_moley_finalize;
  gobject_class->get_property = t_test_holy_moley_get_property;
  gobject_class->set_property = t_test_holy_moley_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_HOLY_MOLEY_BIG,
     g_param_spec_boxed ("big",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_HOLY_MOLEY_CONTAIN,
     g_param_spec_boxed ("contain",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_HOLY_MOLEY_BONKS,
     g_param_spec_boxed ("bonks",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
t_test_holy_moley_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestHolyMoleyClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_holy_moley_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestHolyMoley),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_holy_moley_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestHolyMoleyType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestBackwardsProperties
{
  PROP_T_TEST_BACKWARDS_0,
  PROP_T_TEST_BACKWARDS_FIRST_TAG2,
  PROP_T_TEST_BACKWARDS_SECOND_TAG1
};

/* reads a backwards object */
static gint32
t_test_backwards_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestBackwards * this_object = T_TEST_BACKWARDS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->first_tag2, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_first_tag2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->second_tag1, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_second_tag1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_backwards_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestBackwards * this_object = T_TEST_BACKWARDS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Backwards", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "first_tag2", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->first_tag2, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "second_tag1", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->second_tag1, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_backwards_set_property (GObject *object,
                               guint property_id,
                               const GValue *value,
                               GParamSpec *pspec)
{
  TTestBackwards *self = T_TEST_BACKWARDS (object);

  switch (property_id)
  {
    case PROP_T_TEST_BACKWARDS_FIRST_TAG2:
      self->first_tag2 = g_value_get_int (value);
      self->__isset_first_tag2 = TRUE;
      break;

    case PROP_T_TEST_BACKWARDS_SECOND_TAG1:
      self->second_tag1 = g_value_get_int (value);
      self->__isset_second_tag1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_backwards_get_property (GObject *object,
                               guint property_id,
                               GValue *value,
                               GParamSpec *pspec)
{
  TTestBackwards *self = T_TEST_BACKWARDS (object);

  switch (property_id)
  {
    case PROP_T_TEST_BACKWARDS_FIRST_TAG2:
      g_value_set_int (value, self->first_tag2);
      break;

    case PROP_T_TEST_BACKWARDS_SECOND_TAG1:
      g_value_set_int (value, self->second_tag1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_backwards_instance_init (TTestBackwards * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->first_tag2 = 0;
  object->__isset_first_tag2 = FALSE;
  object->second_tag1 = 0;
  object->__isset_second_tag1 = FALSE;
}

static void 
t_test_backwards_finalize (GObject *object)
{
  TTestBackwards *tobject = T_TEST_BACKWARDS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_backwards_class_init (TTestBackwardsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_backwards_read;
  struct_class->write = t_test_backwards_write;

  gobject_class->finalize = t_test_backwards_finalize;
  gobject_class->get_property = t_test_backwards_get_property;
  gobject_class->set_property = t_test_backwards_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_BACKWARDS_FIRST_TAG2,
     g_param_spec_int ("first_tag2",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_BACKWARDS_SECOND_TAG1,
     g_param_spec_int ("second_tag1",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
t_test_backwards_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestBackwardsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_backwards_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestBackwards),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_backwards_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestBackwardsType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a empty object */
static gint32
t_test_empty_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestEmpty * this_object = T_TEST_EMPTY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_empty_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestEmpty * this_object = T_TEST_EMPTY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Empty", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_empty_instance_init (TTestEmpty * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
t_test_empty_finalize (GObject *object)
{
  TTestEmpty *tobject = T_TEST_EMPTY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_empty_class_init (TTestEmptyClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_empty_read;
  struct_class->write = t_test_empty_write;

  gobject_class->finalize = t_test_empty_finalize;
}

GType
t_test_empty_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestEmptyClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_empty_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestEmpty),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_empty_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestEmptyType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestWrapperProperties
{
  PROP_T_TEST_WRAPPER_0,
  PROP_T_TEST_WRAPPER_FOO
};

/* reads a wrapper object */
static gint32
t_test_wrapper_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestWrapper * this_object = T_TEST_WRAPPER(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->foo), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_foo = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_wrapper_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestWrapper * this_object = T_TEST_WRAPPER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Wrapper", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "foo", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->foo), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_wrapper_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  TTestWrapper *self = T_TEST_WRAPPER (object);

  switch (property_id)
  {
    case PROP_T_TEST_WRAPPER_FOO:
      if (self->foo != NULL)
        g_object_unref (self->foo);
      self->foo = g_value_dup_object (value);
      self->__isset_foo = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_wrapper_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  TTestWrapper *self = T_TEST_WRAPPER (object);

  switch (property_id)
  {
    case PROP_T_TEST_WRAPPER_FOO:
      g_value_set_object (value, self->foo);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_wrapper_instance_init (TTestWrapper * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->foo = g_object_new (T_TEST_TYPE_EMPTY, NULL);
  object->__isset_foo = FALSE;
}

static void 
t_test_wrapper_finalize (GObject *object)
{
  TTestWrapper *tobject = T_TEST_WRAPPER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->foo != NULL)
  {
    g_object_unref(tobject->foo);
    tobject->foo = NULL;
  }
}

static void
t_test_wrapper_class_init (TTestWrapperClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_wrapper_read;
  struct_class->write = t_test_wrapper_write;

  gobject_class->finalize = t_test_wrapper_finalize;
  gobject_class->get_property = t_test_wrapper_get_property;
  gobject_class->set_property = t_test_wrapper_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_WRAPPER_FOO,
     g_param_spec_object ("foo",
                         NULL,
                         NULL,
                         T_TEST_TYPE_EMPTY,
                         G_PARAM_READWRITE));
}

GType
t_test_wrapper_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestWrapperClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_wrapper_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestWrapper),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_wrapper_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestWrapperType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestRandomStuffProperties
{
  PROP_T_TEST_RANDOM_STUFF_0,
  PROP_T_TEST_RANDOM_STUFF_A,
  PROP_T_TEST_RANDOM_STUFF_B,
  PROP_T_TEST_RANDOM_STUFF_C,
  PROP_T_TEST_RANDOM_STUFF_D,
  PROP_T_TEST_RANDOM_STUFF_MYINTLIST,
  PROP_T_TEST_RANDOM_STUFF_MAPS,
  PROP_T_TEST_RANDOM_STUFF_BIGINT,
  PROP_T_TEST_RANDOM_STUFF_TRIPLE
};

/* reads a random_stuff object */
static gint32
t_test_random_stuff_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestRandomStuff * this_object = T_TEST_RANDOM_STUFF(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->a, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_a = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->b, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_b = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->c, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_c = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->d, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_d = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem17 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem17, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->myintlist, _elem17, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_myintlist = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint32* key18 = g_new (gint32, 1);
              TTestWrapper * val19 = NULL;
              if ((ret = thrift_protocol_read_i32 (protocol, &*key18, error)) < 0)
                return -1;
              xfer += ret;
              if ( val19 != NULL)
              {
                g_object_unref (val19);
              }
              val19 = g_object_new (T_TEST_TYPE_WRAPPER, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (val19), protocol, error)) < 0)
              {
                g_object_unref (val19);
                return -1;
              }
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->maps, (gpointer) key18, (gpointer) val19);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_maps = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->bigint, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_bigint = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->triple, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_triple = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_random_stuff_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestRandomStuff * this_object = T_TEST_RANDOM_STUFF(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RandomStuff", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "a", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->a, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "b", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->b, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "c", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->c, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "d", T_I32, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->d, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "myintlist", T_LIST, 5, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i20;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) this_object->myintlist->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i20 = 0; i20 < this_object->myintlist->len; i20++)
    {
      if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->myintlist, gint32, i20)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "maps", T_MAP, 6, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint32* key21 = g_new (gint32, 1);
    TTestWrapper * val22 = NULL;
    GList *key_list = NULL, *iter = NULL;
    gint32** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_STRUCT, (gint32) g_hash_table_size ((GHashTable *) this_object->maps), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->maps, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint32*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint32*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key21 = keys[i];
      val22 = (TTestWrapper *) g_hash_table_lookup (((GHashTable *) this_object->maps), (gpointer) key21);

      if ((ret = thrift_protocol_write_i32 (protocol, * key21, error)) < 0)
        return -1;
      if ((ret = thrift_struct_write (THRIFT_STRUCT ( val22), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "bigint", T_I64, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->bigint, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "triple", T_DOUBLE, 8, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->triple, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_random_stuff_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  TTestRandomStuff *self = T_TEST_RANDOM_STUFF (object);

  switch (property_id)
  {
    case PROP_T_TEST_RANDOM_STUFF_A:
      self->a = g_value_get_int (value);
      self->__isset_a = TRUE;
      break;

    case PROP_T_TEST_RANDOM_STUFF_B:
      self->b = g_value_get_int (value);
      self->__isset_b = TRUE;
      break;

    case PROP_T_TEST_RANDOM_STUFF_C:
      self->c = g_value_get_int (value);
      self->__isset_c = TRUE;
      break;

    case PROP_T_TEST_RANDOM_STUFF_D:
      self->d = g_value_get_int (value);
      self->__isset_d = TRUE;
      break;

    case PROP_T_TEST_RANDOM_STUFF_MYINTLIST:
      if (self->myintlist != NULL)
        g_array_unref (self->myintlist);
      self->myintlist = g_value_dup_boxed (value);
      self->__isset_myintlist = TRUE;
      break;

    case PROP_T_TEST_RANDOM_STUFF_MAPS:
      if (self->maps != NULL)
        g_hash_table_unref (self->maps);
      self->maps = g_value_dup_boxed (value);
      self->__isset_maps = TRUE;
      break;

    case PROP_T_TEST_RANDOM_STUFF_BIGINT:
      self->bigint = g_value_get_int64 (value);
      self->__isset_bigint = TRUE;
      break;

    case PROP_T_TEST_RANDOM_STUFF_TRIPLE:
      self->triple = g_value_get_double (value);
      self->__isset_triple = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_random_stuff_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  TTestRandomStuff *self = T_TEST_RANDOM_STUFF (object);

  switch (property_id)
  {
    case PROP_T_TEST_RANDOM_STUFF_A:
      g_value_set_int (value, self->a);
      break;

    case PROP_T_TEST_RANDOM_STUFF_B:
      g_value_set_int (value, self->b);
      break;

    case PROP_T_TEST_RANDOM_STUFF_C:
      g_value_set_int (value, self->c);
      break;

    case PROP_T_TEST_RANDOM_STUFF_D:
      g_value_set_int (value, self->d);
      break;

    case PROP_T_TEST_RANDOM_STUFF_MYINTLIST:
      g_value_set_boxed (value, self->myintlist);
      break;

    case PROP_T_TEST_RANDOM_STUFF_MAPS:
      g_value_set_boxed (value, self->maps);
      break;

    case PROP_T_TEST_RANDOM_STUFF_BIGINT:
      g_value_set_int64 (value, self->bigint);
      break;

    case PROP_T_TEST_RANDOM_STUFF_TRIPLE:
      g_value_set_double (value, self->triple);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_random_stuff_instance_init (TTestRandomStuff * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->a = 0;
  object->__isset_a = FALSE;
  object->b = 0;
  object->__isset_b = FALSE;
  object->c = 0;
  object->__isset_c = FALSE;
  object->d = 0;
  object->__isset_d = FALSE;
  object->myintlist = g_array_new (0, 1, sizeof (gint32));
  object->__isset_myintlist = FALSE;
  object->maps = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_object_unref);
  object->__isset_maps = FALSE;
  object->bigint = 0;
  object->__isset_bigint = FALSE;
  object->triple = 0;
  object->__isset_triple = FALSE;
}

static void 
t_test_random_stuff_finalize (GObject *object)
{
  TTestRandomStuff *tobject = T_TEST_RANDOM_STUFF (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->myintlist != NULL)
  {
    g_array_unref (tobject->myintlist);
    tobject->myintlist = NULL;
  }
  if (tobject->maps != NULL)
  {
    g_hash_table_destroy (tobject->maps);
    tobject->maps = NULL;
  }
}

static void
t_test_random_stuff_class_init (TTestRandomStuffClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_random_stuff_read;
  struct_class->write = t_test_random_stuff_write;

  gobject_class->finalize = t_test_random_stuff_finalize;
  gobject_class->get_property = t_test_random_stuff_get_property;
  gobject_class->set_property = t_test_random_stuff_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_RANDOM_STUFF_A,
     g_param_spec_int ("a",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_RANDOM_STUFF_B,
     g_param_spec_int ("b",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_RANDOM_STUFF_C,
     g_param_spec_int ("c",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_RANDOM_STUFF_D,
     g_param_spec_int ("d",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_RANDOM_STUFF_MYINTLIST,
     g_param_spec_boxed ("myintlist",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_RANDOM_STUFF_MAPS,
     g_param_spec_boxed ("maps",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_RANDOM_STUFF_BIGINT,
     g_param_spec_int64 ("bigint",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_RANDOM_STUFF_TRIPLE,
     g_param_spec_double ("triple",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));
}

GType
t_test_random_stuff_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestRandomStuffClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_random_stuff_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestRandomStuff),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_random_stuff_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestRandomStuffType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestBase64Properties
{
  PROP_T_TEST_BASE64_0,
  PROP_T_TEST_BASE64_A,
  PROP_T_TEST_BASE64_B1,
  PROP_T_TEST_BASE64_B2,
  PROP_T_TEST_BASE64_B3,
  PROP_T_TEST_BASE64_B4,
  PROP_T_TEST_BASE64_B5,
  PROP_T_TEST_BASE64_B6
};

/* reads a base64 object */
static gint32
t_test_base64_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestBase64 * this_object = T_TEST_BASE64(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->a, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_a = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->b1 != NULL)
          {
            g_free(this_object->b1);
            this_object->b1 = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->b1 = g_byte_array_new();
          g_byte_array_append (this_object->b1, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_b1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->b2 != NULL)
          {
            g_free(this_object->b2);
            this_object->b2 = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->b2 = g_byte_array_new();
          g_byte_array_append (this_object->b2, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_b2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->b3 != NULL)
          {
            g_free(this_object->b3);
            this_object->b3 = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->b3 = g_byte_array_new();
          g_byte_array_append (this_object->b3, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_b3 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->b4 != NULL)
          {
            g_free(this_object->b4);
            this_object->b4 = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->b4 = g_byte_array_new();
          g_byte_array_append (this_object->b4, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_b4 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->b5 != NULL)
          {
            g_free(this_object->b5);
            this_object->b5 = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->b5 = g_byte_array_new();
          g_byte_array_append (this_object->b5, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_b5 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRING)
        {
          if (this_object->b6 != NULL)
          {
            g_free(this_object->b6);
            this_object->b6 = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->b6 = g_byte_array_new();
          g_byte_array_append (this_object->b6, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_b6 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_base64_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestBase64 * this_object = T_TEST_BASE64(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Base64", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "a", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->a, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "b1", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->b1)->data, ((GByteArray *) this_object->b1)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "b2", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->b2)->data, ((GByteArray *) this_object->b2)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "b3", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->b3)->data, ((GByteArray *) this_object->b3)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "b4", T_STRING, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->b4)->data, ((GByteArray *) this_object->b4)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "b5", T_STRING, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->b5)->data, ((GByteArray *) this_object->b5)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "b6", T_STRING, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->b6)->data, ((GByteArray *) this_object->b6)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_base64_set_property (GObject *object,
                            guint property_id,
                            const GValue *value,
                            GParamSpec *pspec)
{
  TTestBase64 *self = T_TEST_BASE64 (object);

  switch (property_id)
  {
    case PROP_T_TEST_BASE64_A:
      self->a = g_value_get_int (value);
      self->__isset_a = TRUE;
      break;

    case PROP_T_TEST_BASE64_B1:
      if (self->b1 != NULL)
        g_byte_array_unref (self->b1);
      self->b1 = g_value_dup_boxed (value);
      self->__isset_b1 = TRUE;
      break;

    case PROP_T_TEST_BASE64_B2:
      if (self->b2 != NULL)
        g_byte_array_unref (self->b2);
      self->b2 = g_value_dup_boxed (value);
      self->__isset_b2 = TRUE;
      break;

    case PROP_T_TEST_BASE64_B3:
      if (self->b3 != NULL)
        g_byte_array_unref (self->b3);
      self->b3 = g_value_dup_boxed (value);
      self->__isset_b3 = TRUE;
      break;

    case PROP_T_TEST_BASE64_B4:
      if (self->b4 != NULL)
        g_byte_array_unref (self->b4);
      self->b4 = g_value_dup_boxed (value);
      self->__isset_b4 = TRUE;
      break;

    case PROP_T_TEST_BASE64_B5:
      if (self->b5 != NULL)
        g_byte_array_unref (self->b5);
      self->b5 = g_value_dup_boxed (value);
      self->__isset_b5 = TRUE;
      break;

    case PROP_T_TEST_BASE64_B6:
      if (self->b6 != NULL)
        g_byte_array_unref (self->b6);
      self->b6 = g_value_dup_boxed (value);
      self->__isset_b6 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_base64_get_property (GObject *object,
                            guint property_id,
                            GValue *value,
                            GParamSpec *pspec)
{
  TTestBase64 *self = T_TEST_BASE64 (object);

  switch (property_id)
  {
    case PROP_T_TEST_BASE64_A:
      g_value_set_int (value, self->a);
      break;

    case PROP_T_TEST_BASE64_B1:
      g_value_set_boxed (value, self->b1);
      break;

    case PROP_T_TEST_BASE64_B2:
      g_value_set_boxed (value, self->b2);
      break;

    case PROP_T_TEST_BASE64_B3:
      g_value_set_boxed (value, self->b3);
      break;

    case PROP_T_TEST_BASE64_B4:
      g_value_set_boxed (value, self->b4);
      break;

    case PROP_T_TEST_BASE64_B5:
      g_value_set_boxed (value, self->b5);
      break;

    case PROP_T_TEST_BASE64_B6:
      g_value_set_boxed (value, self->b6);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_base64_instance_init (TTestBase64 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->a = 0;
  object->__isset_a = FALSE;
  object->b1 = NULL;
  object->__isset_b1 = FALSE;
  object->b2 = NULL;
  object->__isset_b2 = FALSE;
  object->b3 = NULL;
  object->__isset_b3 = FALSE;
  object->b4 = NULL;
  object->__isset_b4 = FALSE;
  object->b5 = NULL;
  object->__isset_b5 = FALSE;
  object->b6 = NULL;
  object->__isset_b6 = FALSE;
}

static void 
t_test_base64_finalize (GObject *object)
{
  TTestBase64 *tobject = T_TEST_BASE64 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->b1 != NULL)
  {
    thrift_string_free(tobject->b1);
    tobject->b1 = NULL;
  }
  if (tobject->b2 != NULL)
  {
    thrift_string_free(tobject->b2);
    tobject->b2 = NULL;
  }
  if (tobject->b3 != NULL)
  {
    thrift_string_free(tobject->b3);
    tobject->b3 = NULL;
  }
  if (tobject->b4 != NULL)
  {
    thrift_string_free(tobject->b4);
    tobject->b4 = NULL;
  }
  if (tobject->b5 != NULL)
  {
    thrift_string_free(tobject->b5);
    tobject->b5 = NULL;
  }
  if (tobject->b6 != NULL)
  {
    thrift_string_free(tobject->b6);
    tobject->b6 = NULL;
  }
}

static void
t_test_base64_class_init (TTestBase64Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_base64_read;
  struct_class->write = t_test_base64_write;

  gobject_class->finalize = t_test_base64_finalize;
  gobject_class->get_property = t_test_base64_get_property;
  gobject_class->set_property = t_test_base64_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_BASE64_A,
     g_param_spec_int ("a",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_BASE64_B1,
     g_param_spec_boxed ("b1",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_BASE64_B2,
     g_param_spec_boxed ("b2",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_BASE64_B3,
     g_param_spec_boxed ("b3",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_BASE64_B4,
     g_param_spec_boxed ("b4",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_BASE64_B5,
     g_param_spec_boxed ("b5",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_BASE64_B6,
     g_param_spec_boxed ("b6",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_test_base64_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestBase64Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_base64_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestBase64),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_base64_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestBase64Type",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestCompactProtoTestStructProperties
{
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_0,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_A_BYTE,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_A_I16,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_A_I32,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_A_I64,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_A_DOUBLE,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_A_STRING,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_A_BINARY,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_TRUE_FIELD,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_FALSE_FIELD,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_EMPTY_STRUCT_FIELD,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_LIST,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I16_LIST,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I32_LIST,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I64_LIST,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_DOUBLE_LIST,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_STRING_LIST,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BINARY_LIST,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BOOLEAN_LIST,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_STRUCT_LIST,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_SET,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I16_SET,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I32_SET,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I64_SET,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_DOUBLE_SET,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_STRING_SET,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BINARY_SET,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BOOLEAN_SET,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_STRUCT_SET,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_BYTE_MAP,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I16_BYTE_MAP,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I32_BYTE_MAP,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I64_BYTE_MAP,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_DOUBLE_BYTE_MAP,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_STRING_BYTE_MAP,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BINARY_BYTE_MAP,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BOOLEAN_BYTE_MAP,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_I16_MAP,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_I32_MAP,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_I64_MAP,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_DOUBLE_MAP,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_STRING_MAP,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_BINARY_MAP,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_BOOLEAN_MAP,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_LIST_BYTE_MAP,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_SET_BYTE_MAP,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_MAP_BYTE_MAP,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_MAP_MAP,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_SET_MAP,
  PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_LIST_MAP
};

/* reads a compact_proto_test_struct object */
static gint32
t_test_compact_proto_test_struct_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestCompactProtoTestStruct * this_object = T_TEST_COMPACT_PROTO_TEST_STRUCT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->a_byte, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_a_byte = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->a_i16, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_a_i16 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->a_i32, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_a_i32 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->a_i64, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_a_i64 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->a_double, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_a_double = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->a_string != NULL)
          {
            g_free(this_object->a_string);
            this_object->a_string = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->a_string, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_a_string = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRING)
        {
          if (this_object->a_binary != NULL)
          {
            g_free(this_object->a_binary);
            this_object->a_binary = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->a_binary = g_byte_array_new();
          g_byte_array_append (this_object->a_binary, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_a_binary = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->true_field, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_true_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->false_field, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_false_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->empty_struct_field), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_empty_struct_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint8* _elem23 = g_new (gint8, 1);
              if ((ret = thrift_protocol_read_byte (protocol, &*_elem23, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->byte_list, _elem23, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_byte_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint16* _elem24 = g_new (gint16, 1);
              if ((ret = thrift_protocol_read_i16 (protocol, &*_elem24, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->i16_list, _elem24, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_i16_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 13:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem25 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem25, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->i32_list, _elem25, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_i32_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 14:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint64* _elem26 = g_new (gint64, 1);
              if ((ret = thrift_protocol_read_i64 (protocol, &*_elem26, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->i64_list, _elem26, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_i64_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 15:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gdouble* _elem27 = g_new (gdouble, 1);
              if ((ret = thrift_protocol_read_double (protocol, &*_elem27, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->double_list, _elem27, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_double_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 16:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem28 = NULL;
              if (_elem28 != NULL)
              {
                g_free(_elem28);
                _elem28 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem28, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->string_list, _elem28);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_string_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 17:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem29 = NULL;
              if (_elem29 != NULL)
              {
                g_free(_elem29);
                _elem29 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem29 = g_byte_array_new();
              g_byte_array_append (_elem29, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->binary_list, _elem29);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_binary_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 18:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gboolean* _elem30 = g_new (gboolean, 1);
              if ((ret = thrift_protocol_read_bool (protocol, &*_elem30, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->boolean_list, _elem30, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_boolean_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 19:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TTestEmpty * _elem31 = NULL;
              if ( _elem31 != NULL)
              {
                g_object_unref (_elem31);
              }
              _elem31 = g_object_new (T_TEST_TYPE_EMPTY, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem31), protocol, error)) < 0)
              {
                g_object_unref (_elem31);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->struct_list, _elem31);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_struct_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 20:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            for (i = 0; i < size; ++i)
            {
              gint8* _elem32 = g_new (gint8, 1);
              if ((ret = thrift_protocol_read_byte (protocol, &*_elem32, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *) this_object->byte_set, (gpointer) _elem32, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_byte_set = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 21:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            for (i = 0; i < size; ++i)
            {
              gint16* _elem33 = g_new (gint16, 1);
              if ((ret = thrift_protocol_read_i16 (protocol, &*_elem33, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *) this_object->i16_set, (gpointer) _elem33, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_i16_set = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 22:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            for (i = 0; i < size; ++i)
            {
              gint32* _elem34 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem34, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *) this_object->i32_set, (gpointer) _elem34, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_i32_set = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 23:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            for (i = 0; i < size; ++i)
            {
              gint64* _elem35 = g_new (gint64, 1);
              if ((ret = thrift_protocol_read_i64 (protocol, &*_elem35, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *) this_object->i64_set, (gpointer) _elem35, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_i64_set = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 24:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            for (i = 0; i < size; ++i)
            {
              gdouble* _elem36 = g_new (gdouble, 1);
              if ((ret = thrift_protocol_read_double (protocol, &*_elem36, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *) this_object->double_set, (gpointer) _elem36, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_double_set = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 25:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            for (i = 0; i < size; ++i)
            {
              gchar * _elem37 = NULL;
              if (_elem37 != NULL)
              {
                g_free(_elem37);
                _elem37 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem37, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *) this_object->string_set, (gpointer) _elem37, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_string_set = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 26:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            for (i = 0; i < size; ++i)
            {
              GByteArray * _elem38 = NULL;
              if (_elem38 != NULL)
              {
                g_free(_elem38);
                _elem38 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem38 = g_byte_array_new();
              g_byte_array_append (_elem38, (guint8 *) data, (guint) len);
              g_free (data);
              g_hash_table_insert ((GHashTable *) this_object->binary_set, (gpointer) _elem38, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_binary_set = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 27:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            for (i = 0; i < size; ++i)
            {
              gboolean* _elem39 = g_new (gboolean, 1);
              if ((ret = thrift_protocol_read_bool (protocol, &*_elem39, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *) this_object->boolean_set, (gpointer) _elem39, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_boolean_set = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 28:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            for (i = 0; i < size; ++i)
            {
              TTestEmpty * _elem40 = NULL;
              if ( _elem40 != NULL)
              {
                g_object_unref (_elem40);
              }
              _elem40 = g_object_new (T_TEST_TYPE_EMPTY, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem40), protocol, error)) < 0)
              {
                g_object_unref (_elem40);
                return -1;
              }
              xfer += ret;
              g_hash_table_insert ((GHashTable *) this_object->struct_set, (gpointer) _elem40, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_struct_set = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 29:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint8* key41 = g_new (gint8, 1);
              gint8* val42 = g_new (gint8, 1);
              if ((ret = thrift_protocol_read_byte (protocol, &*key41, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_byte (protocol, &*val42, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->byte_byte_map, (gpointer) key41, (gpointer) val42);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_byte_byte_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 30:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint16* key43 = g_new (gint16, 1);
              gint8* val44 = g_new (gint8, 1);
              if ((ret = thrift_protocol_read_i16 (protocol, &*key43, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_byte (protocol, &*val44, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->i16_byte_map, (gpointer) key43, (gpointer) val44);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_i16_byte_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 31:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint32* key45 = g_new (gint32, 1);
              gint8* val46 = g_new (gint8, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*key45, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_byte (protocol, &*val46, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->i32_byte_map, (gpointer) key45, (gpointer) val46);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_i32_byte_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 32:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint64* key47 = g_new (gint64, 1);
              gint8* val48 = g_new (gint8, 1);
              if ((ret = thrift_protocol_read_i64 (protocol, &*key47, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_byte (protocol, &*val48, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->i64_byte_map, (gpointer) key47, (gpointer) val48);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_i64_byte_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 33:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gdouble* key49 = g_new (gdouble, 1);
              gint8* val50 = g_new (gint8, 1);
              if ((ret = thrift_protocol_read_double (protocol, &*key49, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_byte (protocol, &*val50, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->double_byte_map, (gpointer) key49, (gpointer) val50);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_double_byte_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 34:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key51 = NULL;
              gint8* val52 = g_new (gint8, 1);
              if (key51 != NULL)
              {
                g_free(key51);
                key51 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key51, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_byte (protocol, &*val52, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->string_byte_map, (gpointer) key51, (gpointer) val52);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_string_byte_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 35:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              GByteArray * key53 = NULL;
              gint8* val54 = g_new (gint8, 1);
              if (key53 != NULL)
              {
                g_free(key53);
                key53 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key53 = g_byte_array_new();
              g_byte_array_append (key53, (guint8 *) data, (guint) len);
              g_free (data);
              if ((ret = thrift_protocol_read_byte (protocol, &*val54, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->binary_byte_map, (gpointer) key53, (gpointer) val54);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_binary_byte_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 36:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gboolean* key55 = g_new (gboolean, 1);
              gint8* val56 = g_new (gint8, 1);
              if ((ret = thrift_protocol_read_bool (protocol, &*key55, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_byte (protocol, &*val56, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->boolean_byte_map, (gpointer) key55, (gpointer) val56);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_boolean_byte_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 37:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint8* key57 = g_new (gint8, 1);
              gint16* val58 = g_new (gint16, 1);
              if ((ret = thrift_protocol_read_byte (protocol, &*key57, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_i16 (protocol, &*val58, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->byte_i16_map, (gpointer) key57, (gpointer) val58);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_byte_i16_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 38:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint8* key59 = g_new (gint8, 1);
              gint32* val60 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_byte (protocol, &*key59, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_i32 (protocol, &*val60, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->byte_i32_map, (gpointer) key59, (gpointer) val60);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_byte_i32_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 39:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint8* key61 = g_new (gint8, 1);
              gint64* val62 = g_new (gint64, 1);
              if ((ret = thrift_protocol_read_byte (protocol, &*key61, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_i64 (protocol, &*val62, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->byte_i64_map, (gpointer) key61, (gpointer) val62);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_byte_i64_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 40:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint8* key63 = g_new (gint8, 1);
              gdouble* val64 = g_new (gdouble, 1);
              if ((ret = thrift_protocol_read_byte (protocol, &*key63, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_double (protocol, &*val64, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->byte_double_map, (gpointer) key63, (gpointer) val64);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_byte_double_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 41:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint8* key65 = g_new (gint8, 1);
              gchar * val66 = NULL;
              if ((ret = thrift_protocol_read_byte (protocol, &*key65, error)) < 0)
                return -1;
              xfer += ret;
              if (val66 != NULL)
              {
                g_free(val66);
                val66 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val66, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->byte_string_map, (gpointer) key65, (gpointer) val66);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_byte_string_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 42:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint8* key67 = g_new (gint8, 1);
              GByteArray * val68 = NULL;
              if ((ret = thrift_protocol_read_byte (protocol, &*key67, error)) < 0)
                return -1;
              xfer += ret;
              if (val68 != NULL)
              {
                g_free(val68);
                val68 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val68 = g_byte_array_new();
              g_byte_array_append (val68, (guint8 *) data, (guint) len);
              g_free (data);
              g_hash_table_insert ((GHashTable *)this_object->byte_binary_map, (gpointer) key67, (gpointer) val68);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_byte_binary_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 43:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint8* key69 = g_new (gint8, 1);
              gboolean* val70 = g_new (gboolean, 1);
              if ((ret = thrift_protocol_read_byte (protocol, &*key69, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_bool (protocol, &*val70, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->byte_boolean_map, (gpointer) key69, (gpointer) val70);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_byte_boolean_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 44:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              GArray * key71 = g_array_new (0, 1, sizeof (gint8));
              gint8* val72 = g_new (gint8, 1);
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                for (i = 0; i < size; i++)
                {
                  gint8* _elem73 = g_new (gint8, 1);
                  if ((ret = thrift_protocol_read_byte (protocol, &*_elem73, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_array_append_vals (key71, _elem73, 1);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              if ((ret = thrift_protocol_read_byte (protocol, &*val72, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->list_byte_map, (gpointer) key71, (gpointer) val72);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_list_byte_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 45:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              GHashTable * key74 = NULL;
              gint8* val75 = g_new (gint8, 1);
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through the set elements */
                for (i = 0; i < size; ++i)
                {
                  gint8* _elem76 = g_new (gint8, 1);
                  if ((ret = thrift_protocol_read_byte (protocol, &*_elem76, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_hash_table_insert ((GHashTable *) key74, (gpointer) _elem76, (gpointer) 1);
                }
                if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;

              }
              if ((ret = thrift_protocol_read_byte (protocol, &*val75, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->set_byte_map, (gpointer) key74, (gpointer) val75);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_set_byte_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 46:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              GHashTable * key77 = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_free);
              gint8* val78 = g_new (gint8, 1);
              {
                guint32 size;
                guint32 i;
                ThriftType key_type;
                ThriftType value_type;

                /* read the map begin marker */
                if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through each of the map's fields */
                for (i = 0; i < size; i++)
                {
                  gint8* key79 = g_new (gint8, 1);
                  gint8* val80 = g_new (gint8, 1);
                  if ((ret = thrift_protocol_read_byte (protocol, &*key79, error)) < 0)
                    return -1;
                  xfer += ret;
                  if ((ret = thrift_protocol_read_byte (protocol, &*val80, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_hash_table_insert ((GHashTable *)key77, (gpointer) key79, (gpointer) val80);
                }

                /* read the map end marker */
                if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              if ((ret = thrift_protocol_read_byte (protocol, &*val78, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->map_byte_map, (gpointer) key77, (gpointer) val78);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_map_byte_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 47:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint8* key81 = g_new (gint8, 1);
              GHashTable * val82 = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_free);
              if ((ret = thrift_protocol_read_byte (protocol, &*key81, error)) < 0)
                return -1;
              xfer += ret;
              {
                guint32 size;
                guint32 i;
                ThriftType key_type;
                ThriftType value_type;

                /* read the map begin marker */
                if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through each of the map's fields */
                for (i = 0; i < size; i++)
                {
                  gint8* key83 = g_new (gint8, 1);
                  gint8* val84 = g_new (gint8, 1);
                  if ((ret = thrift_protocol_read_byte (protocol, &*key83, error)) < 0)
                    return -1;
                  xfer += ret;
                  if ((ret = thrift_protocol_read_byte (protocol, &*val84, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_hash_table_insert ((GHashTable *)val82, (gpointer) key83, (gpointer) val84);
                }

                /* read the map end marker */
                if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              g_hash_table_insert ((GHashTable *)this_object->byte_map_map, (gpointer) key81, (gpointer) val82);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_byte_map_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 48:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint8* key85 = g_new (gint8, 1);
              GHashTable * val86 = NULL;
              if ((ret = thrift_protocol_read_byte (protocol, &*key85, error)) < 0)
                return -1;
              xfer += ret;
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through the set elements */
                for (i = 0; i < size; ++i)
                {
                  gint8* _elem87 = g_new (gint8, 1);
                  if ((ret = thrift_protocol_read_byte (protocol, &*_elem87, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_hash_table_insert ((GHashTable *) val86, (gpointer) _elem87, (gpointer) 1);
                }
                if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;

              }
              g_hash_table_insert ((GHashTable *)this_object->byte_set_map, (gpointer) key85, (gpointer) val86);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_byte_set_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 49:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint8* key88 = g_new (gint8, 1);
              GArray * val89 = g_array_new (0, 1, sizeof (gint8));
              if ((ret = thrift_protocol_read_byte (protocol, &*key88, error)) < 0)
                return -1;
              xfer += ret;
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                for (i = 0; i < size; i++)
                {
                  gint8* _elem90 = g_new (gint8, 1);
                  if ((ret = thrift_protocol_read_byte (protocol, &*_elem90, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_array_append_vals (val89, _elem90, 1);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              g_hash_table_insert ((GHashTable *)this_object->byte_list_map, (gpointer) key88, (gpointer) val89);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_byte_list_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_compact_proto_test_struct_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestCompactProtoTestStruct * this_object = T_TEST_COMPACT_PROTO_TEST_STRUCT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CompactProtoTestStruct", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "a_byte", T_BYTE, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->a_byte, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "a_i16", T_I16, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->a_i16, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "a_i32", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->a_i32, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "a_i64", T_I64, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->a_i64, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "a_double", T_DOUBLE, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->a_double, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "a_string", T_STRING, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->a_string, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "a_binary", T_STRING, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->a_binary)->data, ((GByteArray *) this_object->a_binary)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "true_field", T_BOOL, 8, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->true_field, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "false_field", T_BOOL, 9, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->false_field, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "empty_struct_field", T_STRUCT, 10, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->empty_struct_field), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_list", T_LIST, 11, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i91;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_BYTE, (gint32) this_object->byte_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i91 = 0; i91 < this_object->byte_list->len; i91++)
    {
      if ((ret = thrift_protocol_write_byte (protocol, (g_array_index (this_object->byte_list, gint8, i91)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i16_list", T_LIST, 12, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i92;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I16, (gint32) this_object->i16_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i92 = 0; i92 < this_object->i16_list->len; i92++)
    {
      if ((ret = thrift_protocol_write_i16 (protocol, (g_array_index (this_object->i16_list, gint16, i92)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i32_list", T_LIST, 13, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i93;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) this_object->i32_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i93 = 0; i93 < this_object->i32_list->len; i93++)
    {
      if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->i32_list, gint32, i93)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i64_list", T_LIST, 14, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i94;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I64, (gint32) this_object->i64_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i94 = 0; i94 < this_object->i64_list->len; i94++)
    {
      if ((ret = thrift_protocol_write_i64 (protocol, (g_array_index (this_object->i64_list, gint64, i94)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "double_list", T_LIST, 15, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i95;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_DOUBLE, (gint32) this_object->double_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i95 = 0; i95 < this_object->double_list->len; i95++)
    {
      if ((ret = thrift_protocol_write_double (protocol, (g_array_index (this_object->double_list, gdouble, i95)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "string_list", T_LIST, 16, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i96;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) this_object->string_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i96 = 0; i96 < this_object->string_list->len; i96++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->string_list, i96)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "binary_list", T_LIST, 17, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i97;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) this_object->binary_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i97 = 0; i97 < this_object->binary_list->len; i97++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->binary_list, i97)))->data, ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->binary_list, i97)))->len, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "boolean_list", T_LIST, 18, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i98;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_BOOL, (gint32) this_object->boolean_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i98 = 0; i98 < this_object->boolean_list->len; i98++)
    {
      if ((ret = thrift_protocol_write_bool (protocol, (g_array_index (this_object->boolean_list, gboolean, i98)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "struct_list", T_LIST, 19, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i99;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->struct_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i99 = 0; i99 < this_object->struct_list->len; i99++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->struct_list, i99))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_set", T_SET, 20, error)) < 0)
    return -1;
  xfer += ret;
  {
    GList *key_list = NULL, *iter = NULL;
    gint8** keys;
    int i = 0, key_count;
    gint8* elem;
    gpointer value;
    THRIFT_UNUSED_VAR (value);

    if ((ret = thrift_protocol_write_set_begin (protocol, T_BYTE, (gint32) g_hash_table_size ((GHashTable *) this_object->byte_set), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->byte_set, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint8*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint8*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      elem = keys[i];
      value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->byte_set), (gpointer) elem);

      if ((ret = thrift_protocol_write_byte (protocol, *elem, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i16_set", T_SET, 21, error)) < 0)
    return -1;
  xfer += ret;
  {
    GList *key_list = NULL, *iter = NULL;
    gint16** keys;
    int i = 0, key_count;
    gint16* elem;
    gpointer value;
    THRIFT_UNUSED_VAR (value);

    if ((ret = thrift_protocol_write_set_begin (protocol, T_I16, (gint32) g_hash_table_size ((GHashTable *) this_object->i16_set), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->i16_set, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint16*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint16*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      elem = keys[i];
      value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->i16_set), (gpointer) elem);

      if ((ret = thrift_protocol_write_i16 (protocol, *elem, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i32_set", T_SET, 22, error)) < 0)
    return -1;
  xfer += ret;
  {
    GList *key_list = NULL, *iter = NULL;
    gint32** keys;
    int i = 0, key_count;
    gint32* elem;
    gpointer value;
    THRIFT_UNUSED_VAR (value);

    if ((ret = thrift_protocol_write_set_begin (protocol, T_I32, (gint32) g_hash_table_size ((GHashTable *) this_object->i32_set), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->i32_set, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint32*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint32*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      elem = keys[i];
      value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->i32_set), (gpointer) elem);

      if ((ret = thrift_protocol_write_i32 (protocol, *elem, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i64_set", T_SET, 23, error)) < 0)
    return -1;
  xfer += ret;
  {
    GList *key_list = NULL, *iter = NULL;
    gint64** keys;
    int i = 0, key_count;
    gint64* elem;
    gpointer value;
    THRIFT_UNUSED_VAR (value);

    if ((ret = thrift_protocol_write_set_begin (protocol, T_I64, (gint32) g_hash_table_size ((GHashTable *) this_object->i64_set), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->i64_set, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint64*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint64*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      elem = keys[i];
      value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->i64_set), (gpointer) elem);

      if ((ret = thrift_protocol_write_i64 (protocol, *elem, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "double_set", T_SET, 24, error)) < 0)
    return -1;
  xfer += ret;
  {
    GList *key_list = NULL, *iter = NULL;
    gdouble** keys;
    int i = 0, key_count;
    gdouble* elem;
    gpointer value;
    THRIFT_UNUSED_VAR (value);

    if ((ret = thrift_protocol_write_set_begin (protocol, T_DOUBLE, (gint32) g_hash_table_size ((GHashTable *) this_object->double_set), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->double_set, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gdouble*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gdouble*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      elem = keys[i];
      value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->double_set), (gpointer) elem);

      if ((ret = thrift_protocol_write_double (protocol, *elem, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "string_set", T_SET, 25, error)) < 0)
    return -1;
  xfer += ret;
  {
    GList *key_list = NULL, *iter = NULL;
    gchar ** keys;
    int i = 0, key_count;
    gchar * elem;
    gpointer value;
    THRIFT_UNUSED_VAR (value);

    if ((ret = thrift_protocol_write_set_begin (protocol, T_STRING, (gint32) g_hash_table_size ((GHashTable *) this_object->string_set), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->string_set, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gchar *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gchar *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      elem = keys[i];
      value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->string_set), (gpointer) elem);

      if ((ret = thrift_protocol_write_string (protocol, elem, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "binary_set", T_SET, 26, error)) < 0)
    return -1;
  xfer += ret;
  {
    GList *key_list = NULL, *iter = NULL;
    GByteArray ** keys;
    int i = 0, key_count;
    GByteArray * elem;
    gpointer value;
    THRIFT_UNUSED_VAR (value);

    if ((ret = thrift_protocol_write_set_begin (protocol, T_STRING, (gint32) g_hash_table_size ((GHashTable *) this_object->binary_set), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->binary_set, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (GByteArray *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (GByteArray *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      elem = keys[i];
      value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->binary_set), (gpointer) elem);

      if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) elem)->data, ((GByteArray *) elem)->len, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "boolean_set", T_SET, 27, error)) < 0)
    return -1;
  xfer += ret;
  {
    GList *key_list = NULL, *iter = NULL;
    gboolean** keys;
    int i = 0, key_count;
    gboolean* elem;
    gpointer value;
    THRIFT_UNUSED_VAR (value);

    if ((ret = thrift_protocol_write_set_begin (protocol, T_BOOL, (gint32) g_hash_table_size ((GHashTable *) this_object->boolean_set), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->boolean_set, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gboolean*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gboolean*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      elem = keys[i];
      value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->boolean_set), (gpointer) elem);

      if ((ret = thrift_protocol_write_bool (protocol, *elem, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "struct_set", T_SET, 28, error)) < 0)
    return -1;
  xfer += ret;
  {
    GList *key_list = NULL, *iter = NULL;
    TTestEmpty ** keys;
    int i = 0, key_count;
    TTestEmpty * elem;
    gpointer value;
    THRIFT_UNUSED_VAR (value);

    if ((ret = thrift_protocol_write_set_begin (protocol, T_STRUCT, (gint32) g_hash_table_size ((GHashTable *) this_object->struct_set), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->struct_set, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (TTestEmpty *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (TTestEmpty *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      elem = keys[i];
      value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->struct_set), (gpointer) elem);

      if ((ret = thrift_struct_write (THRIFT_STRUCT (elem), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_byte_map", T_MAP, 29, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint8* key100 = g_new (gint8, 1);
    gint8* val101 = g_new (gint8, 1);
    GList *key_list = NULL, *iter = NULL;
    gint8** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_BYTE, T_BYTE, (gint32) g_hash_table_size ((GHashTable *) this_object->byte_byte_map), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->byte_byte_map, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint8*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint8*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key100 = keys[i];
      val101 = (gint8*) g_hash_table_lookup (((GHashTable *) this_object->byte_byte_map), (gpointer) key100);

      if ((ret = thrift_protocol_write_byte (protocol, * key100, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_byte (protocol, * val101, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i16_byte_map", T_MAP, 30, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint16* key102 = g_new (gint16, 1);
    gint8* val103 = g_new (gint8, 1);
    GList *key_list = NULL, *iter = NULL;
    gint16** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_I16, T_BYTE, (gint32) g_hash_table_size ((GHashTable *) this_object->i16_byte_map), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->i16_byte_map, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint16*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint16*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key102 = keys[i];
      val103 = (gint8*) g_hash_table_lookup (((GHashTable *) this_object->i16_byte_map), (gpointer) key102);

      if ((ret = thrift_protocol_write_i16 (protocol, * key102, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_byte (protocol, * val103, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i32_byte_map", T_MAP, 31, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint32* key104 = g_new (gint32, 1);
    gint8* val105 = g_new (gint8, 1);
    GList *key_list = NULL, *iter = NULL;
    gint32** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_BYTE, (gint32) g_hash_table_size ((GHashTable *) this_object->i32_byte_map), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->i32_byte_map, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint32*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint32*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key104 = keys[i];
      val105 = (gint8*) g_hash_table_lookup (((GHashTable *) this_object->i32_byte_map), (gpointer) key104);

      if ((ret = thrift_protocol_write_i32 (protocol, * key104, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_byte (protocol, * val105, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i64_byte_map", T_MAP, 32, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint64* key106 = g_new (gint64, 1);
    gint8* val107 = g_new (gint8, 1);
    GList *key_list = NULL, *iter = NULL;
    gint64** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_I64, T_BYTE, (gint32) g_hash_table_size ((GHashTable *) this_object->i64_byte_map), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->i64_byte_map, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint64*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint64*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key106 = keys[i];
      val107 = (gint8*) g_hash_table_lookup (((GHashTable *) this_object->i64_byte_map), (gpointer) key106);

      if ((ret = thrift_protocol_write_i64 (protocol, * key106, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_byte (protocol, * val107, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "double_byte_map", T_MAP, 33, error)) < 0)
    return -1;
  xfer += ret;
  {
    gdouble* key108 = g_new (gdouble, 1);
    gint8* val109 = g_new (gint8, 1);
    GList *key_list = NULL, *iter = NULL;
    gdouble** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_DOUBLE, T_BYTE, (gint32) g_hash_table_size ((GHashTable *) this_object->double_byte_map), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->double_byte_map, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gdouble*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gdouble*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key108 = keys[i];
      val109 = (gint8*) g_hash_table_lookup (((GHashTable *) this_object->double_byte_map), (gpointer) key108);

      if ((ret = thrift_protocol_write_double (protocol, * key108, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_byte (protocol, * val109, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "string_byte_map", T_MAP, 34, error)) < 0)
    return -1;
  xfer += ret;
  {
    gchar * key110 = NULL;
    gint8* val111 = g_new (gint8, 1);
    GList *key_list = NULL, *iter = NULL;
    gchar ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_BYTE, (gint32) g_hash_table_size ((GHashTable *) this_object->string_byte_map), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->string_byte_map, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gchar *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gchar *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key110 = keys[i];
      val111 = (gint8*) g_hash_table_lookup (((GHashTable *) this_object->string_byte_map), (gpointer) key110);

      if ((ret = thrift_protocol_write_string (protocol,  key110, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_byte (protocol, * val111, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "binary_byte_map", T_MAP, 35, error)) < 0)
    return -1;
  xfer += ret;
  {
    GByteArray * key112 = NULL;
    gint8* val113 = g_new (gint8, 1);
    GList *key_list = NULL, *iter = NULL;
    GByteArray ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_BYTE, (gint32) g_hash_table_size ((GHashTable *) this_object->binary_byte_map), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->binary_byte_map, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (GByteArray *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (GByteArray *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key112 = keys[i];
      val113 = (gint8*) g_hash_table_lookup (((GHashTable *) this_object->binary_byte_map), (gpointer) key112);

      if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *)  key112)->data, ((GByteArray *)  key112)->len, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_byte (protocol, * val113, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "boolean_byte_map", T_MAP, 36, error)) < 0)
    return -1;
  xfer += ret;
  {
    gboolean* key114 = g_new (gboolean, 1);
    gint8* val115 = g_new (gint8, 1);
    GList *key_list = NULL, *iter = NULL;
    gboolean** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_BOOL, T_BYTE, (gint32) g_hash_table_size ((GHashTable *) this_object->boolean_byte_map), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->boolean_byte_map, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gboolean*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gboolean*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key114 = keys[i];
      val115 = (gint8*) g_hash_table_lookup (((GHashTable *) this_object->boolean_byte_map), (gpointer) key114);

      if ((ret = thrift_protocol_write_bool (protocol, * key114, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_byte (protocol, * val115, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_i16_map", T_MAP, 37, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint8* key116 = g_new (gint8, 1);
    gint16* val117 = g_new (gint16, 1);
    GList *key_list = NULL, *iter = NULL;
    gint8** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_BYTE, T_I16, (gint32) g_hash_table_size ((GHashTable *) this_object->byte_i16_map), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->byte_i16_map, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint8*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint8*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key116 = keys[i];
      val117 = (gint16*) g_hash_table_lookup (((GHashTable *) this_object->byte_i16_map), (gpointer) key116);

      if ((ret = thrift_protocol_write_byte (protocol, * key116, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_i16 (protocol, * val117, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_i32_map", T_MAP, 38, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint8* key118 = g_new (gint8, 1);
    gint32* val119 = g_new (gint32, 1);
    GList *key_list = NULL, *iter = NULL;
    gint8** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_BYTE, T_I32, (gint32) g_hash_table_size ((GHashTable *) this_object->byte_i32_map), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->byte_i32_map, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint8*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint8*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key118 = keys[i];
      val119 = (gint32*) g_hash_table_lookup (((GHashTable *) this_object->byte_i32_map), (gpointer) key118);

      if ((ret = thrift_protocol_write_byte (protocol, * key118, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_i32 (protocol, * val119, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_i64_map", T_MAP, 39, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint8* key120 = g_new (gint8, 1);
    gint64* val121 = g_new (gint64, 1);
    GList *key_list = NULL, *iter = NULL;
    gint8** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_BYTE, T_I64, (gint32) g_hash_table_size ((GHashTable *) this_object->byte_i64_map), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->byte_i64_map, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint8*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint8*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key120 = keys[i];
      val121 = (gint64*) g_hash_table_lookup (((GHashTable *) this_object->byte_i64_map), (gpointer) key120);

      if ((ret = thrift_protocol_write_byte (protocol, * key120, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_i64 (protocol, * val121, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_double_map", T_MAP, 40, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint8* key122 = g_new (gint8, 1);
    gdouble* val123 = g_new (gdouble, 1);
    GList *key_list = NULL, *iter = NULL;
    gint8** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_BYTE, T_DOUBLE, (gint32) g_hash_table_size ((GHashTable *) this_object->byte_double_map), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->byte_double_map, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint8*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint8*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key122 = keys[i];
      val123 = (gdouble*) g_hash_table_lookup (((GHashTable *) this_object->byte_double_map), (gpointer) key122);

      if ((ret = thrift_protocol_write_byte (protocol, * key122, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_double (protocol, * val123, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_string_map", T_MAP, 41, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint8* key124 = g_new (gint8, 1);
    gchar * val125 = NULL;
    GList *key_list = NULL, *iter = NULL;
    gint8** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_BYTE, T_STRING, (gint32) g_hash_table_size ((GHashTable *) this_object->byte_string_map), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->byte_string_map, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint8*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint8*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key124 = keys[i];
      val125 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->byte_string_map), (gpointer) key124);

      if ((ret = thrift_protocol_write_byte (protocol, * key124, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_string (protocol,  val125, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_binary_map", T_MAP, 42, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint8* key126 = g_new (gint8, 1);
    GByteArray * val127 = NULL;
    GList *key_list = NULL, *iter = NULL;
    gint8** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_BYTE, T_STRING, (gint32) g_hash_table_size ((GHashTable *) this_object->byte_binary_map), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->byte_binary_map, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint8*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint8*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key126 = keys[i];
      val127 = (GByteArray *) g_hash_table_lookup (((GHashTable *) this_object->byte_binary_map), (gpointer) key126);

      if ((ret = thrift_protocol_write_byte (protocol, * key126, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *)  val127)->data, ((GByteArray *)  val127)->len, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_boolean_map", T_MAP, 43, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint8* key128 = g_new (gint8, 1);
    gboolean* val129 = g_new (gboolean, 1);
    GList *key_list = NULL, *iter = NULL;
    gint8** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_BYTE, T_BOOL, (gint32) g_hash_table_size ((GHashTable *) this_object->byte_boolean_map), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->byte_boolean_map, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint8*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint8*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key128 = keys[i];
      val129 = (gboolean*) g_hash_table_lookup (((GHashTable *) this_object->byte_boolean_map), (gpointer) key128);

      if ((ret = thrift_protocol_write_byte (protocol, * key128, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_bool (protocol, * val129, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "list_byte_map", T_MAP, 44, error)) < 0)
    return -1;
  xfer += ret;
  {
    GArray * key130 = g_array_new (0, 1, sizeof (gint8));
    gint8* val131 = g_new (gint8, 1);
    GList *key_list = NULL, *iter = NULL;
    GArray ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_LIST, T_BYTE, (gint32) g_hash_table_size ((GHashTable *) this_object->list_byte_map), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->list_byte_map, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (GArray *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (GArray *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key130 = keys[i];
      val131 = (gint8*) g_hash_table_lookup (((GHashTable *) this_object->list_byte_map), (gpointer) key130);

      {
        guint i132;

        if ((ret = thrift_protocol_write_list_begin (protocol, T_BYTE, (gint32)  key130->len, error)) < 0)
          return -1;
        xfer += ret;
        for (i132 = 0; i132 <  key130->len; i132++)
        {
          if ((ret = thrift_protocol_write_byte (protocol, (g_array_index ( key130, gint8, i132)), error)) < 0)
            return -1;
        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
      if ((ret = thrift_protocol_write_byte (protocol, * val131, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "set_byte_map", T_MAP, 45, error)) < 0)
    return -1;
  xfer += ret;
  {
    GHashTable * key133 = NULL;
    gint8* val134 = g_new (gint8, 1);
    GList *key_list = NULL, *iter = NULL;
    GHashTable ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_SET, T_BYTE, (gint32) g_hash_table_size ((GHashTable *) this_object->set_byte_map), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->set_byte_map, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (GHashTable *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (GHashTable *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key133 = keys[i];
      val134 = (gint8*) g_hash_table_lookup (((GHashTable *) this_object->set_byte_map), (gpointer) key133);

      {
        GList *key_list = NULL, *iter = NULL;
        gint8** keys;
        int i = 0, key_count;
        gint8* elem;
        gpointer value;
        THRIFT_UNUSED_VAR (value);

        if ((ret = thrift_protocol_write_set_begin (protocol, T_BYTE, (gint32) g_hash_table_size ((GHashTable *)  key133), error)) < 0)
          return -1;
        xfer += ret;
        g_hash_table_foreach ((GHashTable *)  key133, thrift_hash_table_get_keys, &key_list);
        key_count = g_list_length (key_list);
        keys = g_newa (gint8*, key_count);
        for (iter = g_list_first (key_list); iter; iter = iter->next)
          keys[i++] = (gint8*) iter->data;
        g_list_free (key_list);

        for (i = 0; i < key_count; ++i)
        {
          elem = keys[i];
          value = (gpointer) g_hash_table_lookup (((GHashTable *)  key133), (gpointer) elem);

          if ((ret = thrift_protocol_write_byte (protocol, *elem, error)) < 0)
            return -1;
        }
        if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
      if ((ret = thrift_protocol_write_byte (protocol, * val134, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "map_byte_map", T_MAP, 46, error)) < 0)
    return -1;
  xfer += ret;
  {
    GHashTable * key135 = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_free);
    gint8* val136 = g_new (gint8, 1);
    GList *key_list = NULL, *iter = NULL;
    GHashTable ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_MAP, T_BYTE, (gint32) g_hash_table_size ((GHashTable *) this_object->map_byte_map), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->map_byte_map, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (GHashTable *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (GHashTable *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key135 = keys[i];
      val136 = (gint8*) g_hash_table_lookup (((GHashTable *) this_object->map_byte_map), (gpointer) key135);

      {
        gint8* key137 = g_new (gint8, 1);
        gint8* val138 = g_new (gint8, 1);
        GList *key_list = NULL, *iter = NULL;
        gint8** keys;
        int i = 0, key_count;

        if ((ret = thrift_protocol_write_map_begin (protocol, T_BYTE, T_BYTE, (gint32) g_hash_table_size ((GHashTable *)  key135), error)) < 0)
          return -1;
        xfer += ret;
        g_hash_table_foreach ((GHashTable *)  key135, thrift_hash_table_get_keys, &key_list);
        key_count = g_list_length (key_list);
        keys = g_newa (gint8*, key_count);
        for (iter = g_list_first (key_list); iter; iter = iter->next)
          keys[i++] = (gint8*) iter->data;
        g_list_free (key_list);

        for (i = 0; i < key_count; ++i)
        {
          key137 = keys[i];
          val138 = (gint8*) g_hash_table_lookup (((GHashTable *)  key135), (gpointer) key137);

          if ((ret = thrift_protocol_write_byte (protocol, * key137, error)) < 0)
            return -1;
          if ((ret = thrift_protocol_write_byte (protocol, * val138, error)) < 0)
            return -1;
        }
        if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
      if ((ret = thrift_protocol_write_byte (protocol, * val136, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_map_map", T_MAP, 47, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint8* key139 = g_new (gint8, 1);
    GHashTable * val140 = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_free);
    GList *key_list = NULL, *iter = NULL;
    gint8** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_BYTE, T_MAP, (gint32) g_hash_table_size ((GHashTable *) this_object->byte_map_map), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->byte_map_map, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint8*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint8*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key139 = keys[i];
      val140 = (GHashTable *) g_hash_table_lookup (((GHashTable *) this_object->byte_map_map), (gpointer) key139);

      if ((ret = thrift_protocol_write_byte (protocol, * key139, error)) < 0)
        return -1;
      {
        gint8* key141 = g_new (gint8, 1);
        gint8* val142 = g_new (gint8, 1);
        GList *key_list = NULL, *iter = NULL;
        gint8** keys;
        int i = 0, key_count;

        if ((ret = thrift_protocol_write_map_begin (protocol, T_BYTE, T_BYTE, (gint32) g_hash_table_size ((GHashTable *)  val140), error)) < 0)
          return -1;
        xfer += ret;
        g_hash_table_foreach ((GHashTable *)  val140, thrift_hash_table_get_keys, &key_list);
        key_count = g_list_length (key_list);
        keys = g_newa (gint8*, key_count);
        for (iter = g_list_first (key_list); iter; iter = iter->next)
          keys[i++] = (gint8*) iter->data;
        g_list_free (key_list);

        for (i = 0; i < key_count; ++i)
        {
          key141 = keys[i];
          val142 = (gint8*) g_hash_table_lookup (((GHashTable *)  val140), (gpointer) key141);

          if ((ret = thrift_protocol_write_byte (protocol, * key141, error)) < 0)
            return -1;
          if ((ret = thrift_protocol_write_byte (protocol, * val142, error)) < 0)
            return -1;
        }
        if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_set_map", T_MAP, 48, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint8* key143 = g_new (gint8, 1);
    GHashTable * val144 = NULL;
    GList *key_list = NULL, *iter = NULL;
    gint8** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_BYTE, T_SET, (gint32) g_hash_table_size ((GHashTable *) this_object->byte_set_map), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->byte_set_map, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint8*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint8*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key143 = keys[i];
      val144 = (GHashTable *) g_hash_table_lookup (((GHashTable *) this_object->byte_set_map), (gpointer) key143);

      if ((ret = thrift_protocol_write_byte (protocol, * key143, error)) < 0)
        return -1;
      {
        GList *key_list = NULL, *iter = NULL;
        gint8** keys;
        int i = 0, key_count;
        gint8* elem;
        gpointer value;
        THRIFT_UNUSED_VAR (value);

        if ((ret = thrift_protocol_write_set_begin (protocol, T_BYTE, (gint32) g_hash_table_size ((GHashTable *)  val144), error)) < 0)
          return -1;
        xfer += ret;
        g_hash_table_foreach ((GHashTable *)  val144, thrift_hash_table_get_keys, &key_list);
        key_count = g_list_length (key_list);
        keys = g_newa (gint8*, key_count);
        for (iter = g_list_first (key_list); iter; iter = iter->next)
          keys[i++] = (gint8*) iter->data;
        g_list_free (key_list);

        for (i = 0; i < key_count; ++i)
        {
          elem = keys[i];
          value = (gpointer) g_hash_table_lookup (((GHashTable *)  val144), (gpointer) elem);

          if ((ret = thrift_protocol_write_byte (protocol, *elem, error)) < 0)
            return -1;
        }
        if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_list_map", T_MAP, 49, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint8* key145 = g_new (gint8, 1);
    GArray * val146 = g_array_new (0, 1, sizeof (gint8));
    GList *key_list = NULL, *iter = NULL;
    gint8** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_BYTE, T_LIST, (gint32) g_hash_table_size ((GHashTable *) this_object->byte_list_map), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->byte_list_map, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint8*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint8*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key145 = keys[i];
      val146 = (GArray *) g_hash_table_lookup (((GHashTable *) this_object->byte_list_map), (gpointer) key145);

      if ((ret = thrift_protocol_write_byte (protocol, * key145, error)) < 0)
        return -1;
      {
        guint i147;

        if ((ret = thrift_protocol_write_list_begin (protocol, T_BYTE, (gint32)  val146->len, error)) < 0)
          return -1;
        xfer += ret;
        for (i147 = 0; i147 <  val146->len; i147++)
        {
          if ((ret = thrift_protocol_write_byte (protocol, (g_array_index ( val146, gint8, i147)), error)) < 0)
            return -1;
        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_compact_proto_test_struct_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  TTestCompactProtoTestStruct *self = T_TEST_COMPACT_PROTO_TEST_STRUCT (object);

  switch (property_id)
  {
    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_A_BYTE:
      self->a_byte = g_value_get_int (value);
      self->__isset_a_byte = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_A_I16:
      self->a_i16 = g_value_get_int (value);
      self->__isset_a_i16 = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_A_I32:
      self->a_i32 = g_value_get_int (value);
      self->__isset_a_i32 = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_A_I64:
      self->a_i64 = g_value_get_int64 (value);
      self->__isset_a_i64 = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_A_DOUBLE:
      self->a_double = g_value_get_double (value);
      self->__isset_a_double = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_A_STRING:
      if (self->a_string != NULL)
        g_free (self->a_string);
      self->a_string = g_value_dup_string (value);
      self->__isset_a_string = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_A_BINARY:
      if (self->a_binary != NULL)
        g_byte_array_unref (self->a_binary);
      self->a_binary = g_value_dup_boxed (value);
      self->__isset_a_binary = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_TRUE_FIELD:
      self->true_field = g_value_get_boolean (value);
      self->__isset_true_field = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_FALSE_FIELD:
      self->false_field = g_value_get_boolean (value);
      self->__isset_false_field = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_EMPTY_STRUCT_FIELD:
      if (self->empty_struct_field != NULL)
        g_object_unref (self->empty_struct_field);
      self->empty_struct_field = g_value_dup_object (value);
      self->__isset_empty_struct_field = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_LIST:
      if (self->byte_list != NULL)
        g_array_unref (self->byte_list);
      self->byte_list = g_value_dup_boxed (value);
      self->__isset_byte_list = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I16_LIST:
      if (self->i16_list != NULL)
        g_array_unref (self->i16_list);
      self->i16_list = g_value_dup_boxed (value);
      self->__isset_i16_list = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I32_LIST:
      if (self->i32_list != NULL)
        g_array_unref (self->i32_list);
      self->i32_list = g_value_dup_boxed (value);
      self->__isset_i32_list = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I64_LIST:
      if (self->i64_list != NULL)
        g_array_unref (self->i64_list);
      self->i64_list = g_value_dup_boxed (value);
      self->__isset_i64_list = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_DOUBLE_LIST:
      if (self->double_list != NULL)
        g_array_unref (self->double_list);
      self->double_list = g_value_dup_boxed (value);
      self->__isset_double_list = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_STRING_LIST:
      if (self->string_list != NULL)
        g_ptr_array_unref (self->string_list);
      self->string_list = g_value_dup_boxed (value);
      self->__isset_string_list = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BINARY_LIST:
      if (self->binary_list != NULL)
        g_ptr_array_unref (self->binary_list);
      self->binary_list = g_value_dup_boxed (value);
      self->__isset_binary_list = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BOOLEAN_LIST:
      if (self->boolean_list != NULL)
        g_array_unref (self->boolean_list);
      self->boolean_list = g_value_dup_boxed (value);
      self->__isset_boolean_list = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_STRUCT_LIST:
      if (self->struct_list != NULL)
        g_ptr_array_unref (self->struct_list);
      self->struct_list = g_value_dup_boxed (value);
      self->__isset_struct_list = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_SET:
      if (self->byte_set != NULL)
        g_hash_table_unref (self->byte_set);
      self->byte_set = g_value_dup_boxed (value);
      self->__isset_byte_set = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I16_SET:
      if (self->i16_set != NULL)
        g_hash_table_unref (self->i16_set);
      self->i16_set = g_value_dup_boxed (value);
      self->__isset_i16_set = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I32_SET:
      if (self->i32_set != NULL)
        g_hash_table_unref (self->i32_set);
      self->i32_set = g_value_dup_boxed (value);
      self->__isset_i32_set = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I64_SET:
      if (self->i64_set != NULL)
        g_hash_table_unref (self->i64_set);
      self->i64_set = g_value_dup_boxed (value);
      self->__isset_i64_set = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_DOUBLE_SET:
      if (self->double_set != NULL)
        g_hash_table_unref (self->double_set);
      self->double_set = g_value_dup_boxed (value);
      self->__isset_double_set = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_STRING_SET:
      if (self->string_set != NULL)
        g_hash_table_unref (self->string_set);
      self->string_set = g_value_dup_boxed (value);
      self->__isset_string_set = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BINARY_SET:
      if (self->binary_set != NULL)
        g_hash_table_unref (self->binary_set);
      self->binary_set = g_value_dup_boxed (value);
      self->__isset_binary_set = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BOOLEAN_SET:
      if (self->boolean_set != NULL)
        g_hash_table_unref (self->boolean_set);
      self->boolean_set = g_value_dup_boxed (value);
      self->__isset_boolean_set = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_STRUCT_SET:
      if (self->struct_set != NULL)
        g_hash_table_unref (self->struct_set);
      self->struct_set = g_value_dup_boxed (value);
      self->__isset_struct_set = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_BYTE_MAP:
      if (self->byte_byte_map != NULL)
        g_hash_table_unref (self->byte_byte_map);
      self->byte_byte_map = g_value_dup_boxed (value);
      self->__isset_byte_byte_map = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I16_BYTE_MAP:
      if (self->i16_byte_map != NULL)
        g_hash_table_unref (self->i16_byte_map);
      self->i16_byte_map = g_value_dup_boxed (value);
      self->__isset_i16_byte_map = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I32_BYTE_MAP:
      if (self->i32_byte_map != NULL)
        g_hash_table_unref (self->i32_byte_map);
      self->i32_byte_map = g_value_dup_boxed (value);
      self->__isset_i32_byte_map = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I64_BYTE_MAP:
      if (self->i64_byte_map != NULL)
        g_hash_table_unref (self->i64_byte_map);
      self->i64_byte_map = g_value_dup_boxed (value);
      self->__isset_i64_byte_map = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_DOUBLE_BYTE_MAP:
      if (self->double_byte_map != NULL)
        g_hash_table_unref (self->double_byte_map);
      self->double_byte_map = g_value_dup_boxed (value);
      self->__isset_double_byte_map = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_STRING_BYTE_MAP:
      if (self->string_byte_map != NULL)
        g_hash_table_unref (self->string_byte_map);
      self->string_byte_map = g_value_dup_boxed (value);
      self->__isset_string_byte_map = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BINARY_BYTE_MAP:
      if (self->binary_byte_map != NULL)
        g_hash_table_unref (self->binary_byte_map);
      self->binary_byte_map = g_value_dup_boxed (value);
      self->__isset_binary_byte_map = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BOOLEAN_BYTE_MAP:
      if (self->boolean_byte_map != NULL)
        g_hash_table_unref (self->boolean_byte_map);
      self->boolean_byte_map = g_value_dup_boxed (value);
      self->__isset_boolean_byte_map = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_I16_MAP:
      if (self->byte_i16_map != NULL)
        g_hash_table_unref (self->byte_i16_map);
      self->byte_i16_map = g_value_dup_boxed (value);
      self->__isset_byte_i16_map = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_I32_MAP:
      if (self->byte_i32_map != NULL)
        g_hash_table_unref (self->byte_i32_map);
      self->byte_i32_map = g_value_dup_boxed (value);
      self->__isset_byte_i32_map = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_I64_MAP:
      if (self->byte_i64_map != NULL)
        g_hash_table_unref (self->byte_i64_map);
      self->byte_i64_map = g_value_dup_boxed (value);
      self->__isset_byte_i64_map = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_DOUBLE_MAP:
      if (self->byte_double_map != NULL)
        g_hash_table_unref (self->byte_double_map);
      self->byte_double_map = g_value_dup_boxed (value);
      self->__isset_byte_double_map = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_STRING_MAP:
      if (self->byte_string_map != NULL)
        g_hash_table_unref (self->byte_string_map);
      self->byte_string_map = g_value_dup_boxed (value);
      self->__isset_byte_string_map = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_BINARY_MAP:
      if (self->byte_binary_map != NULL)
        g_hash_table_unref (self->byte_binary_map);
      self->byte_binary_map = g_value_dup_boxed (value);
      self->__isset_byte_binary_map = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_BOOLEAN_MAP:
      if (self->byte_boolean_map != NULL)
        g_hash_table_unref (self->byte_boolean_map);
      self->byte_boolean_map = g_value_dup_boxed (value);
      self->__isset_byte_boolean_map = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_LIST_BYTE_MAP:
      if (self->list_byte_map != NULL)
        g_hash_table_unref (self->list_byte_map);
      self->list_byte_map = g_value_dup_boxed (value);
      self->__isset_list_byte_map = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_SET_BYTE_MAP:
      if (self->set_byte_map != NULL)
        g_hash_table_unref (self->set_byte_map);
      self->set_byte_map = g_value_dup_boxed (value);
      self->__isset_set_byte_map = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_MAP_BYTE_MAP:
      if (self->map_byte_map != NULL)
        g_hash_table_unref (self->map_byte_map);
      self->map_byte_map = g_value_dup_boxed (value);
      self->__isset_map_byte_map = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_MAP_MAP:
      if (self->byte_map_map != NULL)
        g_hash_table_unref (self->byte_map_map);
      self->byte_map_map = g_value_dup_boxed (value);
      self->__isset_byte_map_map = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_SET_MAP:
      if (self->byte_set_map != NULL)
        g_hash_table_unref (self->byte_set_map);
      self->byte_set_map = g_value_dup_boxed (value);
      self->__isset_byte_set_map = TRUE;
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_LIST_MAP:
      if (self->byte_list_map != NULL)
        g_hash_table_unref (self->byte_list_map);
      self->byte_list_map = g_value_dup_boxed (value);
      self->__isset_byte_list_map = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_compact_proto_test_struct_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  TTestCompactProtoTestStruct *self = T_TEST_COMPACT_PROTO_TEST_STRUCT (object);

  switch (property_id)
  {
    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_A_BYTE:
      g_value_set_int (value, self->a_byte);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_A_I16:
      g_value_set_int (value, self->a_i16);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_A_I32:
      g_value_set_int (value, self->a_i32);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_A_I64:
      g_value_set_int64 (value, self->a_i64);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_A_DOUBLE:
      g_value_set_double (value, self->a_double);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_A_STRING:
      g_value_set_string (value, self->a_string);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_A_BINARY:
      g_value_set_boxed (value, self->a_binary);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_TRUE_FIELD:
      g_value_set_boolean (value, self->true_field);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_FALSE_FIELD:
      g_value_set_boolean (value, self->false_field);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_EMPTY_STRUCT_FIELD:
      g_value_set_object (value, self->empty_struct_field);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_LIST:
      g_value_set_boxed (value, self->byte_list);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I16_LIST:
      g_value_set_boxed (value, self->i16_list);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I32_LIST:
      g_value_set_boxed (value, self->i32_list);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I64_LIST:
      g_value_set_boxed (value, self->i64_list);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_DOUBLE_LIST:
      g_value_set_boxed (value, self->double_list);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_STRING_LIST:
      g_value_set_boxed (value, self->string_list);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BINARY_LIST:
      g_value_set_boxed (value, self->binary_list);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BOOLEAN_LIST:
      g_value_set_boxed (value, self->boolean_list);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_STRUCT_LIST:
      g_value_set_boxed (value, self->struct_list);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_SET:
      g_value_set_boxed (value, self->byte_set);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I16_SET:
      g_value_set_boxed (value, self->i16_set);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I32_SET:
      g_value_set_boxed (value, self->i32_set);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I64_SET:
      g_value_set_boxed (value, self->i64_set);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_DOUBLE_SET:
      g_value_set_boxed (value, self->double_set);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_STRING_SET:
      g_value_set_boxed (value, self->string_set);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BINARY_SET:
      g_value_set_boxed (value, self->binary_set);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BOOLEAN_SET:
      g_value_set_boxed (value, self->boolean_set);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_STRUCT_SET:
      g_value_set_boxed (value, self->struct_set);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_BYTE_MAP:
      g_value_set_boxed (value, self->byte_byte_map);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I16_BYTE_MAP:
      g_value_set_boxed (value, self->i16_byte_map);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I32_BYTE_MAP:
      g_value_set_boxed (value, self->i32_byte_map);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I64_BYTE_MAP:
      g_value_set_boxed (value, self->i64_byte_map);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_DOUBLE_BYTE_MAP:
      g_value_set_boxed (value, self->double_byte_map);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_STRING_BYTE_MAP:
      g_value_set_boxed (value, self->string_byte_map);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BINARY_BYTE_MAP:
      g_value_set_boxed (value, self->binary_byte_map);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BOOLEAN_BYTE_MAP:
      g_value_set_boxed (value, self->boolean_byte_map);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_I16_MAP:
      g_value_set_boxed (value, self->byte_i16_map);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_I32_MAP:
      g_value_set_boxed (value, self->byte_i32_map);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_I64_MAP:
      g_value_set_boxed (value, self->byte_i64_map);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_DOUBLE_MAP:
      g_value_set_boxed (value, self->byte_double_map);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_STRING_MAP:
      g_value_set_boxed (value, self->byte_string_map);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_BINARY_MAP:
      g_value_set_boxed (value, self->byte_binary_map);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_BOOLEAN_MAP:
      g_value_set_boxed (value, self->byte_boolean_map);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_LIST_BYTE_MAP:
      g_value_set_boxed (value, self->list_byte_map);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_SET_BYTE_MAP:
      g_value_set_boxed (value, self->set_byte_map);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_MAP_BYTE_MAP:
      g_value_set_boxed (value, self->map_byte_map);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_MAP_MAP:
      g_value_set_boxed (value, self->byte_map_map);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_SET_MAP:
      g_value_set_boxed (value, self->byte_set_map);
      break;

    case PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_LIST_MAP:
      g_value_set_boxed (value, self->byte_list_map);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_compact_proto_test_struct_instance_init (TTestCompactProtoTestStruct * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->a_byte = 0;
  object->__isset_a_byte = FALSE;
  object->a_i16 = 0;
  object->__isset_a_i16 = FALSE;
  object->a_i32 = 0;
  object->__isset_a_i32 = FALSE;
  object->a_i64 = 0;
  object->__isset_a_i64 = FALSE;
  object->a_double = 0;
  object->__isset_a_double = FALSE;
  object->a_string = NULL;
  object->__isset_a_string = FALSE;
  object->a_binary = NULL;
  object->__isset_a_binary = FALSE;
  object->true_field = 0;
  object->__isset_true_field = FALSE;
  object->false_field = 0;
  object->__isset_false_field = FALSE;
  object->empty_struct_field = g_object_new (T_TEST_TYPE_EMPTY, NULL);
  object->__isset_empty_struct_field = FALSE;
  object->byte_list = g_array_new (0, 1, sizeof (gint8));
  object->__isset_byte_list = FALSE;
  object->i16_list = g_array_new (0, 1, sizeof (gint16));
  object->__isset_i16_list = FALSE;
  object->i32_list = g_array_new (0, 1, sizeof (gint32));
  object->__isset_i32_list = FALSE;
  object->i64_list = g_array_new (0, 1, sizeof (gint64));
  object->__isset_i64_list = FALSE;
  object->double_list = g_array_new (0, 1, sizeof (gdouble));
  object->__isset_double_list = FALSE;
  object->string_list = g_ptr_array_new_with_free_func (g_free);
  object->__isset_string_list = FALSE;
  object->binary_list = g_ptr_array_new_with_free_func (g_free);
  object->__isset_binary_list = FALSE;
  object->boolean_list = g_array_new (0, 1, sizeof (gboolean));
  object->__isset_boolean_list = FALSE;
  object->struct_list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_struct_list = FALSE;
  object->byte_set = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, NULL);
  object->__isset_byte_set = FALSE;
  object->i16_set = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, NULL);
  object->__isset_i16_set = FALSE;
  object->i32_set = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, NULL);
  object->__isset_i32_set = FALSE;
  object->i64_set = g_hash_table_new_full (g_int64_hash, g_int64_equal, g_free, NULL);
  object->__isset_i64_set = FALSE;
  object->double_set = g_hash_table_new_full (g_double_hash, g_double_equal, g_free, NULL);
  object->__isset_double_set = FALSE;
  object->string_set = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
  object->__isset_string_set = FALSE;
  object->binary_set = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, NULL);
  object->__isset_binary_set = FALSE;
  object->boolean_set = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, NULL);
  object->__isset_boolean_set = FALSE;
  object->struct_set = g_hash_table_new_full (g_direct_hash, g_direct_equal, g_object_unref, NULL);
  object->__isset_struct_set = FALSE;
  object->byte_byte_map = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_free);
  object->__isset_byte_byte_map = FALSE;
  object->i16_byte_map = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_free);
  object->__isset_i16_byte_map = FALSE;
  object->i32_byte_map = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_free);
  object->__isset_i32_byte_map = FALSE;
  object->i64_byte_map = g_hash_table_new_full (g_int64_hash, g_int64_equal, g_free, g_free);
  object->__isset_i64_byte_map = FALSE;
  object->double_byte_map = g_hash_table_new_full (g_double_hash, g_double_equal, g_free, g_free);
  object->__isset_double_byte_map = FALSE;
  object->string_byte_map = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_string_byte_map = FALSE;
  object->binary_byte_map = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, g_free);
  object->__isset_binary_byte_map = FALSE;
  object->boolean_byte_map = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_free);
  object->__isset_boolean_byte_map = FALSE;
  object->byte_i16_map = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_free);
  object->__isset_byte_i16_map = FALSE;
  object->byte_i32_map = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_free);
  object->__isset_byte_i32_map = FALSE;
  object->byte_i64_map = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_free);
  object->__isset_byte_i64_map = FALSE;
  object->byte_double_map = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_free);
  object->__isset_byte_double_map = FALSE;
  object->byte_string_map = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_free);
  object->__isset_byte_string_map = FALSE;
  object->byte_binary_map = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, thrift_string_free);
  object->__isset_byte_binary_map = FALSE;
  object->byte_boolean_map = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_free);
  object->__isset_byte_boolean_map = FALSE;
  object->list_byte_map = g_hash_table_new_full (g_direct_hash, g_direct_equal, (GDestroyNotify) g_array_unref, g_free);
  object->__isset_list_byte_map = FALSE;
  object->set_byte_map = g_hash_table_new_full (g_direct_hash, g_direct_equal, (GDestroyNotify) g_hash_table_destroy, g_free);
  object->__isset_set_byte_map = FALSE;
  object->map_byte_map = g_hash_table_new_full (g_direct_hash, g_direct_equal, (GDestroyNotify) g_hash_table_destroy, g_free);
  object->__isset_map_byte_map = FALSE;
  object->byte_map_map = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, (GDestroyNotify) g_hash_table_destroy);
  object->__isset_byte_map_map = FALSE;
  object->byte_set_map = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, (GDestroyNotify) g_hash_table_destroy);
  object->__isset_byte_set_map = FALSE;
  object->byte_list_map = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, (GDestroyNotify) g_array_unref);
  object->__isset_byte_list_map = FALSE;
}

static void 
t_test_compact_proto_test_struct_finalize (GObject *object)
{
  TTestCompactProtoTestStruct *tobject = T_TEST_COMPACT_PROTO_TEST_STRUCT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->a_string != NULL)
  {
    g_free(tobject->a_string);
    tobject->a_string = NULL;
  }
  if (tobject->a_binary != NULL)
  {
    thrift_string_free(tobject->a_binary);
    tobject->a_binary = NULL;
  }
  if (tobject->empty_struct_field != NULL)
  {
    g_object_unref(tobject->empty_struct_field);
    tobject->empty_struct_field = NULL;
  }
  if (tobject->byte_list != NULL)
  {
    g_array_unref (tobject->byte_list);
    tobject->byte_list = NULL;
  }
  if (tobject->i16_list != NULL)
  {
    g_array_unref (tobject->i16_list);
    tobject->i16_list = NULL;
  }
  if (tobject->i32_list != NULL)
  {
    g_array_unref (tobject->i32_list);
    tobject->i32_list = NULL;
  }
  if (tobject->i64_list != NULL)
  {
    g_array_unref (tobject->i64_list);
    tobject->i64_list = NULL;
  }
  if (tobject->double_list != NULL)
  {
    g_array_unref (tobject->double_list);
    tobject->double_list = NULL;
  }
  if (tobject->string_list != NULL)
  {
    g_ptr_array_unref (tobject->string_list);
    tobject->string_list = NULL;
  }
  if (tobject->binary_list != NULL)
  {
    g_ptr_array_unref (tobject->binary_list);
    tobject->binary_list = NULL;
  }
  if (tobject->boolean_list != NULL)
  {
    g_array_unref (tobject->boolean_list);
    tobject->boolean_list = NULL;
  }
  if (tobject->struct_list != NULL)
  {
    g_ptr_array_unref (tobject->struct_list);
    tobject->struct_list = NULL;
  }
  if (tobject->byte_set != NULL)
  {
    g_hash_table_destroy (tobject->byte_set);
    tobject->byte_set = NULL;
  }
  if (tobject->i16_set != NULL)
  {
    g_hash_table_destroy (tobject->i16_set);
    tobject->i16_set = NULL;
  }
  if (tobject->i32_set != NULL)
  {
    g_hash_table_destroy (tobject->i32_set);
    tobject->i32_set = NULL;
  }
  if (tobject->i64_set != NULL)
  {
    g_hash_table_destroy (tobject->i64_set);
    tobject->i64_set = NULL;
  }
  if (tobject->double_set != NULL)
  {
    g_hash_table_destroy (tobject->double_set);
    tobject->double_set = NULL;
  }
  if (tobject->string_set != NULL)
  {
    g_hash_table_destroy (tobject->string_set);
    tobject->string_set = NULL;
  }
  if (tobject->binary_set != NULL)
  {
    g_hash_table_destroy (tobject->binary_set);
    tobject->binary_set = NULL;
  }
  if (tobject->boolean_set != NULL)
  {
    g_hash_table_destroy (tobject->boolean_set);
    tobject->boolean_set = NULL;
  }
  if (tobject->struct_set != NULL)
  {
    g_hash_table_destroy (tobject->struct_set);
    tobject->struct_set = NULL;
  }
  if (tobject->byte_byte_map != NULL)
  {
    g_hash_table_destroy (tobject->byte_byte_map);
    tobject->byte_byte_map = NULL;
  }
  if (tobject->i16_byte_map != NULL)
  {
    g_hash_table_destroy (tobject->i16_byte_map);
    tobject->i16_byte_map = NULL;
  }
  if (tobject->i32_byte_map != NULL)
  {
    g_hash_table_destroy (tobject->i32_byte_map);
    tobject->i32_byte_map = NULL;
  }
  if (tobject->i64_byte_map != NULL)
  {
    g_hash_table_destroy (tobject->i64_byte_map);
    tobject->i64_byte_map = NULL;
  }
  if (tobject->double_byte_map != NULL)
  {
    g_hash_table_destroy (tobject->double_byte_map);
    tobject->double_byte_map = NULL;
  }
  if (tobject->string_byte_map != NULL)
  {
    g_hash_table_destroy (tobject->string_byte_map);
    tobject->string_byte_map = NULL;
  }
  if (tobject->binary_byte_map != NULL)
  {
    g_hash_table_destroy (tobject->binary_byte_map);
    tobject->binary_byte_map = NULL;
  }
  if (tobject->boolean_byte_map != NULL)
  {
    g_hash_table_destroy (tobject->boolean_byte_map);
    tobject->boolean_byte_map = NULL;
  }
  if (tobject->byte_i16_map != NULL)
  {
    g_hash_table_destroy (tobject->byte_i16_map);
    tobject->byte_i16_map = NULL;
  }
  if (tobject->byte_i32_map != NULL)
  {
    g_hash_table_destroy (tobject->byte_i32_map);
    tobject->byte_i32_map = NULL;
  }
  if (tobject->byte_i64_map != NULL)
  {
    g_hash_table_destroy (tobject->byte_i64_map);
    tobject->byte_i64_map = NULL;
  }
  if (tobject->byte_double_map != NULL)
  {
    g_hash_table_destroy (tobject->byte_double_map);
    tobject->byte_double_map = NULL;
  }
  if (tobject->byte_string_map != NULL)
  {
    g_hash_table_destroy (tobject->byte_string_map);
    tobject->byte_string_map = NULL;
  }
  if (tobject->byte_binary_map != NULL)
  {
    g_hash_table_destroy (tobject->byte_binary_map);
    tobject->byte_binary_map = NULL;
  }
  if (tobject->byte_boolean_map != NULL)
  {
    g_hash_table_destroy (tobject->byte_boolean_map);
    tobject->byte_boolean_map = NULL;
  }
  if (tobject->list_byte_map != NULL)
  {
    g_hash_table_destroy (tobject->list_byte_map);
    tobject->list_byte_map = NULL;
  }
  if (tobject->set_byte_map != NULL)
  {
    g_hash_table_destroy (tobject->set_byte_map);
    tobject->set_byte_map = NULL;
  }
  if (tobject->map_byte_map != NULL)
  {
    g_hash_table_destroy (tobject->map_byte_map);
    tobject->map_byte_map = NULL;
  }
  if (tobject->byte_map_map != NULL)
  {
    g_hash_table_destroy (tobject->byte_map_map);
    tobject->byte_map_map = NULL;
  }
  if (tobject->byte_set_map != NULL)
  {
    g_hash_table_destroy (tobject->byte_set_map);
    tobject->byte_set_map = NULL;
  }
  if (tobject->byte_list_map != NULL)
  {
    g_hash_table_destroy (tobject->byte_list_map);
    tobject->byte_list_map = NULL;
  }
}

static void
t_test_compact_proto_test_struct_class_init (TTestCompactProtoTestStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_compact_proto_test_struct_read;
  struct_class->write = t_test_compact_proto_test_struct_write;

  gobject_class->finalize = t_test_compact_proto_test_struct_finalize;
  gobject_class->get_property = t_test_compact_proto_test_struct_get_property;
  gobject_class->set_property = t_test_compact_proto_test_struct_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_A_BYTE,
     g_param_spec_int ("a_byte",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_A_I16,
     g_param_spec_int ("a_i16",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_A_I32,
     g_param_spec_int ("a_i32",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_A_I64,
     g_param_spec_int64 ("a_i64",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_A_DOUBLE,
     g_param_spec_double ("a_double",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_A_STRING,
     g_param_spec_string ("a_string",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_A_BINARY,
     g_param_spec_boxed ("a_binary",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_TRUE_FIELD,
     g_param_spec_boolean ("true_field",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_FALSE_FIELD,
     g_param_spec_boolean ("false_field",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_EMPTY_STRUCT_FIELD,
     g_param_spec_object ("empty_struct_field",
                         NULL,
                         NULL,
                         T_TEST_TYPE_EMPTY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_LIST,
     g_param_spec_boxed ("byte_list",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I16_LIST,
     g_param_spec_boxed ("i16_list",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I32_LIST,
     g_param_spec_boxed ("i32_list",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I64_LIST,
     g_param_spec_boxed ("i64_list",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_DOUBLE_LIST,
     g_param_spec_boxed ("double_list",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_STRING_LIST,
     g_param_spec_boxed ("string_list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BINARY_LIST,
     g_param_spec_boxed ("binary_list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BOOLEAN_LIST,
     g_param_spec_boxed ("boolean_list",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_STRUCT_LIST,
     g_param_spec_boxed ("struct_list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_SET,
     g_param_spec_boxed ("byte_set",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I16_SET,
     g_param_spec_boxed ("i16_set",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I32_SET,
     g_param_spec_boxed ("i32_set",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I64_SET,
     g_param_spec_boxed ("i64_set",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_DOUBLE_SET,
     g_param_spec_boxed ("double_set",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_STRING_SET,
     g_param_spec_boxed ("string_set",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BINARY_SET,
     g_param_spec_boxed ("binary_set",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BOOLEAN_SET,
     g_param_spec_boxed ("boolean_set",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_STRUCT_SET,
     g_param_spec_boxed ("struct_set",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_BYTE_MAP,
     g_param_spec_boxed ("byte_byte_map",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I16_BYTE_MAP,
     g_param_spec_boxed ("i16_byte_map",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I32_BYTE_MAP,
     g_param_spec_boxed ("i32_byte_map",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_I64_BYTE_MAP,
     g_param_spec_boxed ("i64_byte_map",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_DOUBLE_BYTE_MAP,
     g_param_spec_boxed ("double_byte_map",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_STRING_BYTE_MAP,
     g_param_spec_boxed ("string_byte_map",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BINARY_BYTE_MAP,
     g_param_spec_boxed ("binary_byte_map",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BOOLEAN_BYTE_MAP,
     g_param_spec_boxed ("boolean_byte_map",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_I16_MAP,
     g_param_spec_boxed ("byte_i16_map",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_I32_MAP,
     g_param_spec_boxed ("byte_i32_map",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_I64_MAP,
     g_param_spec_boxed ("byte_i64_map",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_DOUBLE_MAP,
     g_param_spec_boxed ("byte_double_map",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_STRING_MAP,
     g_param_spec_boxed ("byte_string_map",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_BINARY_MAP,
     g_param_spec_boxed ("byte_binary_map",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_BOOLEAN_MAP,
     g_param_spec_boxed ("byte_boolean_map",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_LIST_BYTE_MAP,
     g_param_spec_boxed ("list_byte_map",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_SET_BYTE_MAP,
     g_param_spec_boxed ("set_byte_map",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_MAP_BYTE_MAP,
     g_param_spec_boxed ("map_byte_map",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_MAP_MAP,
     g_param_spec_boxed ("byte_map_map",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_SET_MAP,
     g_param_spec_boxed ("byte_set_map",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPACT_PROTO_TEST_STRUCT_BYTE_LIST_MAP,
     g_param_spec_boxed ("byte_list_map",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
t_test_compact_proto_test_struct_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestCompactProtoTestStructClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_compact_proto_test_struct_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestCompactProtoTestStruct),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_compact_proto_test_struct_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestCompactProtoTestStructType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestSingleMapTestStructProperties
{
  PROP_T_TEST_SINGLE_MAP_TEST_STRUCT_0,
  PROP_T_TEST_SINGLE_MAP_TEST_STRUCT_I32_MAP
};

/* reads a single_map_test_struct object */
static gint32
t_test_single_map_test_struct_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestSingleMapTestStruct * this_object = T_TEST_SINGLE_MAP_TEST_STRUCT(object);
  gboolean isset_i32_map = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint32* key148 = g_new (gint32, 1);
              gint32* val149 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*key148, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_i32 (protocol, &*val149, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->i32_map, (gpointer) key148, (gpointer) val149);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_i32_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_i32_map)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_test_single_map_test_struct_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestSingleMapTestStruct * this_object = T_TEST_SINGLE_MAP_TEST_STRUCT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SingleMapTestStruct", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i32_map", T_MAP, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint32* key150 = g_new (gint32, 1);
    gint32* val151 = g_new (gint32, 1);
    GList *key_list = NULL, *iter = NULL;
    gint32** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_I32, (gint32) g_hash_table_size ((GHashTable *) this_object->i32_map), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->i32_map, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint32*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint32*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key150 = keys[i];
      val151 = (gint32*) g_hash_table_lookup (((GHashTable *) this_object->i32_map), (gpointer) key150);

      if ((ret = thrift_protocol_write_i32 (protocol, * key150, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_i32 (protocol, * val151, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_single_map_test_struct_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  TTestSingleMapTestStruct *self = T_TEST_SINGLE_MAP_TEST_STRUCT (object);

  switch (property_id)
  {
    case PROP_T_TEST_SINGLE_MAP_TEST_STRUCT_I32_MAP:
      if (self->i32_map != NULL)
        g_hash_table_unref (self->i32_map);
      self->i32_map = g_value_dup_boxed (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_single_map_test_struct_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  TTestSingleMapTestStruct *self = T_TEST_SINGLE_MAP_TEST_STRUCT (object);

  switch (property_id)
  {
    case PROP_T_TEST_SINGLE_MAP_TEST_STRUCT_I32_MAP:
      g_value_set_boxed (value, self->i32_map);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_single_map_test_struct_instance_init (TTestSingleMapTestStruct * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->i32_map = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_free);
}

static void 
t_test_single_map_test_struct_finalize (GObject *object)
{
  TTestSingleMapTestStruct *tobject = T_TEST_SINGLE_MAP_TEST_STRUCT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->i32_map != NULL)
  {
    g_hash_table_destroy (tobject->i32_map);
    tobject->i32_map = NULL;
  }
}

static void
t_test_single_map_test_struct_class_init (TTestSingleMapTestStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_single_map_test_struct_read;
  struct_class->write = t_test_single_map_test_struct_write;

  gobject_class->finalize = t_test_single_map_test_struct_finalize;
  gobject_class->get_property = t_test_single_map_test_struct_get_property;
  gobject_class->set_property = t_test_single_map_test_struct_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_SINGLE_MAP_TEST_STRUCT_I32_MAP,
     g_param_spec_boxed ("i32_map",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
t_test_single_map_test_struct_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestSingleMapTestStructClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_single_map_test_struct_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestSingleMapTestStruct),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_single_map_test_struct_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestSingleMapTestStructType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestExceptionWithAMapProperties
{
  PROP_T_TEST_EXCEPTION_WITH_A_MAP_0,
  PROP_T_TEST_EXCEPTION_WITH_A_MAP_BLAH,
  PROP_T_TEST_EXCEPTION_WITH_A_MAP_MAP_FIELD
};

/* reads a exception_with_a_map object */
static gint32
t_test_exception_with_a_map_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestExceptionWithAMap * this_object = T_TEST_EXCEPTION_WITH_A_MAP(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->blah != NULL)
          {
            g_free(this_object->blah);
            this_object->blah = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->blah, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_blah = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key152 = NULL;
              gchar * val153 = NULL;
              if (key152 != NULL)
              {
                g_free(key152);
                key152 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key152, error)) < 0)
                return -1;
              xfer += ret;
              if (val153 != NULL)
              {
                g_free(val153);
                val153 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val153, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->map_field, (gpointer) key152, (gpointer) val153);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_map_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_exception_with_a_map_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestExceptionWithAMap * this_object = T_TEST_EXCEPTION_WITH_A_MAP(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ExceptionWithAMap", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "blah", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->blah, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "map_field", T_MAP, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    gchar * key154 = NULL;
    gchar * val155 = NULL;
    GList *key_list = NULL, *iter = NULL;
    gchar ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, (gint32) g_hash_table_size ((GHashTable *) this_object->map_field), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->map_field, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gchar *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gchar *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key154 = keys[i];
      val155 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->map_field), (gpointer) key154);

      if ((ret = thrift_protocol_write_string (protocol,  key154, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_string (protocol,  val155, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_exception_with_a_map_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  TTestExceptionWithAMap *self = T_TEST_EXCEPTION_WITH_A_MAP (object);

  switch (property_id)
  {
    case PROP_T_TEST_EXCEPTION_WITH_A_MAP_BLAH:
      if (self->blah != NULL)
        g_free (self->blah);
      self->blah = g_value_dup_string (value);
      self->__isset_blah = TRUE;
      break;

    case PROP_T_TEST_EXCEPTION_WITH_A_MAP_MAP_FIELD:
      if (self->map_field != NULL)
        g_hash_table_unref (self->map_field);
      self->map_field = g_value_dup_boxed (value);
      self->__isset_map_field = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_exception_with_a_map_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  TTestExceptionWithAMap *self = T_TEST_EXCEPTION_WITH_A_MAP (object);

  switch (property_id)
  {
    case PROP_T_TEST_EXCEPTION_WITH_A_MAP_BLAH:
      g_value_set_string (value, self->blah);
      break;

    case PROP_T_TEST_EXCEPTION_WITH_A_MAP_MAP_FIELD:
      g_value_set_boxed (value, self->map_field);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_exception_with_a_map_instance_init (TTestExceptionWithAMap * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->blah = NULL;
  object->__isset_blah = FALSE;
  object->map_field = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_map_field = FALSE;
}

static void 
t_test_exception_with_a_map_finalize (GObject *object)
{
  TTestExceptionWithAMap *tobject = T_TEST_EXCEPTION_WITH_A_MAP (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->blah != NULL)
  {
    g_free(tobject->blah);
    tobject->blah = NULL;
  }
  if (tobject->map_field != NULL)
  {
    g_hash_table_destroy (tobject->map_field);
    tobject->map_field = NULL;
  }
}

static void
t_test_exception_with_a_map_class_init (TTestExceptionWithAMapClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_exception_with_a_map_read;
  struct_class->write = t_test_exception_with_a_map_write;

  gobject_class->finalize = t_test_exception_with_a_map_finalize;
  gobject_class->get_property = t_test_exception_with_a_map_get_property;
  gobject_class->set_property = t_test_exception_with_a_map_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_EXCEPTION_WITH_A_MAP_BLAH,
     g_param_spec_string ("blah",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_EXCEPTION_WITH_A_MAP_MAP_FIELD,
     g_param_spec_boxed ("map_field",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
t_test_exception_with_a_map_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestExceptionWithAMapClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_exception_with_a_map_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestExceptionWithAMap),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_exception_with_a_map_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestExceptionWithAMapType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define T_TEST_EXCEPTION_WITH_A_MAP_ERROR_DOMAIN "t_test_exception_with_a_map_error_quark"
GQuark
t_test_exception_with_a_map_error_quark (void)
{
  return g_quark_from_static_string (T_TEST_EXCEPTION_WITH_A_MAP_ERROR_DOMAIN);
}

enum _TTestBlowUpProperties
{
  PROP_T_TEST_BLOW_UP_0,
  PROP_T_TEST_BLOW_UP_B1,
  PROP_T_TEST_BLOW_UP_B2,
  PROP_T_TEST_BLOW_UP_B3,
  PROP_T_TEST_BLOW_UP_B4
};

/* reads a blow_up object */
static gint32
t_test_blow_up_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestBlowUp * this_object = T_TEST_BLOW_UP(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              GArray * key156 = g_array_new (0, 1, sizeof (gint32));
              GHashTable * val157 = NULL;
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                for (i = 0; i < size; i++)
                {
                  gint32* _elem158 = g_new (gint32, 1);
                  if ((ret = thrift_protocol_read_i32 (protocol, &*_elem158, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_array_append_vals (key156, _elem158, 1);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through the set elements */
                for (i = 0; i < size; ++i)
                {
                  GHashTable * _elem159 = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_free);
                  {
                    guint32 size;
                    guint32 i;
                    ThriftType key_type;
                    ThriftType value_type;

                    /* read the map begin marker */
                    if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                      return -1;
                    xfer += ret;

                    /* iterate through each of the map's fields */
                    for (i = 0; i < size; i++)
                    {
                      gint32* key160 = g_new (gint32, 1);
                      gchar * val161 = NULL;
                      if ((ret = thrift_protocol_read_i32 (protocol, &*key160, error)) < 0)
                        return -1;
                      xfer += ret;
                      if (val161 != NULL)
                      {
                        g_free(val161);
                        val161 = NULL;
                      }

                      if ((ret = thrift_protocol_read_string (protocol, &val161, error)) < 0)
                        return -1;
                      xfer += ret;
                      g_hash_table_insert ((GHashTable *)_elem159, (gpointer) key160, (gpointer) val161);
                    }

                    /* read the map end marker */
                    if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                      return -1;
                    xfer += ret;
                  }
                  g_hash_table_insert ((GHashTable *) val157, (gpointer) _elem159, (gpointer) 1);
                }
                if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;

              }
              g_hash_table_insert ((GHashTable *)this_object->b1, (gpointer) key156, (gpointer) val157);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_b1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              GArray * key162 = g_array_new (0, 1, sizeof (gint32));
              GHashTable * val163 = NULL;
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                for (i = 0; i < size; i++)
                {
                  gint32* _elem164 = g_new (gint32, 1);
                  if ((ret = thrift_protocol_read_i32 (protocol, &*_elem164, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_array_append_vals (key162, _elem164, 1);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through the set elements */
                for (i = 0; i < size; ++i)
                {
                  GHashTable * _elem165 = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_free);
                  {
                    guint32 size;
                    guint32 i;
                    ThriftType key_type;
                    ThriftType value_type;

                    /* read the map begin marker */
                    if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                      return -1;
                    xfer += ret;

                    /* iterate through each of the map's fields */
                    for (i = 0; i < size; i++)
                    {
                      gint32* key166 = g_new (gint32, 1);
                      gchar * val167 = NULL;
                      if ((ret = thrift_protocol_read_i32 (protocol, &*key166, error)) < 0)
                        return -1;
                      xfer += ret;
                      if (val167 != NULL)
                      {
                        g_free(val167);
                        val167 = NULL;
                      }

                      if ((ret = thrift_protocol_read_string (protocol, &val167, error)) < 0)
                        return -1;
                      xfer += ret;
                      g_hash_table_insert ((GHashTable *)_elem165, (gpointer) key166, (gpointer) val167);
                    }

                    /* read the map end marker */
                    if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                      return -1;
                    xfer += ret;
                  }
                  g_hash_table_insert ((GHashTable *) val163, (gpointer) _elem165, (gpointer) 1);
                }
                if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;

              }
              g_hash_table_insert ((GHashTable *)this_object->b2, (gpointer) key162, (gpointer) val163);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_b2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              GArray * key168 = g_array_new (0, 1, sizeof (gint32));
              GHashTable * val169 = NULL;
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                for (i = 0; i < size; i++)
                {
                  gint32* _elem170 = g_new (gint32, 1);
                  if ((ret = thrift_protocol_read_i32 (protocol, &*_elem170, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_array_append_vals (key168, _elem170, 1);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through the set elements */
                for (i = 0; i < size; ++i)
                {
                  GHashTable * _elem171 = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_free);
                  {
                    guint32 size;
                    guint32 i;
                    ThriftType key_type;
                    ThriftType value_type;

                    /* read the map begin marker */
                    if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                      return -1;
                    xfer += ret;

                    /* iterate through each of the map's fields */
                    for (i = 0; i < size; i++)
                    {
                      gint32* key172 = g_new (gint32, 1);
                      gchar * val173 = NULL;
                      if ((ret = thrift_protocol_read_i32 (protocol, &*key172, error)) < 0)
                        return -1;
                      xfer += ret;
                      if (val173 != NULL)
                      {
                        g_free(val173);
                        val173 = NULL;
                      }

                      if ((ret = thrift_protocol_read_string (protocol, &val173, error)) < 0)
                        return -1;
                      xfer += ret;
                      g_hash_table_insert ((GHashTable *)_elem171, (gpointer) key172, (gpointer) val173);
                    }

                    /* read the map end marker */
                    if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                      return -1;
                    xfer += ret;
                  }
                  g_hash_table_insert ((GHashTable *) val169, (gpointer) _elem171, (gpointer) 1);
                }
                if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;

              }
              g_hash_table_insert ((GHashTable *)this_object->b3, (gpointer) key168, (gpointer) val169);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_b3 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              GArray * key174 = g_array_new (0, 1, sizeof (gint32));
              GHashTable * val175 = NULL;
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                for (i = 0; i < size; i++)
                {
                  gint32* _elem176 = g_new (gint32, 1);
                  if ((ret = thrift_protocol_read_i32 (protocol, &*_elem176, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_array_append_vals (key174, _elem176, 1);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through the set elements */
                for (i = 0; i < size; ++i)
                {
                  GHashTable * _elem177 = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_free);
                  {
                    guint32 size;
                    guint32 i;
                    ThriftType key_type;
                    ThriftType value_type;

                    /* read the map begin marker */
                    if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                      return -1;
                    xfer += ret;

                    /* iterate through each of the map's fields */
                    for (i = 0; i < size; i++)
                    {
                      gint32* key178 = g_new (gint32, 1);
                      gchar * val179 = NULL;
                      if ((ret = thrift_protocol_read_i32 (protocol, &*key178, error)) < 0)
                        return -1;
                      xfer += ret;
                      if (val179 != NULL)
                      {
                        g_free(val179);
                        val179 = NULL;
                      }

                      if ((ret = thrift_protocol_read_string (protocol, &val179, error)) < 0)
                        return -1;
                      xfer += ret;
                      g_hash_table_insert ((GHashTable *)_elem177, (gpointer) key178, (gpointer) val179);
                    }

                    /* read the map end marker */
                    if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                      return -1;
                    xfer += ret;
                  }
                  g_hash_table_insert ((GHashTable *) val175, (gpointer) _elem177, (gpointer) 1);
                }
                if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;

              }
              g_hash_table_insert ((GHashTable *)this_object->b4, (gpointer) key174, (gpointer) val175);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_b4 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_blow_up_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestBlowUp * this_object = T_TEST_BLOW_UP(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BlowUp", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "b1", T_MAP, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    GArray * key180 = g_array_new (0, 1, sizeof (gint32));
    GHashTable * val181 = NULL;
    GList *key_list = NULL, *iter = NULL;
    GArray ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_LIST, T_SET, (gint32) g_hash_table_size ((GHashTable *) this_object->b1), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->b1, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (GArray *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (GArray *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key180 = keys[i];
      val181 = (GHashTable *) g_hash_table_lookup (((GHashTable *) this_object->b1), (gpointer) key180);

      {
        guint i182;

        if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32)  key180->len, error)) < 0)
          return -1;
        xfer += ret;
        for (i182 = 0; i182 <  key180->len; i182++)
        {
          if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index ( key180, gint32, i182)), error)) < 0)
            return -1;
        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
      {
        GList *key_list = NULL, *iter = NULL;
        GHashTable ** keys;
        int i = 0, key_count;
        GHashTable * elem;
        gpointer value;
        THRIFT_UNUSED_VAR (value);

        if ((ret = thrift_protocol_write_set_begin (protocol, T_MAP, (gint32) g_hash_table_size ((GHashTable *)  val181), error)) < 0)
          return -1;
        xfer += ret;
        g_hash_table_foreach ((GHashTable *)  val181, thrift_hash_table_get_keys, &key_list);
        key_count = g_list_length (key_list);
        keys = g_newa (GHashTable *, key_count);
        for (iter = g_list_first (key_list); iter; iter = iter->next)
          keys[i++] = (GHashTable *) iter->data;
        g_list_free (key_list);

        for (i = 0; i < key_count; ++i)
        {
          elem = keys[i];
          value = (gpointer) g_hash_table_lookup (((GHashTable *)  val181), (gpointer) elem);

          {
            gint32* key183 = g_new (gint32, 1);
            gchar * val184 = NULL;
            GList *key_list = NULL, *iter = NULL;
            gint32** keys;
            int i = 0, key_count;

            if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_STRING, (gint32) g_hash_table_size ((GHashTable *) elem), error)) < 0)
              return -1;
            xfer += ret;
            g_hash_table_foreach ((GHashTable *) elem, thrift_hash_table_get_keys, &key_list);
            key_count = g_list_length (key_list);
            keys = g_newa (gint32*, key_count);
            for (iter = g_list_first (key_list); iter; iter = iter->next)
              keys[i++] = (gint32*) iter->data;
            g_list_free (key_list);

            for (i = 0; i < key_count; ++i)
            {
              key183 = keys[i];
              val184 = (gchar *) g_hash_table_lookup (((GHashTable *) elem), (gpointer) key183);

              if ((ret = thrift_protocol_write_i32 (protocol, * key183, error)) < 0)
                return -1;
              if ((ret = thrift_protocol_write_string (protocol,  val184, error)) < 0)
                return -1;
            }
            if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
        }
        if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "b2", T_MAP, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    GArray * key185 = g_array_new (0, 1, sizeof (gint32));
    GHashTable * val186 = NULL;
    GList *key_list = NULL, *iter = NULL;
    GArray ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_LIST, T_SET, (gint32) g_hash_table_size ((GHashTable *) this_object->b2), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->b2, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (GArray *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (GArray *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key185 = keys[i];
      val186 = (GHashTable *) g_hash_table_lookup (((GHashTable *) this_object->b2), (gpointer) key185);

      {
        guint i187;

        if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32)  key185->len, error)) < 0)
          return -1;
        xfer += ret;
        for (i187 = 0; i187 <  key185->len; i187++)
        {
          if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index ( key185, gint32, i187)), error)) < 0)
            return -1;
        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
      {
        GList *key_list = NULL, *iter = NULL;
        GHashTable ** keys;
        int i = 0, key_count;
        GHashTable * elem;
        gpointer value;
        THRIFT_UNUSED_VAR (value);

        if ((ret = thrift_protocol_write_set_begin (protocol, T_MAP, (gint32) g_hash_table_size ((GHashTable *)  val186), error)) < 0)
          return -1;
        xfer += ret;
        g_hash_table_foreach ((GHashTable *)  val186, thrift_hash_table_get_keys, &key_list);
        key_count = g_list_length (key_list);
        keys = g_newa (GHashTable *, key_count);
        for (iter = g_list_first (key_list); iter; iter = iter->next)
          keys[i++] = (GHashTable *) iter->data;
        g_list_free (key_list);

        for (i = 0; i < key_count; ++i)
        {
          elem = keys[i];
          value = (gpointer) g_hash_table_lookup (((GHashTable *)  val186), (gpointer) elem);

          {
            gint32* key188 = g_new (gint32, 1);
            gchar * val189 = NULL;
            GList *key_list = NULL, *iter = NULL;
            gint32** keys;
            int i = 0, key_count;

            if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_STRING, (gint32) g_hash_table_size ((GHashTable *) elem), error)) < 0)
              return -1;
            xfer += ret;
            g_hash_table_foreach ((GHashTable *) elem, thrift_hash_table_get_keys, &key_list);
            key_count = g_list_length (key_list);
            keys = g_newa (gint32*, key_count);
            for (iter = g_list_first (key_list); iter; iter = iter->next)
              keys[i++] = (gint32*) iter->data;
            g_list_free (key_list);

            for (i = 0; i < key_count; ++i)
            {
              key188 = keys[i];
              val189 = (gchar *) g_hash_table_lookup (((GHashTable *) elem), (gpointer) key188);

              if ((ret = thrift_protocol_write_i32 (protocol, * key188, error)) < 0)
                return -1;
              if ((ret = thrift_protocol_write_string (protocol,  val189, error)) < 0)
                return -1;
            }
            if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
        }
        if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "b3", T_MAP, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    GArray * key190 = g_array_new (0, 1, sizeof (gint32));
    GHashTable * val191 = NULL;
    GList *key_list = NULL, *iter = NULL;
    GArray ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_LIST, T_SET, (gint32) g_hash_table_size ((GHashTable *) this_object->b3), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->b3, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (GArray *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (GArray *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key190 = keys[i];
      val191 = (GHashTable *) g_hash_table_lookup (((GHashTable *) this_object->b3), (gpointer) key190);

      {
        guint i192;

        if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32)  key190->len, error)) < 0)
          return -1;
        xfer += ret;
        for (i192 = 0; i192 <  key190->len; i192++)
        {
          if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index ( key190, gint32, i192)), error)) < 0)
            return -1;
        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
      {
        GList *key_list = NULL, *iter = NULL;
        GHashTable ** keys;
        int i = 0, key_count;
        GHashTable * elem;
        gpointer value;
        THRIFT_UNUSED_VAR (value);

        if ((ret = thrift_protocol_write_set_begin (protocol, T_MAP, (gint32) g_hash_table_size ((GHashTable *)  val191), error)) < 0)
          return -1;
        xfer += ret;
        g_hash_table_foreach ((GHashTable *)  val191, thrift_hash_table_get_keys, &key_list);
        key_count = g_list_length (key_list);
        keys = g_newa (GHashTable *, key_count);
        for (iter = g_list_first (key_list); iter; iter = iter->next)
          keys[i++] = (GHashTable *) iter->data;
        g_list_free (key_list);

        for (i = 0; i < key_count; ++i)
        {
          elem = keys[i];
          value = (gpointer) g_hash_table_lookup (((GHashTable *)  val191), (gpointer) elem);

          {
            gint32* key193 = g_new (gint32, 1);
            gchar * val194 = NULL;
            GList *key_list = NULL, *iter = NULL;
            gint32** keys;
            int i = 0, key_count;

            if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_STRING, (gint32) g_hash_table_size ((GHashTable *) elem), error)) < 0)
              return -1;
            xfer += ret;
            g_hash_table_foreach ((GHashTable *) elem, thrift_hash_table_get_keys, &key_list);
            key_count = g_list_length (key_list);
            keys = g_newa (gint32*, key_count);
            for (iter = g_list_first (key_list); iter; iter = iter->next)
              keys[i++] = (gint32*) iter->data;
            g_list_free (key_list);

            for (i = 0; i < key_count; ++i)
            {
              key193 = keys[i];
              val194 = (gchar *) g_hash_table_lookup (((GHashTable *) elem), (gpointer) key193);

              if ((ret = thrift_protocol_write_i32 (protocol, * key193, error)) < 0)
                return -1;
              if ((ret = thrift_protocol_write_string (protocol,  val194, error)) < 0)
                return -1;
            }
            if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
        }
        if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "b4", T_MAP, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    GArray * key195 = g_array_new (0, 1, sizeof (gint32));
    GHashTable * val196 = NULL;
    GList *key_list = NULL, *iter = NULL;
    GArray ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_LIST, T_SET, (gint32) g_hash_table_size ((GHashTable *) this_object->b4), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->b4, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (GArray *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (GArray *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key195 = keys[i];
      val196 = (GHashTable *) g_hash_table_lookup (((GHashTable *) this_object->b4), (gpointer) key195);

      {
        guint i197;

        if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32)  key195->len, error)) < 0)
          return -1;
        xfer += ret;
        for (i197 = 0; i197 <  key195->len; i197++)
        {
          if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index ( key195, gint32, i197)), error)) < 0)
            return -1;
        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
      {
        GList *key_list = NULL, *iter = NULL;
        GHashTable ** keys;
        int i = 0, key_count;
        GHashTable * elem;
        gpointer value;
        THRIFT_UNUSED_VAR (value);

        if ((ret = thrift_protocol_write_set_begin (protocol, T_MAP, (gint32) g_hash_table_size ((GHashTable *)  val196), error)) < 0)
          return -1;
        xfer += ret;
        g_hash_table_foreach ((GHashTable *)  val196, thrift_hash_table_get_keys, &key_list);
        key_count = g_list_length (key_list);
        keys = g_newa (GHashTable *, key_count);
        for (iter = g_list_first (key_list); iter; iter = iter->next)
          keys[i++] = (GHashTable *) iter->data;
        g_list_free (key_list);

        for (i = 0; i < key_count; ++i)
        {
          elem = keys[i];
          value = (gpointer) g_hash_table_lookup (((GHashTable *)  val196), (gpointer) elem);

          {
            gint32* key198 = g_new (gint32, 1);
            gchar * val199 = NULL;
            GList *key_list = NULL, *iter = NULL;
            gint32** keys;
            int i = 0, key_count;

            if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_STRING, (gint32) g_hash_table_size ((GHashTable *) elem), error)) < 0)
              return -1;
            xfer += ret;
            g_hash_table_foreach ((GHashTable *) elem, thrift_hash_table_get_keys, &key_list);
            key_count = g_list_length (key_list);
            keys = g_newa (gint32*, key_count);
            for (iter = g_list_first (key_list); iter; iter = iter->next)
              keys[i++] = (gint32*) iter->data;
            g_list_free (key_list);

            for (i = 0; i < key_count; ++i)
            {
              key198 = keys[i];
              val199 = (gchar *) g_hash_table_lookup (((GHashTable *) elem), (gpointer) key198);

              if ((ret = thrift_protocol_write_i32 (protocol, * key198, error)) < 0)
                return -1;
              if ((ret = thrift_protocol_write_string (protocol,  val199, error)) < 0)
                return -1;
            }
            if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
        }
        if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_blow_up_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  TTestBlowUp *self = T_TEST_BLOW_UP (object);

  switch (property_id)
  {
    case PROP_T_TEST_BLOW_UP_B1:
      if (self->b1 != NULL)
        g_hash_table_unref (self->b1);
      self->b1 = g_value_dup_boxed (value);
      self->__isset_b1 = TRUE;
      break;

    case PROP_T_TEST_BLOW_UP_B2:
      if (self->b2 != NULL)
        g_hash_table_unref (self->b2);
      self->b2 = g_value_dup_boxed (value);
      self->__isset_b2 = TRUE;
      break;

    case PROP_T_TEST_BLOW_UP_B3:
      if (self->b3 != NULL)
        g_hash_table_unref (self->b3);
      self->b3 = g_value_dup_boxed (value);
      self->__isset_b3 = TRUE;
      break;

    case PROP_T_TEST_BLOW_UP_B4:
      if (self->b4 != NULL)
        g_hash_table_unref (self->b4);
      self->b4 = g_value_dup_boxed (value);
      self->__isset_b4 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_blow_up_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  TTestBlowUp *self = T_TEST_BLOW_UP (object);

  switch (property_id)
  {
    case PROP_T_TEST_BLOW_UP_B1:
      g_value_set_boxed (value, self->b1);
      break;

    case PROP_T_TEST_BLOW_UP_B2:
      g_value_set_boxed (value, self->b2);
      break;

    case PROP_T_TEST_BLOW_UP_B3:
      g_value_set_boxed (value, self->b3);
      break;

    case PROP_T_TEST_BLOW_UP_B4:
      g_value_set_boxed (value, self->b4);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_blow_up_instance_init (TTestBlowUp * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->b1 = g_hash_table_new_full (g_direct_hash, g_direct_equal, (GDestroyNotify) g_array_unref, (GDestroyNotify) g_hash_table_destroy);
  object->__isset_b1 = FALSE;
  object->b2 = g_hash_table_new_full (g_direct_hash, g_direct_equal, (GDestroyNotify) g_array_unref, (GDestroyNotify) g_hash_table_destroy);
  object->__isset_b2 = FALSE;
  object->b3 = g_hash_table_new_full (g_direct_hash, g_direct_equal, (GDestroyNotify) g_array_unref, (GDestroyNotify) g_hash_table_destroy);
  object->__isset_b3 = FALSE;
  object->b4 = g_hash_table_new_full (g_direct_hash, g_direct_equal, (GDestroyNotify) g_array_unref, (GDestroyNotify) g_hash_table_destroy);
  object->__isset_b4 = FALSE;
}

static void 
t_test_blow_up_finalize (GObject *object)
{
  TTestBlowUp *tobject = T_TEST_BLOW_UP (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->b1 != NULL)
  {
    g_hash_table_destroy (tobject->b1);
    tobject->b1 = NULL;
  }
  if (tobject->b2 != NULL)
  {
    g_hash_table_destroy (tobject->b2);
    tobject->b2 = NULL;
  }
  if (tobject->b3 != NULL)
  {
    g_hash_table_destroy (tobject->b3);
    tobject->b3 = NULL;
  }
  if (tobject->b4 != NULL)
  {
    g_hash_table_destroy (tobject->b4);
    tobject->b4 = NULL;
  }
}

static void
t_test_blow_up_class_init (TTestBlowUpClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_blow_up_read;
  struct_class->write = t_test_blow_up_write;

  gobject_class->finalize = t_test_blow_up_finalize;
  gobject_class->get_property = t_test_blow_up_get_property;
  gobject_class->set_property = t_test_blow_up_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_BLOW_UP_B1,
     g_param_spec_boxed ("b1",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_BLOW_UP_B2,
     g_param_spec_boxed ("b2",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_BLOW_UP_B3,
     g_param_spec_boxed ("b3",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_BLOW_UP_B4,
     g_param_spec_boxed ("b4",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
t_test_blow_up_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestBlowUpClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_blow_up_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestBlowUp),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_blow_up_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestBlowUpType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestReverseOrderStructProperties
{
  PROP_T_TEST_REVERSE_ORDER_STRUCT_0,
  PROP_T_TEST_REVERSE_ORDER_STRUCT_FIRST,
  PROP_T_TEST_REVERSE_ORDER_STRUCT_SECOND,
  PROP_T_TEST_REVERSE_ORDER_STRUCT_THIRD,
  PROP_T_TEST_REVERSE_ORDER_STRUCT_FOURTH
};

/* reads a reverse_order_struct object */
static gint32
t_test_reverse_order_struct_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestReverseOrderStruct * this_object = T_TEST_REVERSE_ORDER_STRUCT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->first != NULL)
          {
            g_free(this_object->first);
            this_object->first = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->first, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_first = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->second, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_second = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->third, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_third = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->fourth, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_fourth = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_reverse_order_struct_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestReverseOrderStruct * this_object = T_TEST_REVERSE_ORDER_STRUCT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ReverseOrderStruct", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "first", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->first, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "second", T_I16, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->second, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "third", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->third, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "fourth", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->fourth, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_reverse_order_struct_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  TTestReverseOrderStruct *self = T_TEST_REVERSE_ORDER_STRUCT (object);

  switch (property_id)
  {
    case PROP_T_TEST_REVERSE_ORDER_STRUCT_FIRST:
      if (self->first != NULL)
        g_free (self->first);
      self->first = g_value_dup_string (value);
      self->__isset_first = TRUE;
      break;

    case PROP_T_TEST_REVERSE_ORDER_STRUCT_SECOND:
      self->second = g_value_get_int (value);
      self->__isset_second = TRUE;
      break;

    case PROP_T_TEST_REVERSE_ORDER_STRUCT_THIRD:
      self->third = g_value_get_int (value);
      self->__isset_third = TRUE;
      break;

    case PROP_T_TEST_REVERSE_ORDER_STRUCT_FOURTH:
      self->fourth = g_value_get_int64 (value);
      self->__isset_fourth = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_reverse_order_struct_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  TTestReverseOrderStruct *self = T_TEST_REVERSE_ORDER_STRUCT (object);

  switch (property_id)
  {
    case PROP_T_TEST_REVERSE_ORDER_STRUCT_FIRST:
      g_value_set_string (value, self->first);
      break;

    case PROP_T_TEST_REVERSE_ORDER_STRUCT_SECOND:
      g_value_set_int (value, self->second);
      break;

    case PROP_T_TEST_REVERSE_ORDER_STRUCT_THIRD:
      g_value_set_int (value, self->third);
      break;

    case PROP_T_TEST_REVERSE_ORDER_STRUCT_FOURTH:
      g_value_set_int64 (value, self->fourth);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_reverse_order_struct_instance_init (TTestReverseOrderStruct * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->first = NULL;
  object->__isset_first = FALSE;
  object->second = 0;
  object->__isset_second = FALSE;
  object->third = 0;
  object->__isset_third = FALSE;
  object->fourth = 0;
  object->__isset_fourth = FALSE;
}

static void 
t_test_reverse_order_struct_finalize (GObject *object)
{
  TTestReverseOrderStruct *tobject = T_TEST_REVERSE_ORDER_STRUCT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->first != NULL)
  {
    g_free(tobject->first);
    tobject->first = NULL;
  }
}

static void
t_test_reverse_order_struct_class_init (TTestReverseOrderStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_reverse_order_struct_read;
  struct_class->write = t_test_reverse_order_struct_write;

  gobject_class->finalize = t_test_reverse_order_struct_finalize;
  gobject_class->get_property = t_test_reverse_order_struct_get_property;
  gobject_class->set_property = t_test_reverse_order_struct_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_REVERSE_ORDER_STRUCT_FIRST,
     g_param_spec_string ("first",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_REVERSE_ORDER_STRUCT_SECOND,
     g_param_spec_int ("second",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_REVERSE_ORDER_STRUCT_THIRD,
     g_param_spec_int ("third",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_REVERSE_ORDER_STRUCT_FOURTH,
     g_param_spec_int64 ("fourth",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
t_test_reverse_order_struct_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestReverseOrderStructClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_reverse_order_struct_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestReverseOrderStruct),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_reverse_order_struct_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestReverseOrderStructType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestStructWithSomeEnumProperties
{
  PROP_T_TEST_STRUCT_WITH_SOME_ENUM_0,
  PROP_T_TEST_STRUCT_WITH_SOME_ENUM_BLAH
};

/* reads a struct_with_some_enum object */
static gint32
t_test_struct_with_some_enum_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestStructWithSomeEnum * this_object = T_TEST_STRUCT_WITH_SOME_ENUM(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast200;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast200, error)) < 0)
            return -1;
          xfer += ret;
          this_object->blah = (TTestSomeEnum)ecast200;
          this_object->__isset_blah = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_struct_with_some_enum_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestStructWithSomeEnum * this_object = T_TEST_STRUCT_WITH_SOME_ENUM(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "StructWithSomeEnum", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "blah", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->blah, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_struct_with_some_enum_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  TTestStructWithSomeEnum *self = T_TEST_STRUCT_WITH_SOME_ENUM (object);

  switch (property_id)
  {
    case PROP_T_TEST_STRUCT_WITH_SOME_ENUM_BLAH:
      self->blah = g_value_get_int (value);
      self->__isset_blah = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_struct_with_some_enum_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  TTestStructWithSomeEnum *self = T_TEST_STRUCT_WITH_SOME_ENUM (object);

  switch (property_id)
  {
    case PROP_T_TEST_STRUCT_WITH_SOME_ENUM_BLAH:
      g_value_set_int (value, self->blah);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_struct_with_some_enum_instance_init (TTestStructWithSomeEnum * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_blah = FALSE;
}

static void 
t_test_struct_with_some_enum_finalize (GObject *object)
{
  TTestStructWithSomeEnum *tobject = T_TEST_STRUCT_WITH_SOME_ENUM (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_struct_with_some_enum_class_init (TTestStructWithSomeEnumClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_struct_with_some_enum_read;
  struct_class->write = t_test_struct_with_some_enum_write;

  gobject_class->finalize = t_test_struct_with_some_enum_finalize;
  gobject_class->get_property = t_test_struct_with_some_enum_get_property;
  gobject_class->set_property = t_test_struct_with_some_enum_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_STRUCT_WITH_SOME_ENUM_BLAH,
     g_param_spec_int ("blah",
                       NULL,
                       NULL,
                       1,
                       2,
                       1,
                       G_PARAM_READWRITE));
}

GType
t_test_struct_with_some_enum_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestStructWithSomeEnumClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_struct_with_some_enum_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestStructWithSomeEnum),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_struct_with_some_enum_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestStructWithSomeEnumType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestTestUnionProperties
{
  PROP_T_TEST_TEST_UNION_0,
  PROP_T_TEST_TEST_UNION_STRING_FIELD,
  PROP_T_TEST_TEST_UNION_I32_FIELD,
  PROP_T_TEST_TEST_UNION_STRUCT_FIELD,
  PROP_T_TEST_TEST_UNION_STRUCT_LIST,
  PROP_T_TEST_TEST_UNION_OTHER_I32_FIELD,
  PROP_T_TEST_TEST_UNION_ENUM_FIELD,
  PROP_T_TEST_TEST_UNION_I32_SET,
  PROP_T_TEST_TEST_UNION_I32_MAP
};

/* reads a test_union object */
static gint32
t_test_test_union_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestTestUnion * this_object = T_TEST_TEST_UNION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->string_field != NULL)
          {
            g_free(this_object->string_field);
            this_object->string_field = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->string_field, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_string_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->i32_field, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_i32_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->struct_field), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_struct_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TTestRandomStuff * _elem201 = NULL;
              if ( _elem201 != NULL)
              {
                g_object_unref (_elem201);
              }
              _elem201 = g_object_new (T_TEST_TYPE_RANDOM_STUFF, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem201), protocol, error)) < 0)
              {
                g_object_unref (_elem201);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->struct_list, _elem201);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_struct_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->other_i32_field, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_other_i32_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          gint32 ecast202;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast202, error)) < 0)
            return -1;
          xfer += ret;
          this_object->enum_field = (TTestSomeEnum)ecast202;
          this_object->__isset_enum_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            for (i = 0; i < size; ++i)
            {
              gint32* _elem203 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem203, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *) this_object->i32_set, (gpointer) _elem203, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_i32_set = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint32* key204 = g_new (gint32, 1);
              gint32* val205 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*key204, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_i32 (protocol, &*val205, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->i32_map, (gpointer) key204, (gpointer) val205);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_i32_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_test_union_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestTestUnion * this_object = T_TEST_TEST_UNION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TestUnion", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "string_field", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->string_field, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i32_field", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->i32_field, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "struct_field", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->struct_field), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "struct_list", T_LIST, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i206;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->struct_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i206 = 0; i206 < this_object->struct_list->len; i206++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->struct_list, i206))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "other_i32_field", T_I32, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->other_i32_field, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "enum_field", T_I32, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->enum_field, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i32_set", T_SET, 7, error)) < 0)
    return -1;
  xfer += ret;
  {
    GList *key_list = NULL, *iter = NULL;
    gint32** keys;
    int i = 0, key_count;
    gint32* elem;
    gpointer value;
    THRIFT_UNUSED_VAR (value);

    if ((ret = thrift_protocol_write_set_begin (protocol, T_I32, (gint32) g_hash_table_size ((GHashTable *) this_object->i32_set), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->i32_set, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint32*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint32*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      elem = keys[i];
      value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->i32_set), (gpointer) elem);

      if ((ret = thrift_protocol_write_i32 (protocol, *elem, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i32_map", T_MAP, 8, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint32* key207 = g_new (gint32, 1);
    gint32* val208 = g_new (gint32, 1);
    GList *key_list = NULL, *iter = NULL;
    gint32** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_I32, (gint32) g_hash_table_size ((GHashTable *) this_object->i32_map), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->i32_map, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint32*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint32*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key207 = keys[i];
      val208 = (gint32*) g_hash_table_lookup (((GHashTable *) this_object->i32_map), (gpointer) key207);

      if ((ret = thrift_protocol_write_i32 (protocol, * key207, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_i32 (protocol, * val208, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_test_union_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  TTestTestUnion *self = T_TEST_TEST_UNION (object);

  switch (property_id)
  {
    case PROP_T_TEST_TEST_UNION_STRING_FIELD:
      if (self->string_field != NULL)
        g_free (self->string_field);
      self->string_field = g_value_dup_string (value);
      self->__isset_string_field = TRUE;
      break;

    case PROP_T_TEST_TEST_UNION_I32_FIELD:
      self->i32_field = g_value_get_int (value);
      self->__isset_i32_field = TRUE;
      break;

    case PROP_T_TEST_TEST_UNION_STRUCT_FIELD:
      if (self->struct_field != NULL)
        g_object_unref (self->struct_field);
      self->struct_field = g_value_dup_object (value);
      self->__isset_struct_field = TRUE;
      break;

    case PROP_T_TEST_TEST_UNION_STRUCT_LIST:
      if (self->struct_list != NULL)
        g_ptr_array_unref (self->struct_list);
      self->struct_list = g_value_dup_boxed (value);
      self->__isset_struct_list = TRUE;
      break;

    case PROP_T_TEST_TEST_UNION_OTHER_I32_FIELD:
      self->other_i32_field = g_value_get_int (value);
      self->__isset_other_i32_field = TRUE;
      break;

    case PROP_T_TEST_TEST_UNION_ENUM_FIELD:
      self->enum_field = g_value_get_int (value);
      self->__isset_enum_field = TRUE;
      break;

    case PROP_T_TEST_TEST_UNION_I32_SET:
      if (self->i32_set != NULL)
        g_hash_table_unref (self->i32_set);
      self->i32_set = g_value_dup_boxed (value);
      self->__isset_i32_set = TRUE;
      break;

    case PROP_T_TEST_TEST_UNION_I32_MAP:
      if (self->i32_map != NULL)
        g_hash_table_unref (self->i32_map);
      self->i32_map = g_value_dup_boxed (value);
      self->__isset_i32_map = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_test_union_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  TTestTestUnion *self = T_TEST_TEST_UNION (object);

  switch (property_id)
  {
    case PROP_T_TEST_TEST_UNION_STRING_FIELD:
      g_value_set_string (value, self->string_field);
      break;

    case PROP_T_TEST_TEST_UNION_I32_FIELD:
      g_value_set_int (value, self->i32_field);
      break;

    case PROP_T_TEST_TEST_UNION_STRUCT_FIELD:
      g_value_set_object (value, self->struct_field);
      break;

    case PROP_T_TEST_TEST_UNION_STRUCT_LIST:
      g_value_set_boxed (value, self->struct_list);
      break;

    case PROP_T_TEST_TEST_UNION_OTHER_I32_FIELD:
      g_value_set_int (value, self->other_i32_field);
      break;

    case PROP_T_TEST_TEST_UNION_ENUM_FIELD:
      g_value_set_int (value, self->enum_field);
      break;

    case PROP_T_TEST_TEST_UNION_I32_SET:
      g_value_set_boxed (value, self->i32_set);
      break;

    case PROP_T_TEST_TEST_UNION_I32_MAP:
      g_value_set_boxed (value, self->i32_map);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_test_union_instance_init (TTestTestUnion * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->string_field = NULL;
  object->__isset_string_field = FALSE;
  object->i32_field = 0;
  object->__isset_i32_field = FALSE;
  object->struct_field = g_object_new (T_TEST_TYPE_ONE_OF_EACH, NULL);
  object->__isset_struct_field = FALSE;
  object->struct_list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_struct_list = FALSE;
  object->other_i32_field = 0;
  object->__isset_other_i32_field = FALSE;
  object->__isset_enum_field = FALSE;
  object->i32_set = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, NULL);
  object->__isset_i32_set = FALSE;
  object->i32_map = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_free);
  object->__isset_i32_map = FALSE;
}

static void 
t_test_test_union_finalize (GObject *object)
{
  TTestTestUnion *tobject = T_TEST_TEST_UNION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->string_field != NULL)
  {
    g_free(tobject->string_field);
    tobject->string_field = NULL;
  }
  if (tobject->struct_field != NULL)
  {
    g_object_unref(tobject->struct_field);
    tobject->struct_field = NULL;
  }
  if (tobject->struct_list != NULL)
  {
    g_ptr_array_unref (tobject->struct_list);
    tobject->struct_list = NULL;
  }
  if (tobject->i32_set != NULL)
  {
    g_hash_table_destroy (tobject->i32_set);
    tobject->i32_set = NULL;
  }
  if (tobject->i32_map != NULL)
  {
    g_hash_table_destroy (tobject->i32_map);
    tobject->i32_map = NULL;
  }
}

static void
t_test_test_union_class_init (TTestTestUnionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_test_union_read;
  struct_class->write = t_test_test_union_write;

  gobject_class->finalize = t_test_test_union_finalize;
  gobject_class->get_property = t_test_test_union_get_property;
  gobject_class->set_property = t_test_test_union_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_TEST_UNION_STRING_FIELD,
     g_param_spec_string ("string_field",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_TEST_UNION_I32_FIELD,
     g_param_spec_int ("i32_field",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_TEST_UNION_STRUCT_FIELD,
     g_param_spec_object ("struct_field",
                         NULL,
                         NULL,
                         T_TEST_TYPE_ONE_OF_EACH,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_TEST_UNION_STRUCT_LIST,
     g_param_spec_boxed ("struct_list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_TEST_UNION_OTHER_I32_FIELD,
     g_param_spec_int ("other_i32_field",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_TEST_UNION_ENUM_FIELD,
     g_param_spec_int ("enum_field",
                       NULL,
                       NULL,
                       1,
                       2,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_TEST_UNION_I32_SET,
     g_param_spec_boxed ("i32_set",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_TEST_UNION_I32_MAP,
     g_param_spec_boxed ("i32_map",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
t_test_test_union_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestTestUnionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_test_union_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestTestUnion),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_test_union_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestTestUnionType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestTestUnionMinusStringFieldProperties
{
  PROP_T_TEST_TEST_UNION_MINUS_STRING_FIELD_0,
  PROP_T_TEST_TEST_UNION_MINUS_STRING_FIELD_I32_FIELD,
  PROP_T_TEST_TEST_UNION_MINUS_STRING_FIELD_STRUCT_FIELD,
  PROP_T_TEST_TEST_UNION_MINUS_STRING_FIELD_STRUCT_LIST,
  PROP_T_TEST_TEST_UNION_MINUS_STRING_FIELD_OTHER_I32_FIELD,
  PROP_T_TEST_TEST_UNION_MINUS_STRING_FIELD_ENUM_FIELD,
  PROP_T_TEST_TEST_UNION_MINUS_STRING_FIELD_I32_SET,
  PROP_T_TEST_TEST_UNION_MINUS_STRING_FIELD_I32_MAP
};

/* reads a test_union_minus_string_field object */
static gint32
t_test_test_union_minus_string_field_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestTestUnionMinusStringField * this_object = T_TEST_TEST_UNION_MINUS_STRING_FIELD(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->i32_field, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_i32_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->struct_field), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_struct_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TTestRandomStuff * _elem209 = NULL;
              if ( _elem209 != NULL)
              {
                g_object_unref (_elem209);
              }
              _elem209 = g_object_new (T_TEST_TYPE_RANDOM_STUFF, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem209), protocol, error)) < 0)
              {
                g_object_unref (_elem209);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->struct_list, _elem209);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_struct_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->other_i32_field, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_other_i32_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          gint32 ecast210;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast210, error)) < 0)
            return -1;
          xfer += ret;
          this_object->enum_field = (TTestSomeEnum)ecast210;
          this_object->__isset_enum_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            for (i = 0; i < size; ++i)
            {
              gint32* _elem211 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem211, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *) this_object->i32_set, (gpointer) _elem211, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_i32_set = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint32* key212 = g_new (gint32, 1);
              gint32* val213 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*key212, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_i32 (protocol, &*val213, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->i32_map, (gpointer) key212, (gpointer) val213);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_i32_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_test_union_minus_string_field_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestTestUnionMinusStringField * this_object = T_TEST_TEST_UNION_MINUS_STRING_FIELD(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TestUnionMinusStringField", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i32_field", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->i32_field, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "struct_field", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->struct_field), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "struct_list", T_LIST, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i214;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->struct_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i214 = 0; i214 < this_object->struct_list->len; i214++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->struct_list, i214))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "other_i32_field", T_I32, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->other_i32_field, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "enum_field", T_I32, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->enum_field, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i32_set", T_SET, 7, error)) < 0)
    return -1;
  xfer += ret;
  {
    GList *key_list = NULL, *iter = NULL;
    gint32** keys;
    int i = 0, key_count;
    gint32* elem;
    gpointer value;
    THRIFT_UNUSED_VAR (value);

    if ((ret = thrift_protocol_write_set_begin (protocol, T_I32, (gint32) g_hash_table_size ((GHashTable *) this_object->i32_set), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->i32_set, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint32*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint32*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      elem = keys[i];
      value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->i32_set), (gpointer) elem);

      if ((ret = thrift_protocol_write_i32 (protocol, *elem, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i32_map", T_MAP, 8, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint32* key215 = g_new (gint32, 1);
    gint32* val216 = g_new (gint32, 1);
    GList *key_list = NULL, *iter = NULL;
    gint32** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_I32, (gint32) g_hash_table_size ((GHashTable *) this_object->i32_map), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->i32_map, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint32*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint32*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key215 = keys[i];
      val216 = (gint32*) g_hash_table_lookup (((GHashTable *) this_object->i32_map), (gpointer) key215);

      if ((ret = thrift_protocol_write_i32 (protocol, * key215, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_i32 (protocol, * val216, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_test_union_minus_string_field_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  TTestTestUnionMinusStringField *self = T_TEST_TEST_UNION_MINUS_STRING_FIELD (object);

  switch (property_id)
  {
    case PROP_T_TEST_TEST_UNION_MINUS_STRING_FIELD_I32_FIELD:
      self->i32_field = g_value_get_int (value);
      self->__isset_i32_field = TRUE;
      break;

    case PROP_T_TEST_TEST_UNION_MINUS_STRING_FIELD_STRUCT_FIELD:
      if (self->struct_field != NULL)
        g_object_unref (self->struct_field);
      self->struct_field = g_value_dup_object (value);
      self->__isset_struct_field = TRUE;
      break;

    case PROP_T_TEST_TEST_UNION_MINUS_STRING_FIELD_STRUCT_LIST:
      if (self->struct_list != NULL)
        g_ptr_array_unref (self->struct_list);
      self->struct_list = g_value_dup_boxed (value);
      self->__isset_struct_list = TRUE;
      break;

    case PROP_T_TEST_TEST_UNION_MINUS_STRING_FIELD_OTHER_I32_FIELD:
      self->other_i32_field = g_value_get_int (value);
      self->__isset_other_i32_field = TRUE;
      break;

    case PROP_T_TEST_TEST_UNION_MINUS_STRING_FIELD_ENUM_FIELD:
      self->enum_field = g_value_get_int (value);
      self->__isset_enum_field = TRUE;
      break;

    case PROP_T_TEST_TEST_UNION_MINUS_STRING_FIELD_I32_SET:
      if (self->i32_set != NULL)
        g_hash_table_unref (self->i32_set);
      self->i32_set = g_value_dup_boxed (value);
      self->__isset_i32_set = TRUE;
      break;

    case PROP_T_TEST_TEST_UNION_MINUS_STRING_FIELD_I32_MAP:
      if (self->i32_map != NULL)
        g_hash_table_unref (self->i32_map);
      self->i32_map = g_value_dup_boxed (value);
      self->__isset_i32_map = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_test_union_minus_string_field_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  TTestTestUnionMinusStringField *self = T_TEST_TEST_UNION_MINUS_STRING_FIELD (object);

  switch (property_id)
  {
    case PROP_T_TEST_TEST_UNION_MINUS_STRING_FIELD_I32_FIELD:
      g_value_set_int (value, self->i32_field);
      break;

    case PROP_T_TEST_TEST_UNION_MINUS_STRING_FIELD_STRUCT_FIELD:
      g_value_set_object (value, self->struct_field);
      break;

    case PROP_T_TEST_TEST_UNION_MINUS_STRING_FIELD_STRUCT_LIST:
      g_value_set_boxed (value, self->struct_list);
      break;

    case PROP_T_TEST_TEST_UNION_MINUS_STRING_FIELD_OTHER_I32_FIELD:
      g_value_set_int (value, self->other_i32_field);
      break;

    case PROP_T_TEST_TEST_UNION_MINUS_STRING_FIELD_ENUM_FIELD:
      g_value_set_int (value, self->enum_field);
      break;

    case PROP_T_TEST_TEST_UNION_MINUS_STRING_FIELD_I32_SET:
      g_value_set_boxed (value, self->i32_set);
      break;

    case PROP_T_TEST_TEST_UNION_MINUS_STRING_FIELD_I32_MAP:
      g_value_set_boxed (value, self->i32_map);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_test_union_minus_string_field_instance_init (TTestTestUnionMinusStringField * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->i32_field = 0;
  object->__isset_i32_field = FALSE;
  object->struct_field = g_object_new (T_TEST_TYPE_ONE_OF_EACH, NULL);
  object->__isset_struct_field = FALSE;
  object->struct_list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_struct_list = FALSE;
  object->other_i32_field = 0;
  object->__isset_other_i32_field = FALSE;
  object->__isset_enum_field = FALSE;
  object->i32_set = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, NULL);
  object->__isset_i32_set = FALSE;
  object->i32_map = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_free);
  object->__isset_i32_map = FALSE;
}

static void 
t_test_test_union_minus_string_field_finalize (GObject *object)
{
  TTestTestUnionMinusStringField *tobject = T_TEST_TEST_UNION_MINUS_STRING_FIELD (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->struct_field != NULL)
  {
    g_object_unref(tobject->struct_field);
    tobject->struct_field = NULL;
  }
  if (tobject->struct_list != NULL)
  {
    g_ptr_array_unref (tobject->struct_list);
    tobject->struct_list = NULL;
  }
  if (tobject->i32_set != NULL)
  {
    g_hash_table_destroy (tobject->i32_set);
    tobject->i32_set = NULL;
  }
  if (tobject->i32_map != NULL)
  {
    g_hash_table_destroy (tobject->i32_map);
    tobject->i32_map = NULL;
  }
}

static void
t_test_test_union_minus_string_field_class_init (TTestTestUnionMinusStringFieldClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_test_union_minus_string_field_read;
  struct_class->write = t_test_test_union_minus_string_field_write;

  gobject_class->finalize = t_test_test_union_minus_string_field_finalize;
  gobject_class->get_property = t_test_test_union_minus_string_field_get_property;
  gobject_class->set_property = t_test_test_union_minus_string_field_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_TEST_UNION_MINUS_STRING_FIELD_I32_FIELD,
     g_param_spec_int ("i32_field",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_TEST_UNION_MINUS_STRING_FIELD_STRUCT_FIELD,
     g_param_spec_object ("struct_field",
                         NULL,
                         NULL,
                         T_TEST_TYPE_ONE_OF_EACH,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_TEST_UNION_MINUS_STRING_FIELD_STRUCT_LIST,
     g_param_spec_boxed ("struct_list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_TEST_UNION_MINUS_STRING_FIELD_OTHER_I32_FIELD,
     g_param_spec_int ("other_i32_field",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_TEST_UNION_MINUS_STRING_FIELD_ENUM_FIELD,
     g_param_spec_int ("enum_field",
                       NULL,
                       NULL,
                       1,
                       2,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_TEST_UNION_MINUS_STRING_FIELD_I32_SET,
     g_param_spec_boxed ("i32_set",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_TEST_UNION_MINUS_STRING_FIELD_I32_MAP,
     g_param_spec_boxed ("i32_map",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
t_test_test_union_minus_string_field_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestTestUnionMinusStringFieldClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_test_union_minus_string_field_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestTestUnionMinusStringField),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_test_union_minus_string_field_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestTestUnionMinusStringFieldType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestComparableUnionProperties
{
  PROP_T_TEST_COMPARABLE_UNION_0,
  PROP_T_TEST_COMPARABLE_UNION_STRING_FIELD,
  PROP_T_TEST_COMPARABLE_UNION_BINARY_FIELD
};

/* reads a comparable_union object */
static gint32
t_test_comparable_union_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestComparableUnion * this_object = T_TEST_COMPARABLE_UNION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->string_field != NULL)
          {
            g_free(this_object->string_field);
            this_object->string_field = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->string_field, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_string_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->binary_field != NULL)
          {
            g_free(this_object->binary_field);
            this_object->binary_field = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->binary_field = g_byte_array_new();
          g_byte_array_append (this_object->binary_field, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_binary_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_comparable_union_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestComparableUnion * this_object = T_TEST_COMPARABLE_UNION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ComparableUnion", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "string_field", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->string_field, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "binary_field", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->binary_field)->data, ((GByteArray *) this_object->binary_field)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_comparable_union_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  TTestComparableUnion *self = T_TEST_COMPARABLE_UNION (object);

  switch (property_id)
  {
    case PROP_T_TEST_COMPARABLE_UNION_STRING_FIELD:
      if (self->string_field != NULL)
        g_free (self->string_field);
      self->string_field = g_value_dup_string (value);
      self->__isset_string_field = TRUE;
      break;

    case PROP_T_TEST_COMPARABLE_UNION_BINARY_FIELD:
      if (self->binary_field != NULL)
        g_byte_array_unref (self->binary_field);
      self->binary_field = g_value_dup_boxed (value);
      self->__isset_binary_field = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_comparable_union_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  TTestComparableUnion *self = T_TEST_COMPARABLE_UNION (object);

  switch (property_id)
  {
    case PROP_T_TEST_COMPARABLE_UNION_STRING_FIELD:
      g_value_set_string (value, self->string_field);
      break;

    case PROP_T_TEST_COMPARABLE_UNION_BINARY_FIELD:
      g_value_set_boxed (value, self->binary_field);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_comparable_union_instance_init (TTestComparableUnion * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->string_field = NULL;
  object->__isset_string_field = FALSE;
  object->binary_field = NULL;
  object->__isset_binary_field = FALSE;
}

static void 
t_test_comparable_union_finalize (GObject *object)
{
  TTestComparableUnion *tobject = T_TEST_COMPARABLE_UNION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->string_field != NULL)
  {
    g_free(tobject->string_field);
    tobject->string_field = NULL;
  }
  if (tobject->binary_field != NULL)
  {
    thrift_string_free(tobject->binary_field);
    tobject->binary_field = NULL;
  }
}

static void
t_test_comparable_union_class_init (TTestComparableUnionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_comparable_union_read;
  struct_class->write = t_test_comparable_union_write;

  gobject_class->finalize = t_test_comparable_union_finalize;
  gobject_class->get_property = t_test_comparable_union_get_property;
  gobject_class->set_property = t_test_comparable_union_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPARABLE_UNION_STRING_FIELD,
     g_param_spec_string ("string_field",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPARABLE_UNION_BINARY_FIELD,
     g_param_spec_boxed ("binary_field",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_test_comparable_union_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestComparableUnionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_comparable_union_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestComparableUnion),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_comparable_union_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestComparableUnionType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestStructWithAUnionProperties
{
  PROP_T_TEST_STRUCT_WITH_A_UNION_0,
  PROP_T_TEST_STRUCT_WITH_A_UNION_TEST_UNION
};

/* reads a struct_with_a_union object */
static gint32
t_test_struct_with_a_union_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestStructWithAUnion * this_object = T_TEST_STRUCT_WITH_A_UNION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->test_union), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_test_union = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_struct_with_a_union_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestStructWithAUnion * this_object = T_TEST_STRUCT_WITH_A_UNION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "StructWithAUnion", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "test_union", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->test_union), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_struct_with_a_union_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  TTestStructWithAUnion *self = T_TEST_STRUCT_WITH_A_UNION (object);

  switch (property_id)
  {
    case PROP_T_TEST_STRUCT_WITH_A_UNION_TEST_UNION:
      if (self->test_union != NULL)
        g_object_unref (self->test_union);
      self->test_union = g_value_dup_object (value);
      self->__isset_test_union = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_struct_with_a_union_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  TTestStructWithAUnion *self = T_TEST_STRUCT_WITH_A_UNION (object);

  switch (property_id)
  {
    case PROP_T_TEST_STRUCT_WITH_A_UNION_TEST_UNION:
      g_value_set_object (value, self->test_union);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_struct_with_a_union_instance_init (TTestStructWithAUnion * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->test_union = g_object_new (T_TEST_TYPE_TEST_UNION, NULL);
  object->__isset_test_union = FALSE;
}

static void 
t_test_struct_with_a_union_finalize (GObject *object)
{
  TTestStructWithAUnion *tobject = T_TEST_STRUCT_WITH_A_UNION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->test_union != NULL)
  {
    g_object_unref(tobject->test_union);
    tobject->test_union = NULL;
  }
}

static void
t_test_struct_with_a_union_class_init (TTestStructWithAUnionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_struct_with_a_union_read;
  struct_class->write = t_test_struct_with_a_union_write;

  gobject_class->finalize = t_test_struct_with_a_union_finalize;
  gobject_class->get_property = t_test_struct_with_a_union_get_property;
  gobject_class->set_property = t_test_struct_with_a_union_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_STRUCT_WITH_A_UNION_TEST_UNION,
     g_param_spec_object ("test_union",
                         NULL,
                         NULL,
                         T_TEST_TYPE_TEST_UNION,
                         G_PARAM_READWRITE));
}

GType
t_test_struct_with_a_union_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestStructWithAUnionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_struct_with_a_union_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestStructWithAUnion),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_struct_with_a_union_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestStructWithAUnionType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestPrimitiveThenStructProperties
{
  PROP_T_TEST_PRIMITIVE_THEN_STRUCT_0,
  PROP_T_TEST_PRIMITIVE_THEN_STRUCT_BLAH,
  PROP_T_TEST_PRIMITIVE_THEN_STRUCT_BLAH2,
  PROP_T_TEST_PRIMITIVE_THEN_STRUCT_BW
};

/* reads a primitive_then_struct object */
static gint32
t_test_primitive_then_struct_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestPrimitiveThenStruct * this_object = T_TEST_PRIMITIVE_THEN_STRUCT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->blah, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_blah = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->blah2, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_blah2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->bw), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_bw = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_primitive_then_struct_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestPrimitiveThenStruct * this_object = T_TEST_PRIMITIVE_THEN_STRUCT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "PrimitiveThenStruct", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "blah", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->blah, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "blah2", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->blah2, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "bw", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->bw), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_primitive_then_struct_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  TTestPrimitiveThenStruct *self = T_TEST_PRIMITIVE_THEN_STRUCT (object);

  switch (property_id)
  {
    case PROP_T_TEST_PRIMITIVE_THEN_STRUCT_BLAH:
      self->blah = g_value_get_int (value);
      self->__isset_blah = TRUE;
      break;

    case PROP_T_TEST_PRIMITIVE_THEN_STRUCT_BLAH2:
      self->blah2 = g_value_get_int (value);
      self->__isset_blah2 = TRUE;
      break;

    case PROP_T_TEST_PRIMITIVE_THEN_STRUCT_BW:
      if (self->bw != NULL)
        g_object_unref (self->bw);
      self->bw = g_value_dup_object (value);
      self->__isset_bw = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_primitive_then_struct_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  TTestPrimitiveThenStruct *self = T_TEST_PRIMITIVE_THEN_STRUCT (object);

  switch (property_id)
  {
    case PROP_T_TEST_PRIMITIVE_THEN_STRUCT_BLAH:
      g_value_set_int (value, self->blah);
      break;

    case PROP_T_TEST_PRIMITIVE_THEN_STRUCT_BLAH2:
      g_value_set_int (value, self->blah2);
      break;

    case PROP_T_TEST_PRIMITIVE_THEN_STRUCT_BW:
      g_value_set_object (value, self->bw);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_primitive_then_struct_instance_init (TTestPrimitiveThenStruct * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->blah = 0;
  object->__isset_blah = FALSE;
  object->blah2 = 0;
  object->__isset_blah2 = FALSE;
  object->bw = g_object_new (T_TEST_TYPE_BACKWARDS, NULL);
  object->__isset_bw = FALSE;
}

static void 
t_test_primitive_then_struct_finalize (GObject *object)
{
  TTestPrimitiveThenStruct *tobject = T_TEST_PRIMITIVE_THEN_STRUCT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->bw != NULL)
  {
    g_object_unref(tobject->bw);
    tobject->bw = NULL;
  }
}

static void
t_test_primitive_then_struct_class_init (TTestPrimitiveThenStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_primitive_then_struct_read;
  struct_class->write = t_test_primitive_then_struct_write;

  gobject_class->finalize = t_test_primitive_then_struct_finalize;
  gobject_class->get_property = t_test_primitive_then_struct_get_property;
  gobject_class->set_property = t_test_primitive_then_struct_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_PRIMITIVE_THEN_STRUCT_BLAH,
     g_param_spec_int ("blah",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_PRIMITIVE_THEN_STRUCT_BLAH2,
     g_param_spec_int ("blah2",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_PRIMITIVE_THEN_STRUCT_BW,
     g_param_spec_object ("bw",
                         NULL,
                         NULL,
                         T_TEST_TYPE_BACKWARDS,
                         G_PARAM_READWRITE));
}

GType
t_test_primitive_then_struct_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestPrimitiveThenStructClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_primitive_then_struct_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestPrimitiveThenStruct),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_primitive_then_struct_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestPrimitiveThenStructType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestStructWithASomemapProperties
{
  PROP_T_TEST_STRUCT_WITH_A_SOMEMAP_0,
  PROP_T_TEST_STRUCT_WITH_A_SOMEMAP_SOMEMAP_FIELD
};

/* reads a struct_with_a_somemap object */
static gint32
t_test_struct_with_a_somemap_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestStructWithASomemap * this_object = T_TEST_STRUCT_WITH_A_SOMEMAP(object);
  gboolean isset_somemap_field = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint32* key217 = g_new (gint32, 1);
              gint32* val218 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*key217, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_i32 (protocol, &*val218, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->somemap_field, (gpointer) key217, (gpointer) val218);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_somemap_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_somemap_field)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_test_struct_with_a_somemap_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestStructWithASomemap * this_object = T_TEST_STRUCT_WITH_A_SOMEMAP(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "StructWithASomemap", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "somemap_field", T_MAP, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint32* key219 = g_new (gint32, 1);
    gint32* val220 = g_new (gint32, 1);
    GList *key_list = NULL, *iter = NULL;
    gint32** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_I32, (gint32) g_hash_table_size ((GHashTable *) this_object->somemap_field), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->somemap_field, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint32*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint32*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key219 = keys[i];
      val220 = (gint32*) g_hash_table_lookup (((GHashTable *) this_object->somemap_field), (gpointer) key219);

      if ((ret = thrift_protocol_write_i32 (protocol, * key219, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_i32 (protocol, * val220, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_struct_with_a_somemap_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  TTestStructWithASomemap *self = T_TEST_STRUCT_WITH_A_SOMEMAP (object);

  switch (property_id)
  {
    case PROP_T_TEST_STRUCT_WITH_A_SOMEMAP_SOMEMAP_FIELD:
      if (self->somemap_field != NULL)
        g_hash_table_unref (self->somemap_field);
      self->somemap_field = g_value_dup_boxed (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_struct_with_a_somemap_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  TTestStructWithASomemap *self = T_TEST_STRUCT_WITH_A_SOMEMAP (object);

  switch (property_id)
  {
    case PROP_T_TEST_STRUCT_WITH_A_SOMEMAP_SOMEMAP_FIELD:
      g_value_set_boxed (value, self->somemap_field);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_struct_with_a_somemap_instance_init (TTestStructWithASomemap * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->somemap_field = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_free);
}

static void 
t_test_struct_with_a_somemap_finalize (GObject *object)
{
  TTestStructWithASomemap *tobject = T_TEST_STRUCT_WITH_A_SOMEMAP (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->somemap_field != NULL)
  {
    g_hash_table_destroy (tobject->somemap_field);
    tobject->somemap_field = NULL;
  }
}

static void
t_test_struct_with_a_somemap_class_init (TTestStructWithASomemapClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_struct_with_a_somemap_read;
  struct_class->write = t_test_struct_with_a_somemap_write;

  gobject_class->finalize = t_test_struct_with_a_somemap_finalize;
  gobject_class->get_property = t_test_struct_with_a_somemap_get_property;
  gobject_class->set_property = t_test_struct_with_a_somemap_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_STRUCT_WITH_A_SOMEMAP_SOMEMAP_FIELD,
     g_param_spec_boxed ("somemap_field",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
t_test_struct_with_a_somemap_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestStructWithASomemapClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_struct_with_a_somemap_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestStructWithASomemap),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_struct_with_a_somemap_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestStructWithASomemapType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestBigFieldIdStructProperties
{
  PROP_T_TEST_BIG_FIELD_ID_STRUCT_0,
  PROP_T_TEST_BIG_FIELD_ID_STRUCT_FIELD1,
  PROP_T_TEST_BIG_FIELD_ID_STRUCT_FIELD2
};

/* reads a big_field_id_struct object */
static gint32
t_test_big_field_id_struct_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestBigFieldIdStruct * this_object = T_TEST_BIG_FIELD_ID_STRUCT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->field1 != NULL)
          {
            g_free(this_object->field1);
            this_object->field1 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->field1, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 45:
        if (ftype == T_STRING)
        {
          if (this_object->field2 != NULL)
          {
            g_free(this_object->field2);
            this_object->field2 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->field2, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_big_field_id_struct_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestBigFieldIdStruct * this_object = T_TEST_BIG_FIELD_ID_STRUCT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BigFieldIdStruct", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "field1", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->field1, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "field2", T_STRING, 45, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->field2, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_big_field_id_struct_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  TTestBigFieldIdStruct *self = T_TEST_BIG_FIELD_ID_STRUCT (object);

  switch (property_id)
  {
    case PROP_T_TEST_BIG_FIELD_ID_STRUCT_FIELD1:
      if (self->field1 != NULL)
        g_free (self->field1);
      self->field1 = g_value_dup_string (value);
      self->__isset_field1 = TRUE;
      break;

    case PROP_T_TEST_BIG_FIELD_ID_STRUCT_FIELD2:
      if (self->field2 != NULL)
        g_free (self->field2);
      self->field2 = g_value_dup_string (value);
      self->__isset_field2 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_big_field_id_struct_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  TTestBigFieldIdStruct *self = T_TEST_BIG_FIELD_ID_STRUCT (object);

  switch (property_id)
  {
    case PROP_T_TEST_BIG_FIELD_ID_STRUCT_FIELD1:
      g_value_set_string (value, self->field1);
      break;

    case PROP_T_TEST_BIG_FIELD_ID_STRUCT_FIELD2:
      g_value_set_string (value, self->field2);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_big_field_id_struct_instance_init (TTestBigFieldIdStruct * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->field1 = NULL;
  object->__isset_field1 = FALSE;
  object->field2 = NULL;
  object->__isset_field2 = FALSE;
}

static void 
t_test_big_field_id_struct_finalize (GObject *object)
{
  TTestBigFieldIdStruct *tobject = T_TEST_BIG_FIELD_ID_STRUCT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->field1 != NULL)
  {
    g_free(tobject->field1);
    tobject->field1 = NULL;
  }
  if (tobject->field2 != NULL)
  {
    g_free(tobject->field2);
    tobject->field2 = NULL;
  }
}

static void
t_test_big_field_id_struct_class_init (TTestBigFieldIdStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_big_field_id_struct_read;
  struct_class->write = t_test_big_field_id_struct_write;

  gobject_class->finalize = t_test_big_field_id_struct_finalize;
  gobject_class->get_property = t_test_big_field_id_struct_get_property;
  gobject_class->set_property = t_test_big_field_id_struct_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_BIG_FIELD_ID_STRUCT_FIELD1,
     g_param_spec_string ("field1",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_BIG_FIELD_ID_STRUCT_FIELD2,
     g_param_spec_string ("field2",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
t_test_big_field_id_struct_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestBigFieldIdStructClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_big_field_id_struct_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestBigFieldIdStruct),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_big_field_id_struct_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestBigFieldIdStructType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestBreaksRubyCompactProtocolProperties
{
  PROP_T_TEST_BREAKS_RUBY_COMPACT_PROTOCOL_0,
  PROP_T_TEST_BREAKS_RUBY_COMPACT_PROTOCOL_FIELD1,
  PROP_T_TEST_BREAKS_RUBY_COMPACT_PROTOCOL_FIELD2,
  PROP_T_TEST_BREAKS_RUBY_COMPACT_PROTOCOL_FIELD3
};

/* reads a breaks_ruby_compact_protocol object */
static gint32
t_test_breaks_ruby_compact_protocol_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestBreaksRubyCompactProtocol * this_object = T_TEST_BREAKS_RUBY_COMPACT_PROTOCOL(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->field1 != NULL)
          {
            g_free(this_object->field1);
            this_object->field1 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->field1, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->field2), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_field2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field3, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field3 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_breaks_ruby_compact_protocol_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestBreaksRubyCompactProtocol * this_object = T_TEST_BREAKS_RUBY_COMPACT_PROTOCOL(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BreaksRubyCompactProtocol", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "field1", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->field1, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "field2", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->field2), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "field3", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->field3, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_breaks_ruby_compact_protocol_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  TTestBreaksRubyCompactProtocol *self = T_TEST_BREAKS_RUBY_COMPACT_PROTOCOL (object);

  switch (property_id)
  {
    case PROP_T_TEST_BREAKS_RUBY_COMPACT_PROTOCOL_FIELD1:
      if (self->field1 != NULL)
        g_free (self->field1);
      self->field1 = g_value_dup_string (value);
      self->__isset_field1 = TRUE;
      break;

    case PROP_T_TEST_BREAKS_RUBY_COMPACT_PROTOCOL_FIELD2:
      if (self->field2 != NULL)
        g_object_unref (self->field2);
      self->field2 = g_value_dup_object (value);
      self->__isset_field2 = TRUE;
      break;

    case PROP_T_TEST_BREAKS_RUBY_COMPACT_PROTOCOL_FIELD3:
      self->field3 = g_value_get_int (value);
      self->__isset_field3 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_breaks_ruby_compact_protocol_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  TTestBreaksRubyCompactProtocol *self = T_TEST_BREAKS_RUBY_COMPACT_PROTOCOL (object);

  switch (property_id)
  {
    case PROP_T_TEST_BREAKS_RUBY_COMPACT_PROTOCOL_FIELD1:
      g_value_set_string (value, self->field1);
      break;

    case PROP_T_TEST_BREAKS_RUBY_COMPACT_PROTOCOL_FIELD2:
      g_value_set_object (value, self->field2);
      break;

    case PROP_T_TEST_BREAKS_RUBY_COMPACT_PROTOCOL_FIELD3:
      g_value_set_int (value, self->field3);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_breaks_ruby_compact_protocol_instance_init (TTestBreaksRubyCompactProtocol * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->field1 = NULL;
  object->__isset_field1 = FALSE;
  object->field2 = g_object_new (T_TEST_TYPE_BIG_FIELD_ID_STRUCT, NULL);
  object->__isset_field2 = FALSE;
  object->field3 = 0;
  object->__isset_field3 = FALSE;
}

static void 
t_test_breaks_ruby_compact_protocol_finalize (GObject *object)
{
  TTestBreaksRubyCompactProtocol *tobject = T_TEST_BREAKS_RUBY_COMPACT_PROTOCOL (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->field1 != NULL)
  {
    g_free(tobject->field1);
    tobject->field1 = NULL;
  }
  if (tobject->field2 != NULL)
  {
    g_object_unref(tobject->field2);
    tobject->field2 = NULL;
  }
}

static void
t_test_breaks_ruby_compact_protocol_class_init (TTestBreaksRubyCompactProtocolClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_breaks_ruby_compact_protocol_read;
  struct_class->write = t_test_breaks_ruby_compact_protocol_write;

  gobject_class->finalize = t_test_breaks_ruby_compact_protocol_finalize;
  gobject_class->get_property = t_test_breaks_ruby_compact_protocol_get_property;
  gobject_class->set_property = t_test_breaks_ruby_compact_protocol_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_BREAKS_RUBY_COMPACT_PROTOCOL_FIELD1,
     g_param_spec_string ("field1",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_BREAKS_RUBY_COMPACT_PROTOCOL_FIELD2,
     g_param_spec_object ("field2",
                         NULL,
                         NULL,
                         T_TEST_TYPE_BIG_FIELD_ID_STRUCT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_BREAKS_RUBY_COMPACT_PROTOCOL_FIELD3,
     g_param_spec_int ("field3",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
t_test_breaks_ruby_compact_protocol_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestBreaksRubyCompactProtocolClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_breaks_ruby_compact_protocol_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestBreaksRubyCompactProtocol),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_breaks_ruby_compact_protocol_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestBreaksRubyCompactProtocolType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestTupleProtocolTestStructProperties
{
  PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_0,
  PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD1,
  PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD2,
  PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD3,
  PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD4,
  PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD5,
  PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD6,
  PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD7,
  PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD8,
  PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD9,
  PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD10,
  PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD11,
  PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD12
};

/* reads a tuple_protocol_test_struct object */
static gint32
t_test_tuple_protocol_test_struct_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestTupleProtocolTestStruct * this_object = T_TEST_TUPLE_PROTOCOL_TEST_STRUCT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case -1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field1, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case -2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field2, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case -3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field3, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field3 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case -4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field4, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field4 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case -5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field5, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field5 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case -6:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field6, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field6 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case -7:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field7, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field7 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case -8:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field8, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field8 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case -9:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field9, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field9 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case -10:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field10, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field10 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case -11:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field11, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field11 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case -12:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field12, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field12 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_tuple_protocol_test_struct_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestTupleProtocolTestStruct * this_object = T_TEST_TUPLE_PROTOCOL_TEST_STRUCT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TupleProtocolTestStruct", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_field1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "field1", T_I32, -1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->field1, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_field2 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "field2", T_I32, -2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->field2, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_field3 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "field3", T_I32, -3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->field3, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_field4 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "field4", T_I32, -4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->field4, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_field5 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "field5", T_I32, -5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->field5, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_field6 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "field6", T_I32, -6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->field6, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_field7 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "field7", T_I32, -7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->field7, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_field8 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "field8", T_I32, -8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->field8, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_field9 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "field9", T_I32, -9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->field9, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_field10 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "field10", T_I32, -10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->field10, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_field11 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "field11", T_I32, -11, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->field11, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_field12 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "field12", T_I32, -12, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->field12, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_tuple_protocol_test_struct_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  TTestTupleProtocolTestStruct *self = T_TEST_TUPLE_PROTOCOL_TEST_STRUCT (object);

  switch (property_id)
  {
    case PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD1:
      self->field1 = g_value_get_int (value);
      self->__isset_field1 = TRUE;
      break;

    case PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD2:
      self->field2 = g_value_get_int (value);
      self->__isset_field2 = TRUE;
      break;

    case PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD3:
      self->field3 = g_value_get_int (value);
      self->__isset_field3 = TRUE;
      break;

    case PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD4:
      self->field4 = g_value_get_int (value);
      self->__isset_field4 = TRUE;
      break;

    case PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD5:
      self->field5 = g_value_get_int (value);
      self->__isset_field5 = TRUE;
      break;

    case PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD6:
      self->field6 = g_value_get_int (value);
      self->__isset_field6 = TRUE;
      break;

    case PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD7:
      self->field7 = g_value_get_int (value);
      self->__isset_field7 = TRUE;
      break;

    case PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD8:
      self->field8 = g_value_get_int (value);
      self->__isset_field8 = TRUE;
      break;

    case PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD9:
      self->field9 = g_value_get_int (value);
      self->__isset_field9 = TRUE;
      break;

    case PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD10:
      self->field10 = g_value_get_int (value);
      self->__isset_field10 = TRUE;
      break;

    case PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD11:
      self->field11 = g_value_get_int (value);
      self->__isset_field11 = TRUE;
      break;

    case PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD12:
      self->field12 = g_value_get_int (value);
      self->__isset_field12 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_tuple_protocol_test_struct_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  TTestTupleProtocolTestStruct *self = T_TEST_TUPLE_PROTOCOL_TEST_STRUCT (object);

  switch (property_id)
  {
    case PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD1:
      g_value_set_int (value, self->field1);
      break;

    case PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD2:
      g_value_set_int (value, self->field2);
      break;

    case PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD3:
      g_value_set_int (value, self->field3);
      break;

    case PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD4:
      g_value_set_int (value, self->field4);
      break;

    case PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD5:
      g_value_set_int (value, self->field5);
      break;

    case PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD6:
      g_value_set_int (value, self->field6);
      break;

    case PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD7:
      g_value_set_int (value, self->field7);
      break;

    case PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD8:
      g_value_set_int (value, self->field8);
      break;

    case PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD9:
      g_value_set_int (value, self->field9);
      break;

    case PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD10:
      g_value_set_int (value, self->field10);
      break;

    case PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD11:
      g_value_set_int (value, self->field11);
      break;

    case PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD12:
      g_value_set_int (value, self->field12);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_tuple_protocol_test_struct_instance_init (TTestTupleProtocolTestStruct * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->field1 = 0;
  object->__isset_field1 = FALSE;
  object->field2 = 0;
  object->__isset_field2 = FALSE;
  object->field3 = 0;
  object->__isset_field3 = FALSE;
  object->field4 = 0;
  object->__isset_field4 = FALSE;
  object->field5 = 0;
  object->__isset_field5 = FALSE;
  object->field6 = 0;
  object->__isset_field6 = FALSE;
  object->field7 = 0;
  object->__isset_field7 = FALSE;
  object->field8 = 0;
  object->__isset_field8 = FALSE;
  object->field9 = 0;
  object->__isset_field9 = FALSE;
  object->field10 = 0;
  object->__isset_field10 = FALSE;
  object->field11 = 0;
  object->__isset_field11 = FALSE;
  object->field12 = 0;
  object->__isset_field12 = FALSE;
}

static void 
t_test_tuple_protocol_test_struct_finalize (GObject *object)
{
  TTestTupleProtocolTestStruct *tobject = T_TEST_TUPLE_PROTOCOL_TEST_STRUCT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_tuple_protocol_test_struct_class_init (TTestTupleProtocolTestStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_tuple_protocol_test_struct_read;
  struct_class->write = t_test_tuple_protocol_test_struct_write;

  gobject_class->finalize = t_test_tuple_protocol_test_struct_finalize;
  gobject_class->get_property = t_test_tuple_protocol_test_struct_get_property;
  gobject_class->set_property = t_test_tuple_protocol_test_struct_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD1,
     g_param_spec_int ("field1",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD2,
     g_param_spec_int ("field2",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD3,
     g_param_spec_int ("field3",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD4,
     g_param_spec_int ("field4",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD5,
     g_param_spec_int ("field5",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD6,
     g_param_spec_int ("field6",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD7,
     g_param_spec_int ("field7",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD8,
     g_param_spec_int ("field8",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD9,
     g_param_spec_int ("field9",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD10,
     g_param_spec_int ("field10",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD11,
     g_param_spec_int ("field11",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_TUPLE_PROTOCOL_TEST_STRUCT_FIELD12,
     g_param_spec_int ("field12",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
t_test_tuple_protocol_test_struct_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestTupleProtocolTestStructClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_tuple_protocol_test_struct_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestTupleProtocolTestStruct),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_tuple_protocol_test_struct_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestTupleProtocolTestStructType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestListDoublePerfProperties
{
  PROP_T_TEST_LIST_DOUBLE_PERF_0,
  PROP_T_TEST_LIST_DOUBLE_PERF_FIELD
};

/* reads a list_double_perf object */
static gint32
t_test_list_double_perf_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestListDoublePerf * this_object = T_TEST_LIST_DOUBLE_PERF(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gdouble* _elem221 = g_new (gdouble, 1);
              if ((ret = thrift_protocol_read_double (protocol, &*_elem221, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->field, _elem221, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_list_double_perf_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestListDoublePerf * this_object = T_TEST_LIST_DOUBLE_PERF(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ListDoublePerf", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "field", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i222;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_DOUBLE, (gint32) this_object->field->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i222 = 0; i222 < this_object->field->len; i222++)
    {
      if ((ret = thrift_protocol_write_double (protocol, (g_array_index (this_object->field, gdouble, i222)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_list_double_perf_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  TTestListDoublePerf *self = T_TEST_LIST_DOUBLE_PERF (object);

  switch (property_id)
  {
    case PROP_T_TEST_LIST_DOUBLE_PERF_FIELD:
      if (self->field != NULL)
        g_array_unref (self->field);
      self->field = g_value_dup_boxed (value);
      self->__isset_field = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_list_double_perf_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  TTestListDoublePerf *self = T_TEST_LIST_DOUBLE_PERF (object);

  switch (property_id)
  {
    case PROP_T_TEST_LIST_DOUBLE_PERF_FIELD:
      g_value_set_boxed (value, self->field);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_list_double_perf_instance_init (TTestListDoublePerf * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->field = g_array_new (0, 1, sizeof (gdouble));
  object->__isset_field = FALSE;
}

static void 
t_test_list_double_perf_finalize (GObject *object)
{
  TTestListDoublePerf *tobject = T_TEST_LIST_DOUBLE_PERF (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->field != NULL)
  {
    g_array_unref (tobject->field);
    tobject->field = NULL;
  }
}

static void
t_test_list_double_perf_class_init (TTestListDoublePerfClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_list_double_perf_read;
  struct_class->write = t_test_list_double_perf_write;

  gobject_class->finalize = t_test_list_double_perf_finalize;
  gobject_class->get_property = t_test_list_double_perf_get_property;
  gobject_class->set_property = t_test_list_double_perf_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_LIST_DOUBLE_PERF_FIELD,
     g_param_spec_boxed ("field",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_test_list_double_perf_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestListDoublePerfClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_list_double_perf_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestListDoublePerf),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_list_double_perf_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestListDoublePerfType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */
static TTestEmpty *
t_test_compact_test_constant_empty_struct_field231_constant (void)
{
  static TTestEmpty *constant = NULL;
  if (constant == NULL)
  {
    constant = g_object_new (T_TEST_TYPE_EMPTY, NULL);
  }
  return constant;
}

static GArray *
t_test_compact_test_constant_byte_list232_constant (void)
{
  static GArray * constant = NULL;
  if (constant == NULL)
  {
    gint8 compact_test_constant_byte_list232233 = -127;
    gint8 compact_test_constant_byte_list232234 = -1;
    gint8 compact_test_constant_byte_list232235 = 0;
    gint8 compact_test_constant_byte_list232236 = 1;
    gint8 compact_test_constant_byte_list232237 = 127;

    constant = g_array_new (0, 1, sizeof (gint8));
    g_array_append_val(constant, compact_test_constant_byte_list232233);
    g_array_append_val(constant, compact_test_constant_byte_list232234);
    g_array_append_val(constant, compact_test_constant_byte_list232235);
    g_array_append_val(constant, compact_test_constant_byte_list232236);
    g_array_append_val(constant, compact_test_constant_byte_list232237);
  }
  return constant;
}

static GArray *
t_test_compact_test_constant_i16_list238_constant (void)
{
  static GArray * constant = NULL;
  if (constant == NULL)
  {
    gint16 compact_test_constant_i16_list238239 = -1;
    gint16 compact_test_constant_i16_list238240 = 0;
    gint16 compact_test_constant_i16_list238241 = 1;
    gint16 compact_test_constant_i16_list238242 = 32767;

    constant = g_array_new (0, 1, sizeof (gint16));
    g_array_append_val(constant, compact_test_constant_i16_list238239);
    g_array_append_val(constant, compact_test_constant_i16_list238240);
    g_array_append_val(constant, compact_test_constant_i16_list238241);
    g_array_append_val(constant, compact_test_constant_i16_list238242);
  }
  return constant;
}

static GArray *
t_test_compact_test_constant_i32_list243_constant (void)
{
  static GArray * constant = NULL;
  if (constant == NULL)
  {
    gint32 compact_test_constant_i32_list243244 = -1;
    gint32 compact_test_constant_i32_list243245 = 0;
    gint32 compact_test_constant_i32_list243246 = 255;
    gint32 compact_test_constant_i32_list243247 = 65535;
    gint32 compact_test_constant_i32_list243248 = 16777215;
    gint32 compact_test_constant_i32_list243249 = 2147483647;

    constant = g_array_new (0, 1, sizeof (gint32));
    g_array_append_val(constant, compact_test_constant_i32_list243244);
    g_array_append_val(constant, compact_test_constant_i32_list243245);
    g_array_append_val(constant, compact_test_constant_i32_list243246);
    g_array_append_val(constant, compact_test_constant_i32_list243247);
    g_array_append_val(constant, compact_test_constant_i32_list243248);
    g_array_append_val(constant, compact_test_constant_i32_list243249);
  }
  return constant;
}

static GArray *
t_test_compact_test_constant_i64_list250_constant (void)
{
  static GArray * constant = NULL;
  if (constant == NULL)
  {
    gint64 compact_test_constant_i64_list250251 = -1;
    gint64 compact_test_constant_i64_list250252 = 0;
    gint64 compact_test_constant_i64_list250253 = 255;
    gint64 compact_test_constant_i64_list250254 = 65535;
    gint64 compact_test_constant_i64_list250255 = 16777215;
    gint64 compact_test_constant_i64_list250256 = 4294967295;
    gint64 compact_test_constant_i64_list250257 = 1099511627775;
    gint64 compact_test_constant_i64_list250258 = 281474976710655;
    gint64 compact_test_constant_i64_list250259 = 72057594037927935;
    gint64 compact_test_constant_i64_list250260 = 9223372036854775807;

    constant = g_array_new (0, 1, sizeof (gint64));
    g_array_append_val(constant, compact_test_constant_i64_list250251);
    g_array_append_val(constant, compact_test_constant_i64_list250252);
    g_array_append_val(constant, compact_test_constant_i64_list250253);
    g_array_append_val(constant, compact_test_constant_i64_list250254);
    g_array_append_val(constant, compact_test_constant_i64_list250255);
    g_array_append_val(constant, compact_test_constant_i64_list250256);
    g_array_append_val(constant, compact_test_constant_i64_list250257);
    g_array_append_val(constant, compact_test_constant_i64_list250258);
    g_array_append_val(constant, compact_test_constant_i64_list250259);
    g_array_append_val(constant, compact_test_constant_i64_list250260);
  }
  return constant;
}

static GArray *
t_test_compact_test_constant_double_list261_constant (void)
{
  static GArray * constant = NULL;
  if (constant == NULL)
  {
    gdouble compact_test_constant_double_list261262 = 0.1;
    gdouble compact_test_constant_double_list261263 = 0.2;
    gdouble compact_test_constant_double_list261264 = 0.3;

    constant = g_array_new (0, 1, sizeof (gdouble));
    g_array_append_val(constant, compact_test_constant_double_list261262);
    g_array_append_val(constant, compact_test_constant_double_list261263);
    g_array_append_val(constant, compact_test_constant_double_list261264);
  }
  return constant;
}

static GPtrArray *
t_test_compact_test_constant_string_list265_constant (void)
{
  static GPtrArray * constant = NULL;
  if (constant == NULL)
  {
    constant = g_ptr_array_new_with_free_func (g_free);
    g_ptr_array_add(constant, g_strdup ("first"));
    g_ptr_array_add(constant, g_strdup ("second"));
    g_ptr_array_add(constant, g_strdup ("third"));
  }
  return constant;
}

static GArray *
t_test_compact_test_constant_boolean_list269_constant (void)
{
  static GArray * constant = NULL;
  if (constant == NULL)
  {
    gboolean compact_test_constant_boolean_list269270 = 1;
    gboolean compact_test_constant_boolean_list269271 = 1;
    gboolean compact_test_constant_boolean_list269272 = 1;
    gboolean compact_test_constant_boolean_list269273 = 0;
    gboolean compact_test_constant_boolean_list269274 = 0;
    gboolean compact_test_constant_boolean_list269275 = 0;

    constant = g_array_new (0, 1, sizeof (gboolean));
    g_array_append_val(constant, compact_test_constant_boolean_list269270);
    g_array_append_val(constant, compact_test_constant_boolean_list269271);
    g_array_append_val(constant, compact_test_constant_boolean_list269272);
    g_array_append_val(constant, compact_test_constant_boolean_list269273);
    g_array_append_val(constant, compact_test_constant_boolean_list269274);
    g_array_append_val(constant, compact_test_constant_boolean_list269275);
  }
  return constant;
}

static TTestEmpty *
t_test_compact_test_constant_struct_list276277_constant (void)
{
  static TTestEmpty *constant = NULL;
  if (constant == NULL)
  {
    constant = g_object_new (T_TEST_TYPE_EMPTY, NULL);
  }
  return constant;
}

static TTestEmpty *
t_test_compact_test_constant_struct_list276278_constant (void)
{
  static TTestEmpty *constant = NULL;
  if (constant == NULL)
  {
    constant = g_object_new (T_TEST_TYPE_EMPTY, NULL);
  }
  return constant;
}

static GPtrArray *
t_test_compact_test_constant_struct_list276_constant (void)
{
  static GPtrArray * constant = NULL;
  if (constant == NULL)
  {
    constant = g_ptr_array_new_with_free_func (g_object_unref);
    g_ptr_array_add(constant, (t_test_compact_test_constant_struct_list276277_constant()));
    g_ptr_array_add(constant, (t_test_compact_test_constant_struct_list276278_constant()));
  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_byte_set279_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    gint8 compact_test_constant_byte_set279280 = -127;
    gint8 compact_test_constant_byte_set279281 = -1;
    gint8 compact_test_constant_byte_set279282 = 0;
    gint8 compact_test_constant_byte_set279283 = 1;
    gint8 compact_test_constant_byte_set279284 = 127;

    constant = g_hash_table_new (NULL, NULL);
    g_hash_table_insert (constant, &compact_test_constant_byte_set279280, &compact_test_constant_byte_set279280);
    g_hash_table_insert (constant, &compact_test_constant_byte_set279281, &compact_test_constant_byte_set279281);
    g_hash_table_insert (constant, &compact_test_constant_byte_set279282, &compact_test_constant_byte_set279282);
    g_hash_table_insert (constant, &compact_test_constant_byte_set279283, &compact_test_constant_byte_set279283);
    g_hash_table_insert (constant, &compact_test_constant_byte_set279284, &compact_test_constant_byte_set279284);
  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_i16_set285_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    gint16 compact_test_constant_i16_set285286 = -1;
    gint16 compact_test_constant_i16_set285287 = 0;
    gint16 compact_test_constant_i16_set285288 = 1;
    gint16 compact_test_constant_i16_set285289 = 32767;

    constant = g_hash_table_new (NULL, NULL);
    g_hash_table_insert (constant, &compact_test_constant_i16_set285286, &compact_test_constant_i16_set285286);
    g_hash_table_insert (constant, &compact_test_constant_i16_set285287, &compact_test_constant_i16_set285287);
    g_hash_table_insert (constant, &compact_test_constant_i16_set285288, &compact_test_constant_i16_set285288);
    g_hash_table_insert (constant, &compact_test_constant_i16_set285289, &compact_test_constant_i16_set285289);
  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_i32_set290_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    gint32 compact_test_constant_i32_set290291 = 1;
    gint32 compact_test_constant_i32_set290292 = 2;
    gint32 compact_test_constant_i32_set290293 = 3;

    constant = g_hash_table_new (NULL, NULL);
    g_hash_table_insert (constant, &compact_test_constant_i32_set290291, &compact_test_constant_i32_set290291);
    g_hash_table_insert (constant, &compact_test_constant_i32_set290292, &compact_test_constant_i32_set290292);
    g_hash_table_insert (constant, &compact_test_constant_i32_set290293, &compact_test_constant_i32_set290293);
  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_i64_set294_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    gint64 compact_test_constant_i64_set294295 = -1;
    gint64 compact_test_constant_i64_set294296 = 0;
    gint64 compact_test_constant_i64_set294297 = 255;
    gint64 compact_test_constant_i64_set294298 = 65535;
    gint64 compact_test_constant_i64_set294299 = 16777215;
    gint64 compact_test_constant_i64_set294300 = 4294967295;
    gint64 compact_test_constant_i64_set294301 = 1099511627775;
    gint64 compact_test_constant_i64_set294302 = 281474976710655;
    gint64 compact_test_constant_i64_set294303 = 72057594037927935;
    gint64 compact_test_constant_i64_set294304 = 9223372036854775807;

    constant = g_hash_table_new (NULL, NULL);
    g_hash_table_insert (constant, &compact_test_constant_i64_set294295, &compact_test_constant_i64_set294295);
    g_hash_table_insert (constant, &compact_test_constant_i64_set294296, &compact_test_constant_i64_set294296);
    g_hash_table_insert (constant, &compact_test_constant_i64_set294297, &compact_test_constant_i64_set294297);
    g_hash_table_insert (constant, &compact_test_constant_i64_set294298, &compact_test_constant_i64_set294298);
    g_hash_table_insert (constant, &compact_test_constant_i64_set294299, &compact_test_constant_i64_set294299);
    g_hash_table_insert (constant, &compact_test_constant_i64_set294300, &compact_test_constant_i64_set294300);
    g_hash_table_insert (constant, &compact_test_constant_i64_set294301, &compact_test_constant_i64_set294301);
    g_hash_table_insert (constant, &compact_test_constant_i64_set294302, &compact_test_constant_i64_set294302);
    g_hash_table_insert (constant, &compact_test_constant_i64_set294303, &compact_test_constant_i64_set294303);
    g_hash_table_insert (constant, &compact_test_constant_i64_set294304, &compact_test_constant_i64_set294304);
  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_double_set305_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    gdouble compact_test_constant_double_set305306 = 0.1;
    gdouble compact_test_constant_double_set305307 = 0.2;
    gdouble compact_test_constant_double_set305308 = 0.3;

    constant = g_hash_table_new (NULL, NULL);
    g_hash_table_insert (constant, &compact_test_constant_double_set305306, &compact_test_constant_double_set305306);
    g_hash_table_insert (constant, &compact_test_constant_double_set305307, &compact_test_constant_double_set305307);
    g_hash_table_insert (constant, &compact_test_constant_double_set305308, &compact_test_constant_double_set305308);
  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_string_set309_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    gchar * compact_test_constant_string_set309310 = g_strdup ("first");
    gchar * compact_test_constant_string_set309311 = g_strdup ("second");
    gchar * compact_test_constant_string_set309312 = g_strdup ("third");

    constant = g_hash_table_new (NULL, NULL);
    g_hash_table_insert (constant, &compact_test_constant_string_set309310, &compact_test_constant_string_set309310);
    g_hash_table_insert (constant, &compact_test_constant_string_set309311, &compact_test_constant_string_set309311);
    g_hash_table_insert (constant, &compact_test_constant_string_set309312, &compact_test_constant_string_set309312);
  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_boolean_set313_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    gboolean compact_test_constant_boolean_set313314 = 1;
    gboolean compact_test_constant_boolean_set313315 = 0;

    constant = g_hash_table_new (NULL, NULL);
    g_hash_table_insert (constant, &compact_test_constant_boolean_set313314, &compact_test_constant_boolean_set313314);
    g_hash_table_insert (constant, &compact_test_constant_boolean_set313315, &compact_test_constant_boolean_set313315);
  }
  return constant;
}

static TTestEmpty *
t_test_compact_test_constant_struct_set316317_constant (void)
{
  static TTestEmpty *constant = NULL;
  if (constant == NULL)
  {
    constant = g_object_new (T_TEST_TYPE_EMPTY, NULL);
  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_struct_set316_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {
    TTestEmpty * compact_test_constant_struct_set316317 = (t_test_compact_test_constant_struct_set316317_constant());

    constant = g_hash_table_new (NULL, NULL);
    g_hash_table_insert (constant, &compact_test_constant_struct_set316317, &compact_test_constant_struct_set316317);
  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_byte_byte_map318_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {

    constant = g_hash_table_new (NULL, NULL);
  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_i16_byte_map319_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {

    constant = g_hash_table_new (NULL, NULL);
  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_i32_byte_map320_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {

    constant = g_hash_table_new (NULL, NULL);
  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_i64_byte_map321_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {

    constant = g_hash_table_new (NULL, NULL);
  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_double_byte_map322_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {

    constant = g_hash_table_new (NULL, NULL);
  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_string_byte_map323_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {

    constant = g_hash_table_new (NULL, NULL);
  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_boolean_byte_map324_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {

    constant = g_hash_table_new (NULL, NULL);
  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_byte_i16_map325_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {

    constant = g_hash_table_new (NULL, NULL);
  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_byte_i32_map326_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {

    constant = g_hash_table_new (NULL, NULL);
  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_byte_i64_map327_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {

    constant = g_hash_table_new (NULL, NULL);
  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_byte_double_map328_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {

    constant = g_hash_table_new (NULL, NULL);
  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_byte_string_map329_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {

    constant = g_hash_table_new (NULL, NULL);
  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_byte_boolean_map330_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {

    constant = g_hash_table_new (NULL, NULL);
  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_list_byte_map331_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {

    constant = g_hash_table_new (NULL, NULL);
  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_set_byte_map332_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {

    constant = g_hash_table_new (NULL, NULL);
  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_map_byte_map333_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {

    constant = g_hash_table_new (NULL, NULL);
  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_byte_map_map334_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {

    constant = g_hash_table_new (NULL, NULL);
  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_byte_set_map335_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {

    constant = g_hash_table_new (NULL, NULL);
  }
  return constant;
}

static GHashTable *
t_test_compact_test_constant_byte_list_map336_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {

    constant = g_hash_table_new (NULL, NULL);
  }
  return constant;
}

static TTestCompactProtoTestStruct *
t_test_compact_test_constant (void)
{
  static TTestCompactProtoTestStruct *constant = NULL;
  if (constant == NULL)
  {
    constant = g_object_new (T_TEST_TYPE_COMPACT_PROTO_TEST_STRUCT, NULL);
    constant->a_byte = 127;
    constant->__isset_a_byte = TRUE;
    constant->a_i16 = 32000;
    constant->__isset_a_i16 = TRUE;
    constant->a_i32 = 1000000000;
    constant->__isset_a_i32 = TRUE;
    constant->a_i64 = 1099511627775;
    constant->__isset_a_i64 = TRUE;
    constant->a_double = 5.6789;
    constant->__isset_a_double = TRUE;
    constant->a_string = g_strdup ("my string");
    constant->__isset_a_string = TRUE;
    constant->true_field = 1;
    constant->__isset_true_field = TRUE;
    constant->false_field = 0;
    constant->__isset_false_field = TRUE;
    constant->empty_struct_field = (t_test_compact_test_constant_empty_struct_field231_constant());
    constant->__isset_empty_struct_field = TRUE;
    constant->byte_list = (t_test_compact_test_constant_byte_list232_constant());
    constant->__isset_byte_list = TRUE;
    constant->i16_list = (t_test_compact_test_constant_i16_list238_constant());
    constant->__isset_i16_list = TRUE;
    constant->i32_list = (t_test_compact_test_constant_i32_list243_constant());
    constant->__isset_i32_list = TRUE;
    constant->i64_list = (t_test_compact_test_constant_i64_list250_constant());
    constant->__isset_i64_list = TRUE;
    constant->double_list = (t_test_compact_test_constant_double_list261_constant());
    constant->__isset_double_list = TRUE;
    constant->string_list = (t_test_compact_test_constant_string_list265_constant());
    constant->__isset_string_list = TRUE;
    constant->boolean_list = (t_test_compact_test_constant_boolean_list269_constant());
    constant->__isset_boolean_list = TRUE;
    constant->struct_list = (t_test_compact_test_constant_struct_list276_constant());
    constant->__isset_struct_list = TRUE;
    constant->byte_set = (t_test_compact_test_constant_byte_set279_constant());
    constant->__isset_byte_set = TRUE;
    constant->i16_set = (t_test_compact_test_constant_i16_set285_constant());
    constant->__isset_i16_set = TRUE;
    constant->i32_set = (t_test_compact_test_constant_i32_set290_constant());
    constant->__isset_i32_set = TRUE;
    constant->i64_set = (t_test_compact_test_constant_i64_set294_constant());
    constant->__isset_i64_set = TRUE;
    constant->double_set = (t_test_compact_test_constant_double_set305_constant());
    constant->__isset_double_set = TRUE;
    constant->string_set = (t_test_compact_test_constant_string_set309_constant());
    constant->__isset_string_set = TRUE;
    constant->boolean_set = (t_test_compact_test_constant_boolean_set313_constant());
    constant->__isset_boolean_set = TRUE;
    constant->struct_set = (t_test_compact_test_constant_struct_set316_constant());
    constant->__isset_struct_set = TRUE;
    constant->byte_byte_map = (t_test_compact_test_constant_byte_byte_map318_constant());
    constant->__isset_byte_byte_map = TRUE;
    constant->i16_byte_map = (t_test_compact_test_constant_i16_byte_map319_constant());
    constant->__isset_i16_byte_map = TRUE;
    constant->i32_byte_map = (t_test_compact_test_constant_i32_byte_map320_constant());
    constant->__isset_i32_byte_map = TRUE;
    constant->i64_byte_map = (t_test_compact_test_constant_i64_byte_map321_constant());
    constant->__isset_i64_byte_map = TRUE;
    constant->double_byte_map = (t_test_compact_test_constant_double_byte_map322_constant());
    constant->__isset_double_byte_map = TRUE;
    constant->string_byte_map = (t_test_compact_test_constant_string_byte_map323_constant());
    constant->__isset_string_byte_map = TRUE;
    constant->boolean_byte_map = (t_test_compact_test_constant_boolean_byte_map324_constant());
    constant->__isset_boolean_byte_map = TRUE;
    constant->byte_i16_map = (t_test_compact_test_constant_byte_i16_map325_constant());
    constant->__isset_byte_i16_map = TRUE;
    constant->byte_i32_map = (t_test_compact_test_constant_byte_i32_map326_constant());
    constant->__isset_byte_i32_map = TRUE;
    constant->byte_i64_map = (t_test_compact_test_constant_byte_i64_map327_constant());
    constant->__isset_byte_i64_map = TRUE;
    constant->byte_double_map = (t_test_compact_test_constant_byte_double_map328_constant());
    constant->__isset_byte_double_map = TRUE;
    constant->byte_string_map = (t_test_compact_test_constant_byte_string_map329_constant());
    constant->__isset_byte_string_map = TRUE;
    constant->byte_boolean_map = (t_test_compact_test_constant_byte_boolean_map330_constant());
    constant->__isset_byte_boolean_map = TRUE;
    constant->list_byte_map = (t_test_compact_test_constant_list_byte_map331_constant());
    constant->__isset_list_byte_map = TRUE;
    constant->set_byte_map = (t_test_compact_test_constant_set_byte_map332_constant());
    constant->__isset_set_byte_map = TRUE;
    constant->map_byte_map = (t_test_compact_test_constant_map_byte_map333_constant());
    constant->__isset_map_byte_map = TRUE;
    constant->byte_map_map = (t_test_compact_test_constant_byte_map_map334_constant());
    constant->__isset_byte_map_map = TRUE;
    constant->byte_set_map = (t_test_compact_test_constant_byte_set_map335_constant());
    constant->__isset_byte_set_map = TRUE;
    constant->byte_list_map = (t_test_compact_test_constant_byte_list_map336_constant());
    constant->__isset_byte_list_map = TRUE;
  }
  return constant;
}

static GHashTable *
t_test_my_enum_map_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {

    constant = g_hash_table_new (NULL, NULL);
  }
  return constant;
}

static GHashTable *
t_test_extra_crazy_map_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {

    constant = g_hash_table_new (NULL, NULL);
  }
  return constant;
}


/* reads a service_for_exception_with_a_map_method_that_throws_an_exception_args object */
static gint32
t_test_service_for_exception_with_a_map_method_that_throws_an_exception_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestServiceForExceptionWithAMapMethodThatThrowsAnExceptionArgs * this_object = T_TEST_SERVICE_FOR_EXCEPTION_WITH_A_MAP_METHOD_THAT_THROWS_AN_EXCEPTION_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_service_for_exception_with_a_map_method_that_throws_an_exception_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestServiceForExceptionWithAMapMethodThatThrowsAnExceptionArgs * this_object = T_TEST_SERVICE_FOR_EXCEPTION_WITH_A_MAP_METHOD_THAT_THROWS_AN_EXCEPTION_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceForExceptionWithAMapMethodThatThrowsAnExceptionArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_service_for_exception_with_a_map_method_that_throws_an_exception_args_instance_init (TTestServiceForExceptionWithAMapMethodThatThrowsAnExceptionArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
t_test_service_for_exception_with_a_map_method_that_throws_an_exception_args_finalize (GObject *object)
{
  TTestServiceForExceptionWithAMapMethodThatThrowsAnExceptionArgs *tobject = T_TEST_SERVICE_FOR_EXCEPTION_WITH_A_MAP_METHOD_THAT_THROWS_AN_EXCEPTION_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_service_for_exception_with_a_map_method_that_throws_an_exception_args_class_init (TTestServiceForExceptionWithAMapMethodThatThrowsAnExceptionArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_service_for_exception_with_a_map_method_that_throws_an_exception_args_read;
  struct_class->write = t_test_service_for_exception_with_a_map_method_that_throws_an_exception_args_write;

  gobject_class->finalize = t_test_service_for_exception_with_a_map_method_that_throws_an_exception_args_finalize;
}

GType
t_test_service_for_exception_with_a_map_method_that_throws_an_exception_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestServiceForExceptionWithAMapMethodThatThrowsAnExceptionArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_service_for_exception_with_a_map_method_that_throws_an_exception_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestServiceForExceptionWithAMapMethodThatThrowsAnExceptionArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_service_for_exception_with_a_map_method_that_throws_an_exception_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestServiceForExceptionWithAMapMethodThatThrowsAnExceptionArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestServiceForExceptionWithAMapMethodThatThrowsAnExceptionResultProperties
{
  PROP_T_TEST_SERVICE_FOR_EXCEPTION_WITH_A_MAP_METHOD_THAT_THROWS_AN_EXCEPTION_RESULT_0,
  PROP_T_TEST_SERVICE_FOR_EXCEPTION_WITH_A_MAP_METHOD_THAT_THROWS_AN_EXCEPTION_RESULT_XWAMAP
};

/* reads a service_for_exception_with_a_map_method_that_throws_an_exception_result object */
static gint32
t_test_service_for_exception_with_a_map_method_that_throws_an_exception_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestServiceForExceptionWithAMapMethodThatThrowsAnExceptionResult * this_object = T_TEST_SERVICE_FOR_EXCEPTION_WITH_A_MAP_METHOD_THAT_THROWS_AN_EXCEPTION_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->xwamap != NULL)
          {
            g_object_unref (this_object->xwamap);
          }
          this_object->xwamap = g_object_new (T_TEST_TYPE_EXCEPTION_WITH_A_MAP, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->xwamap), protocol, error)) < 0)
          {
            g_object_unref (this_object->xwamap);
            this_object->xwamap = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_xwamap = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_service_for_exception_with_a_map_method_that_throws_an_exception_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestServiceForExceptionWithAMapMethodThatThrowsAnExceptionResult * this_object = T_TEST_SERVICE_FOR_EXCEPTION_WITH_A_MAP_METHOD_THAT_THROWS_AN_EXCEPTION_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceForExceptionWithAMapMethodThatThrowsAnExceptionResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_xwamap == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "xwamap", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->xwamap), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_service_for_exception_with_a_map_method_that_throws_an_exception_result_set_property (GObject *object,
                                                                                             guint property_id,
                                                                                             const GValue *value,
                                                                                             GParamSpec *pspec)
{
  TTestServiceForExceptionWithAMapMethodThatThrowsAnExceptionResult *self = T_TEST_SERVICE_FOR_EXCEPTION_WITH_A_MAP_METHOD_THAT_THROWS_AN_EXCEPTION_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_SERVICE_FOR_EXCEPTION_WITH_A_MAP_METHOD_THAT_THROWS_AN_EXCEPTION_RESULT_XWAMAP:
      if (self->xwamap != NULL)
        g_object_unref (self->xwamap);
      self->xwamap = g_value_dup_object (value);
      self->__isset_xwamap = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_service_for_exception_with_a_map_method_that_throws_an_exception_result_get_property (GObject *object,
                                                                                             guint property_id,
                                                                                             GValue *value,
                                                                                             GParamSpec *pspec)
{
  TTestServiceForExceptionWithAMapMethodThatThrowsAnExceptionResult *self = T_TEST_SERVICE_FOR_EXCEPTION_WITH_A_MAP_METHOD_THAT_THROWS_AN_EXCEPTION_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_SERVICE_FOR_EXCEPTION_WITH_A_MAP_METHOD_THAT_THROWS_AN_EXCEPTION_RESULT_XWAMAP:
      g_value_set_object (value, self->xwamap);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_service_for_exception_with_a_map_method_that_throws_an_exception_result_instance_init (TTestServiceForExceptionWithAMapMethodThatThrowsAnExceptionResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->xwamap = NULL;
  object->__isset_xwamap = FALSE;
}

static void 
t_test_service_for_exception_with_a_map_method_that_throws_an_exception_result_finalize (GObject *object)
{
  TTestServiceForExceptionWithAMapMethodThatThrowsAnExceptionResult *tobject = T_TEST_SERVICE_FOR_EXCEPTION_WITH_A_MAP_METHOD_THAT_THROWS_AN_EXCEPTION_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->xwamap != NULL)
  {
    g_object_unref(tobject->xwamap);
    tobject->xwamap = NULL;
  }
}

static void
t_test_service_for_exception_with_a_map_method_that_throws_an_exception_result_class_init (TTestServiceForExceptionWithAMapMethodThatThrowsAnExceptionResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_service_for_exception_with_a_map_method_that_throws_an_exception_result_read;
  struct_class->write = t_test_service_for_exception_with_a_map_method_that_throws_an_exception_result_write;

  gobject_class->finalize = t_test_service_for_exception_with_a_map_method_that_throws_an_exception_result_finalize;
  gobject_class->get_property = t_test_service_for_exception_with_a_map_method_that_throws_an_exception_result_get_property;
  gobject_class->set_property = t_test_service_for_exception_with_a_map_method_that_throws_an_exception_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_SERVICE_FOR_EXCEPTION_WITH_A_MAP_METHOD_THAT_THROWS_AN_EXCEPTION_RESULT_XWAMAP,
     g_param_spec_object ("xwamap",
                         NULL,
                         NULL,
                         T_TEST_TYPE_EXCEPTION_WITH_A_MAP,
                         G_PARAM_READWRITE));
}

GType
t_test_service_for_exception_with_a_map_method_that_throws_an_exception_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestServiceForExceptionWithAMapMethodThatThrowsAnExceptionResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_service_for_exception_with_a_map_method_that_throws_an_exception_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestServiceForExceptionWithAMapMethodThatThrowsAnExceptionResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_service_for_exception_with_a_map_method_that_throws_an_exception_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestServiceForExceptionWithAMapMethodThatThrowsAnExceptionResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestSrvJankyArgsProperties
{
  PROP_T_TEST_SRV_JANKY_ARGS_0,
  PROP_T_TEST_SRV_JANKY_ARGS_ARG
};

/* reads a srv_janky_args object */
static gint32
t_test_srv_janky_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestSrvJankyArgs * this_object = T_TEST_SRV_JANKY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->arg, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_arg = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_srv_janky_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestSrvJankyArgs * this_object = T_TEST_SRV_JANKY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SrvJankyArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "arg", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->arg, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_srv_janky_args_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  TTestSrvJankyArgs *self = T_TEST_SRV_JANKY_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_SRV_JANKY_ARGS_ARG:
      self->arg = g_value_get_int (value);
      self->__isset_arg = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_srv_janky_args_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  TTestSrvJankyArgs *self = T_TEST_SRV_JANKY_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_SRV_JANKY_ARGS_ARG:
      g_value_set_int (value, self->arg);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_srv_janky_args_instance_init (TTestSrvJankyArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->arg = 0;
  object->__isset_arg = FALSE;
}

static void 
t_test_srv_janky_args_finalize (GObject *object)
{
  TTestSrvJankyArgs *tobject = T_TEST_SRV_JANKY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_srv_janky_args_class_init (TTestSrvJankyArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_srv_janky_args_read;
  struct_class->write = t_test_srv_janky_args_write;

  gobject_class->finalize = t_test_srv_janky_args_finalize;
  gobject_class->get_property = t_test_srv_janky_args_get_property;
  gobject_class->set_property = t_test_srv_janky_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_SRV_JANKY_ARGS_ARG,
     g_param_spec_int ("arg",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
t_test_srv_janky_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestSrvJankyArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_srv_janky_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestSrvJankyArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_srv_janky_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestSrvJankyArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestSrvJankyResultProperties
{
  PROP_T_TEST_SRV_JANKY_RESULT_0,
  PROP_T_TEST_SRV_JANKY_RESULT_SUCCESS
};

/* reads a srv_janky_result object */
static gint32
t_test_srv_janky_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestSrvJankyResult * this_object = T_TEST_SRV_JANKY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_srv_janky_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestSrvJankyResult * this_object = T_TEST_SRV_JANKY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SrvJankyResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_srv_janky_result_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  TTestSrvJankyResult *self = T_TEST_SRV_JANKY_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_SRV_JANKY_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_srv_janky_result_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  TTestSrvJankyResult *self = T_TEST_SRV_JANKY_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_SRV_JANKY_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_srv_janky_result_instance_init (TTestSrvJankyResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
t_test_srv_janky_result_finalize (GObject *object)
{
  TTestSrvJankyResult *tobject = T_TEST_SRV_JANKY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_srv_janky_result_class_init (TTestSrvJankyResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_srv_janky_result_read;
  struct_class->write = t_test_srv_janky_result_write;

  gobject_class->finalize = t_test_srv_janky_result_finalize;
  gobject_class->get_property = t_test_srv_janky_result_get_property;
  gobject_class->set_property = t_test_srv_janky_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_SRV_JANKY_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
t_test_srv_janky_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestSrvJankyResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_srv_janky_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestSrvJankyResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_srv_janky_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestSrvJankyResultType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a srv_void_method_args object */
static gint32
t_test_srv_void_method_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestSrvVoidMethodArgs * this_object = T_TEST_SRV_VOID_METHOD_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_srv_void_method_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestSrvVoidMethodArgs * this_object = T_TEST_SRV_VOID_METHOD_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SrvVoidMethodArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_srv_void_method_args_instance_init (TTestSrvVoidMethodArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
t_test_srv_void_method_args_finalize (GObject *object)
{
  TTestSrvVoidMethodArgs *tobject = T_TEST_SRV_VOID_METHOD_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_srv_void_method_args_class_init (TTestSrvVoidMethodArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_srv_void_method_args_read;
  struct_class->write = t_test_srv_void_method_args_write;

  gobject_class->finalize = t_test_srv_void_method_args_finalize;
}

GType
t_test_srv_void_method_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestSrvVoidMethodArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_srv_void_method_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestSrvVoidMethodArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_srv_void_method_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestSrvVoidMethodArgsType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a srv_void_method_result object */
static gint32
t_test_srv_void_method_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestSrvVoidMethodResult * this_object = T_TEST_SRV_VOID_METHOD_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_srv_void_method_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestSrvVoidMethodResult * this_object = T_TEST_SRV_VOID_METHOD_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SrvVoidMethodResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_srv_void_method_result_instance_init (TTestSrvVoidMethodResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
t_test_srv_void_method_result_finalize (GObject *object)
{
  TTestSrvVoidMethodResult *tobject = T_TEST_SRV_VOID_METHOD_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_srv_void_method_result_class_init (TTestSrvVoidMethodResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_srv_void_method_result_read;
  struct_class->write = t_test_srv_void_method_result_write;

  gobject_class->finalize = t_test_srv_void_method_result_finalize;
}

GType
t_test_srv_void_method_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestSrvVoidMethodResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_srv_void_method_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestSrvVoidMethodResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_srv_void_method_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestSrvVoidMethodResultType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a srv_primitive_method_args object */
static gint32
t_test_srv_primitive_method_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestSrvPrimitiveMethodArgs * this_object = T_TEST_SRV_PRIMITIVE_METHOD_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_srv_primitive_method_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestSrvPrimitiveMethodArgs * this_object = T_TEST_SRV_PRIMITIVE_METHOD_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SrvPrimitiveMethodArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_srv_primitive_method_args_instance_init (TTestSrvPrimitiveMethodArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
t_test_srv_primitive_method_args_finalize (GObject *object)
{
  TTestSrvPrimitiveMethodArgs *tobject = T_TEST_SRV_PRIMITIVE_METHOD_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_srv_primitive_method_args_class_init (TTestSrvPrimitiveMethodArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_srv_primitive_method_args_read;
  struct_class->write = t_test_srv_primitive_method_args_write;

  gobject_class->finalize = t_test_srv_primitive_method_args_finalize;
}

GType
t_test_srv_primitive_method_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestSrvPrimitiveMethodArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_srv_primitive_method_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestSrvPrimitiveMethodArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_srv_primitive_method_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestSrvPrimitiveMethodArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestSrvPrimitiveMethodResultProperties
{
  PROP_T_TEST_SRV_PRIMITIVE_METHOD_RESULT_0,
  PROP_T_TEST_SRV_PRIMITIVE_METHOD_RESULT_SUCCESS
};

/* reads a srv_primitive_method_result object */
static gint32
t_test_srv_primitive_method_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestSrvPrimitiveMethodResult * this_object = T_TEST_SRV_PRIMITIVE_METHOD_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_srv_primitive_method_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestSrvPrimitiveMethodResult * this_object = T_TEST_SRV_PRIMITIVE_METHOD_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SrvPrimitiveMethodResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_srv_primitive_method_result_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  TTestSrvPrimitiveMethodResult *self = T_TEST_SRV_PRIMITIVE_METHOD_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_SRV_PRIMITIVE_METHOD_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_srv_primitive_method_result_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  TTestSrvPrimitiveMethodResult *self = T_TEST_SRV_PRIMITIVE_METHOD_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_SRV_PRIMITIVE_METHOD_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_srv_primitive_method_result_instance_init (TTestSrvPrimitiveMethodResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
t_test_srv_primitive_method_result_finalize (GObject *object)
{
  TTestSrvPrimitiveMethodResult *tobject = T_TEST_SRV_PRIMITIVE_METHOD_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_srv_primitive_method_result_class_init (TTestSrvPrimitiveMethodResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_srv_primitive_method_result_read;
  struct_class->write = t_test_srv_primitive_method_result_write;

  gobject_class->finalize = t_test_srv_primitive_method_result_finalize;
  gobject_class->get_property = t_test_srv_primitive_method_result_get_property;
  gobject_class->set_property = t_test_srv_primitive_method_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_SRV_PRIMITIVE_METHOD_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
t_test_srv_primitive_method_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestSrvPrimitiveMethodResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_srv_primitive_method_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestSrvPrimitiveMethodResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_srv_primitive_method_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestSrvPrimitiveMethodResultType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a srv_struct_method_args object */
static gint32
t_test_srv_struct_method_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestSrvStructMethodArgs * this_object = T_TEST_SRV_STRUCT_METHOD_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_srv_struct_method_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestSrvStructMethodArgs * this_object = T_TEST_SRV_STRUCT_METHOD_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SrvStructMethodArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_srv_struct_method_args_instance_init (TTestSrvStructMethodArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
t_test_srv_struct_method_args_finalize (GObject *object)
{
  TTestSrvStructMethodArgs *tobject = T_TEST_SRV_STRUCT_METHOD_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_srv_struct_method_args_class_init (TTestSrvStructMethodArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_srv_struct_method_args_read;
  struct_class->write = t_test_srv_struct_method_args_write;

  gobject_class->finalize = t_test_srv_struct_method_args_finalize;
}

GType
t_test_srv_struct_method_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestSrvStructMethodArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_srv_struct_method_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestSrvStructMethodArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_srv_struct_method_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestSrvStructMethodArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestSrvStructMethodResultProperties
{
  PROP_T_TEST_SRV_STRUCT_METHOD_RESULT_0,
  PROP_T_TEST_SRV_STRUCT_METHOD_RESULT_SUCCESS
};

/* reads a srv_struct_method_result object */
static gint32
t_test_srv_struct_method_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestSrvStructMethodResult * this_object = T_TEST_SRV_STRUCT_METHOD_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_srv_struct_method_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestSrvStructMethodResult * this_object = T_TEST_SRV_STRUCT_METHOD_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SrvStructMethodResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_srv_struct_method_result_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  TTestSrvStructMethodResult *self = T_TEST_SRV_STRUCT_METHOD_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_SRV_STRUCT_METHOD_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_srv_struct_method_result_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  TTestSrvStructMethodResult *self = T_TEST_SRV_STRUCT_METHOD_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_SRV_STRUCT_METHOD_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_srv_struct_method_result_instance_init (TTestSrvStructMethodResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (T_TEST_TYPE_COMPACT_PROTO_TEST_STRUCT, NULL);
  object->__isset_success = FALSE;
}

static void 
t_test_srv_struct_method_result_finalize (GObject *object)
{
  TTestSrvStructMethodResult *tobject = T_TEST_SRV_STRUCT_METHOD_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
t_test_srv_struct_method_result_class_init (TTestSrvStructMethodResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_srv_struct_method_result_read;
  struct_class->write = t_test_srv_struct_method_result_write;

  gobject_class->finalize = t_test_srv_struct_method_result_finalize;
  gobject_class->get_property = t_test_srv_struct_method_result_get_property;
  gobject_class->set_property = t_test_srv_struct_method_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_SRV_STRUCT_METHOD_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         T_TEST_TYPE_COMPACT_PROTO_TEST_STRUCT,
                         G_PARAM_READWRITE));
}

GType
t_test_srv_struct_method_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestSrvStructMethodResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_srv_struct_method_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestSrvStructMethodResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_srv_struct_method_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestSrvStructMethodResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestSrvMethodWithDefaultArgsArgsProperties
{
  PROP_T_TEST_SRV_METHOD_WITH_DEFAULT_ARGS_ARGS_0,
  PROP_T_TEST_SRV_METHOD_WITH_DEFAULT_ARGS_ARGS_SOMETHING
};

/* reads a srv_method_with_default_args_args object */
static gint32
t_test_srv_method_with_default_args_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestSrvMethodWithDefaultArgsArgs * this_object = T_TEST_SRV_METHOD_WITH_DEFAULT_ARGS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->something, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_something = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_srv_method_with_default_args_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestSrvMethodWithDefaultArgsArgs * this_object = T_TEST_SRV_METHOD_WITH_DEFAULT_ARGS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SrvMethodWithDefaultArgsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "something", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->something, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_srv_method_with_default_args_args_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  TTestSrvMethodWithDefaultArgsArgs *self = T_TEST_SRV_METHOD_WITH_DEFAULT_ARGS_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_SRV_METHOD_WITH_DEFAULT_ARGS_ARGS_SOMETHING:
      self->something = g_value_get_int (value);
      self->__isset_something = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_srv_method_with_default_args_args_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  TTestSrvMethodWithDefaultArgsArgs *self = T_TEST_SRV_METHOD_WITH_DEFAULT_ARGS_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_SRV_METHOD_WITH_DEFAULT_ARGS_ARGS_SOMETHING:
      g_value_set_int (value, self->something);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_srv_method_with_default_args_args_instance_init (TTestSrvMethodWithDefaultArgsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->something = 2;
  object->__isset_something = FALSE;
}

static void 
t_test_srv_method_with_default_args_args_finalize (GObject *object)
{
  TTestSrvMethodWithDefaultArgsArgs *tobject = T_TEST_SRV_METHOD_WITH_DEFAULT_ARGS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_srv_method_with_default_args_args_class_init (TTestSrvMethodWithDefaultArgsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_srv_method_with_default_args_args_read;
  struct_class->write = t_test_srv_method_with_default_args_args_write;

  gobject_class->finalize = t_test_srv_method_with_default_args_args_finalize;
  gobject_class->get_property = t_test_srv_method_with_default_args_args_get_property;
  gobject_class->set_property = t_test_srv_method_with_default_args_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_SRV_METHOD_WITH_DEFAULT_ARGS_ARGS_SOMETHING,
     g_param_spec_int ("something",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       2,
                       G_PARAM_READWRITE));
}

GType
t_test_srv_method_with_default_args_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestSrvMethodWithDefaultArgsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_srv_method_with_default_args_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestSrvMethodWithDefaultArgsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_srv_method_with_default_args_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestSrvMethodWithDefaultArgsArgsType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a srv_method_with_default_args_result object */
static gint32
t_test_srv_method_with_default_args_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestSrvMethodWithDefaultArgsResult * this_object = T_TEST_SRV_METHOD_WITH_DEFAULT_ARGS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_srv_method_with_default_args_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestSrvMethodWithDefaultArgsResult * this_object = T_TEST_SRV_METHOD_WITH_DEFAULT_ARGS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SrvMethodWithDefaultArgsResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_srv_method_with_default_args_result_instance_init (TTestSrvMethodWithDefaultArgsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
t_test_srv_method_with_default_args_result_finalize (GObject *object)
{
  TTestSrvMethodWithDefaultArgsResult *tobject = T_TEST_SRV_METHOD_WITH_DEFAULT_ARGS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_srv_method_with_default_args_result_class_init (TTestSrvMethodWithDefaultArgsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_srv_method_with_default_args_result_read;
  struct_class->write = t_test_srv_method_with_default_args_result_write;

  gobject_class->finalize = t_test_srv_method_with_default_args_result_finalize;
}

GType
t_test_srv_method_with_default_args_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestSrvMethodWithDefaultArgsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_srv_method_with_default_args_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestSrvMethodWithDefaultArgsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_srv_method_with_default_args_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestSrvMethodWithDefaultArgsResultType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a srv_oneway_method_args object */
static gint32
t_test_srv_oneway_method_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestSrvOnewayMethodArgs * this_object = T_TEST_SRV_ONEWAY_METHOD_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_srv_oneway_method_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestSrvOnewayMethodArgs * this_object = T_TEST_SRV_ONEWAY_METHOD_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SrvOnewayMethodArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_srv_oneway_method_args_instance_init (TTestSrvOnewayMethodArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
t_test_srv_oneway_method_args_finalize (GObject *object)
{
  TTestSrvOnewayMethodArgs *tobject = T_TEST_SRV_ONEWAY_METHOD_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_srv_oneway_method_args_class_init (TTestSrvOnewayMethodArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_srv_oneway_method_args_read;
  struct_class->write = t_test_srv_oneway_method_args_write;

  gobject_class->finalize = t_test_srv_oneway_method_args_finalize;
}

GType
t_test_srv_oneway_method_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestSrvOnewayMethodArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_srv_oneway_method_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestSrvOnewayMethodArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_srv_oneway_method_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestSrvOnewayMethodArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestInheritedIdentityArgsProperties
{
  PROP_T_TEST_INHERITED_IDENTITY_ARGS_0,
  PROP_T_TEST_INHERITED_IDENTITY_ARGS_ARG
};

/* reads a inherited_identity_args object */
static gint32
t_test_inherited_identity_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestInheritedIdentityArgs * this_object = T_TEST_INHERITED_IDENTITY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->arg, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_arg = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_inherited_identity_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestInheritedIdentityArgs * this_object = T_TEST_INHERITED_IDENTITY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "InheritedIdentityArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "arg", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->arg, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_inherited_identity_args_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  TTestInheritedIdentityArgs *self = T_TEST_INHERITED_IDENTITY_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_INHERITED_IDENTITY_ARGS_ARG:
      self->arg = g_value_get_int (value);
      self->__isset_arg = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_inherited_identity_args_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  TTestInheritedIdentityArgs *self = T_TEST_INHERITED_IDENTITY_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_INHERITED_IDENTITY_ARGS_ARG:
      g_value_set_int (value, self->arg);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_inherited_identity_args_instance_init (TTestInheritedIdentityArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->arg = 0;
  object->__isset_arg = FALSE;
}

static void 
t_test_inherited_identity_args_finalize (GObject *object)
{
  TTestInheritedIdentityArgs *tobject = T_TEST_INHERITED_IDENTITY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_inherited_identity_args_class_init (TTestInheritedIdentityArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_inherited_identity_args_read;
  struct_class->write = t_test_inherited_identity_args_write;

  gobject_class->finalize = t_test_inherited_identity_args_finalize;
  gobject_class->get_property = t_test_inherited_identity_args_get_property;
  gobject_class->set_property = t_test_inherited_identity_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_INHERITED_IDENTITY_ARGS_ARG,
     g_param_spec_int ("arg",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
t_test_inherited_identity_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestInheritedIdentityArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_inherited_identity_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestInheritedIdentityArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_inherited_identity_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestInheritedIdentityArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestInheritedIdentityResultProperties
{
  PROP_T_TEST_INHERITED_IDENTITY_RESULT_0,
  PROP_T_TEST_INHERITED_IDENTITY_RESULT_SUCCESS
};

/* reads a inherited_identity_result object */
static gint32
t_test_inherited_identity_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestInheritedIdentityResult * this_object = T_TEST_INHERITED_IDENTITY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_inherited_identity_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestInheritedIdentityResult * this_object = T_TEST_INHERITED_IDENTITY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "InheritedIdentityResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_inherited_identity_result_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  TTestInheritedIdentityResult *self = T_TEST_INHERITED_IDENTITY_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_INHERITED_IDENTITY_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_inherited_identity_result_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  TTestInheritedIdentityResult *self = T_TEST_INHERITED_IDENTITY_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_INHERITED_IDENTITY_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_inherited_identity_result_instance_init (TTestInheritedIdentityResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
t_test_inherited_identity_result_finalize (GObject *object)
{
  TTestInheritedIdentityResult *tobject = T_TEST_INHERITED_IDENTITY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_inherited_identity_result_class_init (TTestInheritedIdentityResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_inherited_identity_result_read;
  struct_class->write = t_test_inherited_identity_result_write;

  gobject_class->finalize = t_test_inherited_identity_result_finalize;
  gobject_class->get_property = t_test_inherited_identity_result_get_property;
  gobject_class->set_property = t_test_inherited_identity_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_INHERITED_IDENTITY_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
t_test_inherited_identity_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestInheritedIdentityResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_inherited_identity_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestInheritedIdentityResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_inherited_identity_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestInheritedIdentityResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestReverseOrderServiceMyMethodArgsProperties
{
  PROP_T_TEST_REVERSE_ORDER_SERVICE_MY_METHOD_ARGS_0,
  PROP_T_TEST_REVERSE_ORDER_SERVICE_MY_METHOD_ARGS_FIRST,
  PROP_T_TEST_REVERSE_ORDER_SERVICE_MY_METHOD_ARGS_SECOND,
  PROP_T_TEST_REVERSE_ORDER_SERVICE_MY_METHOD_ARGS_THIRD,
  PROP_T_TEST_REVERSE_ORDER_SERVICE_MY_METHOD_ARGS_FOURTH
};

/* reads a reverse_order_service_my_method_args object */
static gint32
t_test_reverse_order_service_my_method_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestReverseOrderServiceMyMethodArgs * this_object = T_TEST_REVERSE_ORDER_SERVICE_MY_METHOD_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->first != NULL)
          {
            g_free(this_object->first);
            this_object->first = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->first, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_first = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->second, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_second = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->third, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_third = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->fourth, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_fourth = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_reverse_order_service_my_method_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestReverseOrderServiceMyMethodArgs * this_object = T_TEST_REVERSE_ORDER_SERVICE_MY_METHOD_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ReverseOrderServiceMyMethodArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "first", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->first, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "second", T_I16, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->second, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "third", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->third, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "fourth", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->fourth, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_reverse_order_service_my_method_args_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  TTestReverseOrderServiceMyMethodArgs *self = T_TEST_REVERSE_ORDER_SERVICE_MY_METHOD_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_REVERSE_ORDER_SERVICE_MY_METHOD_ARGS_FIRST:
      if (self->first != NULL)
        g_free (self->first);
      self->first = g_value_dup_string (value);
      self->__isset_first = TRUE;
      break;

    case PROP_T_TEST_REVERSE_ORDER_SERVICE_MY_METHOD_ARGS_SECOND:
      self->second = g_value_get_int (value);
      self->__isset_second = TRUE;
      break;

    case PROP_T_TEST_REVERSE_ORDER_SERVICE_MY_METHOD_ARGS_THIRD:
      self->third = g_value_get_int (value);
      self->__isset_third = TRUE;
      break;

    case PROP_T_TEST_REVERSE_ORDER_SERVICE_MY_METHOD_ARGS_FOURTH:
      self->fourth = g_value_get_int64 (value);
      self->__isset_fourth = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_reverse_order_service_my_method_args_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  TTestReverseOrderServiceMyMethodArgs *self = T_TEST_REVERSE_ORDER_SERVICE_MY_METHOD_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_REVERSE_ORDER_SERVICE_MY_METHOD_ARGS_FIRST:
      g_value_set_string (value, self->first);
      break;

    case PROP_T_TEST_REVERSE_ORDER_SERVICE_MY_METHOD_ARGS_SECOND:
      g_value_set_int (value, self->second);
      break;

    case PROP_T_TEST_REVERSE_ORDER_SERVICE_MY_METHOD_ARGS_THIRD:
      g_value_set_int (value, self->third);
      break;

    case PROP_T_TEST_REVERSE_ORDER_SERVICE_MY_METHOD_ARGS_FOURTH:
      g_value_set_int64 (value, self->fourth);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_reverse_order_service_my_method_args_instance_init (TTestReverseOrderServiceMyMethodArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->first = NULL;
  object->__isset_first = FALSE;
  object->second = 0;
  object->__isset_second = FALSE;
  object->third = 0;
  object->__isset_third = FALSE;
  object->fourth = 0;
  object->__isset_fourth = FALSE;
}

static void 
t_test_reverse_order_service_my_method_args_finalize (GObject *object)
{
  TTestReverseOrderServiceMyMethodArgs *tobject = T_TEST_REVERSE_ORDER_SERVICE_MY_METHOD_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->first != NULL)
  {
    g_free(tobject->first);
    tobject->first = NULL;
  }
}

static void
t_test_reverse_order_service_my_method_args_class_init (TTestReverseOrderServiceMyMethodArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_reverse_order_service_my_method_args_read;
  struct_class->write = t_test_reverse_order_service_my_method_args_write;

  gobject_class->finalize = t_test_reverse_order_service_my_method_args_finalize;
  gobject_class->get_property = t_test_reverse_order_service_my_method_args_get_property;
  gobject_class->set_property = t_test_reverse_order_service_my_method_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_REVERSE_ORDER_SERVICE_MY_METHOD_ARGS_FIRST,
     g_param_spec_string ("first",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_REVERSE_ORDER_SERVICE_MY_METHOD_ARGS_SECOND,
     g_param_spec_int ("second",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_REVERSE_ORDER_SERVICE_MY_METHOD_ARGS_THIRD,
     g_param_spec_int ("third",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_REVERSE_ORDER_SERVICE_MY_METHOD_ARGS_FOURTH,
     g_param_spec_int64 ("fourth",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
t_test_reverse_order_service_my_method_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestReverseOrderServiceMyMethodArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_reverse_order_service_my_method_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestReverseOrderServiceMyMethodArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_reverse_order_service_my_method_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestReverseOrderServiceMyMethodArgsType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a reverse_order_service_my_method_result object */
static gint32
t_test_reverse_order_service_my_method_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestReverseOrderServiceMyMethodResult * this_object = T_TEST_REVERSE_ORDER_SERVICE_MY_METHOD_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_reverse_order_service_my_method_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestReverseOrderServiceMyMethodResult * this_object = T_TEST_REVERSE_ORDER_SERVICE_MY_METHOD_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ReverseOrderServiceMyMethodResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_reverse_order_service_my_method_result_instance_init (TTestReverseOrderServiceMyMethodResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
t_test_reverse_order_service_my_method_result_finalize (GObject *object)
{
  TTestReverseOrderServiceMyMethodResult *tobject = T_TEST_REVERSE_ORDER_SERVICE_MY_METHOD_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_reverse_order_service_my_method_result_class_init (TTestReverseOrderServiceMyMethodResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_reverse_order_service_my_method_result_read;
  struct_class->write = t_test_reverse_order_service_my_method_result_write;

  gobject_class->finalize = t_test_reverse_order_service_my_method_result_finalize;
}

GType
t_test_reverse_order_service_my_method_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestReverseOrderServiceMyMethodResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_reverse_order_service_my_method_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestReverseOrderServiceMyMethodResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_reverse_order_service_my_method_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestReverseOrderServiceMyMethodResultType",
                                   &type_info, 0);
  }

  return type;
}

