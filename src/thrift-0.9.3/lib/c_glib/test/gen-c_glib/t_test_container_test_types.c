/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "t_test_container_test_types.h"
#include <thrift/c_glib/thrift.h>

enum _TTestContainersWithDefaultValuesProperties
{
  PROP_T_TEST_CONTAINERS_WITH_DEFAULT_VALUES_0,
  PROP_T_TEST_CONTAINERS_WITH_DEFAULT_VALUES_STRING_LIST
};

/* reads a containers_with_default_values object */
static gint32
t_test_containers_with_default_values_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestContainersWithDefaultValues * this_object = T_TEST_CONTAINERS_WITH_DEFAULT_VALUES(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem0 = NULL;
              if (_elem0 != NULL)
              {
                g_free(_elem0);
                _elem0 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem0, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->StringList, _elem0);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_StringList = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_containers_with_default_values_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestContainersWithDefaultValues * this_object = T_TEST_CONTAINERS_WITH_DEFAULT_VALUES(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ContainersWithDefaultValues", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "StringList", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i1;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) this_object->StringList->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i1 = 0; i1 < this_object->StringList->len; i1++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->StringList, i1)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_containers_with_default_values_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  TTestContainersWithDefaultValues *self = T_TEST_CONTAINERS_WITH_DEFAULT_VALUES (object);

  switch (property_id)
  {
    case PROP_T_TEST_CONTAINERS_WITH_DEFAULT_VALUES_STRING_LIST:
      if (self->StringList != NULL)
        g_ptr_array_unref (self->StringList);
      self->StringList = g_value_dup_boxed (value);
      self->__isset_StringList = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_containers_with_default_values_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  TTestContainersWithDefaultValues *self = T_TEST_CONTAINERS_WITH_DEFAULT_VALUES (object);

  switch (property_id)
  {
    case PROP_T_TEST_CONTAINERS_WITH_DEFAULT_VALUES_STRING_LIST:
      g_value_set_boxed (value, self->StringList);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_containers_with_default_values_instance_init (TTestContainersWithDefaultValues * object)
{
  static const gchar * __default_StringList[2] = 
    { "Apache", "Thrift" };
  unsigned int list_index;

  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->StringList = g_ptr_array_new_with_free_func (g_free);
  for (list_index = 0; list_index < 2; list_index += 1)
    g_ptr_array_add (object->StringList,
                     g_strdup (__default_StringList[list_index]));
  object->__isset_StringList = FALSE;
}

static void 
t_test_containers_with_default_values_finalize (GObject *object)
{
  TTestContainersWithDefaultValues *tobject = T_TEST_CONTAINERS_WITH_DEFAULT_VALUES (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->StringList != NULL)
  {
    g_ptr_array_unref (tobject->StringList);
    tobject->StringList = NULL;
  }
}

static void
t_test_containers_with_default_values_class_init (TTestContainersWithDefaultValuesClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_containers_with_default_values_read;
  struct_class->write = t_test_containers_with_default_values_write;

  gobject_class->finalize = t_test_containers_with_default_values_finalize;
  gobject_class->get_property = t_test_containers_with_default_values_get_property;
  gobject_class->set_property = t_test_containers_with_default_values_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_CONTAINERS_WITH_DEFAULT_VALUES_STRING_LIST,
     g_param_spec_boxed ("StringList",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_test_containers_with_default_values_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestContainersWithDefaultValuesClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_containers_with_default_values_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestContainersWithDefaultValues),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_containers_with_default_values_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestContainersWithDefaultValuesType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */

enum _TTestContainerServiceReceiveStringListArgsProperties
{
  PROP_T_TEST_CONTAINER_SERVICE_RECEIVE_STRING_LIST_ARGS_0,
  PROP_T_TEST_CONTAINER_SERVICE_RECEIVE_STRING_LIST_ARGS_STRING_LIST
};

/* reads a container_service_receive_string_list_args object */
static gint32
t_test_container_service_receive_string_list_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestContainerServiceReceiveStringListArgs * this_object = T_TEST_CONTAINER_SERVICE_RECEIVE_STRING_LIST_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem2 = NULL;
              if (_elem2 != NULL)
              {
                g_free(_elem2);
                _elem2 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem2, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->stringList, _elem2);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_stringList = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_container_service_receive_string_list_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestContainerServiceReceiveStringListArgs * this_object = T_TEST_CONTAINER_SERVICE_RECEIVE_STRING_LIST_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ContainerServiceReceiveStringListArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "stringList", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i3;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) this_object->stringList->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i3 = 0; i3 < this_object->stringList->len; i3++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->stringList, i3)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_container_service_receive_string_list_args_set_property (GObject *object,
                                                                guint property_id,
                                                                const GValue *value,
                                                                GParamSpec *pspec)
{
  TTestContainerServiceReceiveStringListArgs *self = T_TEST_CONTAINER_SERVICE_RECEIVE_STRING_LIST_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_CONTAINER_SERVICE_RECEIVE_STRING_LIST_ARGS_STRING_LIST:
      if (self->stringList != NULL)
        g_ptr_array_unref (self->stringList);
      self->stringList = g_value_dup_boxed (value);
      self->__isset_stringList = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_container_service_receive_string_list_args_get_property (GObject *object,
                                                                guint property_id,
                                                                GValue *value,
                                                                GParamSpec *pspec)
{
  TTestContainerServiceReceiveStringListArgs *self = T_TEST_CONTAINER_SERVICE_RECEIVE_STRING_LIST_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_CONTAINER_SERVICE_RECEIVE_STRING_LIST_ARGS_STRING_LIST:
      g_value_set_boxed (value, self->stringList);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_container_service_receive_string_list_args_instance_init (TTestContainerServiceReceiveStringListArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->stringList = g_ptr_array_new_with_free_func (g_free);
  object->__isset_stringList = FALSE;
}

static void 
t_test_container_service_receive_string_list_args_finalize (GObject *object)
{
  TTestContainerServiceReceiveStringListArgs *tobject = T_TEST_CONTAINER_SERVICE_RECEIVE_STRING_LIST_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->stringList != NULL)
  {
    g_ptr_array_unref (tobject->stringList);
    tobject->stringList = NULL;
  }
}

static void
t_test_container_service_receive_string_list_args_class_init (TTestContainerServiceReceiveStringListArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_container_service_receive_string_list_args_read;
  struct_class->write = t_test_container_service_receive_string_list_args_write;

  gobject_class->finalize = t_test_container_service_receive_string_list_args_finalize;
  gobject_class->get_property = t_test_container_service_receive_string_list_args_get_property;
  gobject_class->set_property = t_test_container_service_receive_string_list_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_CONTAINER_SERVICE_RECEIVE_STRING_LIST_ARGS_STRING_LIST,
     g_param_spec_boxed ("stringList",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_test_container_service_receive_string_list_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestContainerServiceReceiveStringListArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_container_service_receive_string_list_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestContainerServiceReceiveStringListArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_container_service_receive_string_list_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestContainerServiceReceiveStringListArgsType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a container_service_receive_string_list_result object */
static gint32
t_test_container_service_receive_string_list_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestContainerServiceReceiveStringListResult * this_object = T_TEST_CONTAINER_SERVICE_RECEIVE_STRING_LIST_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_container_service_receive_string_list_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestContainerServiceReceiveStringListResult * this_object = T_TEST_CONTAINER_SERVICE_RECEIVE_STRING_LIST_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ContainerServiceReceiveStringListResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_container_service_receive_string_list_result_instance_init (TTestContainerServiceReceiveStringListResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
t_test_container_service_receive_string_list_result_finalize (GObject *object)
{
  TTestContainerServiceReceiveStringListResult *tobject = T_TEST_CONTAINER_SERVICE_RECEIVE_STRING_LIST_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_container_service_receive_string_list_result_class_init (TTestContainerServiceReceiveStringListResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_container_service_receive_string_list_result_read;
  struct_class->write = t_test_container_service_receive_string_list_result_write;

  gobject_class->finalize = t_test_container_service_receive_string_list_result_finalize;
}

GType
t_test_container_service_receive_string_list_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestContainerServiceReceiveStringListResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_container_service_receive_string_list_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestContainerServiceReceiveStringListResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_container_service_receive_string_list_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestContainerServiceReceiveStringListResultType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a container_service_return_string_list_args object */
static gint32
t_test_container_service_return_string_list_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestContainerServiceReturnStringListArgs * this_object = T_TEST_CONTAINER_SERVICE_RETURN_STRING_LIST_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_container_service_return_string_list_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestContainerServiceReturnStringListArgs * this_object = T_TEST_CONTAINER_SERVICE_RETURN_STRING_LIST_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ContainerServiceReturnStringListArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_container_service_return_string_list_args_instance_init (TTestContainerServiceReturnStringListArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
t_test_container_service_return_string_list_args_finalize (GObject *object)
{
  TTestContainerServiceReturnStringListArgs *tobject = T_TEST_CONTAINER_SERVICE_RETURN_STRING_LIST_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_container_service_return_string_list_args_class_init (TTestContainerServiceReturnStringListArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_container_service_return_string_list_args_read;
  struct_class->write = t_test_container_service_return_string_list_args_write;

  gobject_class->finalize = t_test_container_service_return_string_list_args_finalize;
}

GType
t_test_container_service_return_string_list_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestContainerServiceReturnStringListArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_container_service_return_string_list_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestContainerServiceReturnStringListArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_container_service_return_string_list_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestContainerServiceReturnStringListArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestContainerServiceReturnStringListResultProperties
{
  PROP_T_TEST_CONTAINER_SERVICE_RETURN_STRING_LIST_RESULT_0,
  PROP_T_TEST_CONTAINER_SERVICE_RETURN_STRING_LIST_RESULT_SUCCESS
};

/* reads a container_service_return_string_list_result object */
static gint32
t_test_container_service_return_string_list_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestContainerServiceReturnStringListResult * this_object = T_TEST_CONTAINER_SERVICE_RETURN_STRING_LIST_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem4 = NULL;
              if (_elem4 != NULL)
              {
                g_free(_elem4);
                _elem4 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem4, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem4);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_container_service_return_string_list_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestContainerServiceReturnStringListResult * this_object = T_TEST_CONTAINER_SERVICE_RETURN_STRING_LIST_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ContainerServiceReturnStringListResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i5;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) this_object->success->len, error)) < 0)
        return -1;
      xfer += ret;
      for (i5 = 0; i5 < this_object->success->len; i5++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->success, i5)), error)) < 0)
          return -1;
      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_container_service_return_string_list_result_set_property (GObject *object,
                                                                 guint property_id,
                                                                 const GValue *value,
                                                                 GParamSpec *pspec)
{
  TTestContainerServiceReturnStringListResult *self = T_TEST_CONTAINER_SERVICE_RETURN_STRING_LIST_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_CONTAINER_SERVICE_RETURN_STRING_LIST_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_container_service_return_string_list_result_get_property (GObject *object,
                                                                 guint property_id,
                                                                 GValue *value,
                                                                 GParamSpec *pspec)
{
  TTestContainerServiceReturnStringListResult *self = T_TEST_CONTAINER_SERVICE_RETURN_STRING_LIST_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_CONTAINER_SERVICE_RETURN_STRING_LIST_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_container_service_return_string_list_result_instance_init (TTestContainerServiceReturnStringListResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_free);
  object->__isset_success = FALSE;
}

static void 
t_test_container_service_return_string_list_result_finalize (GObject *object)
{
  TTestContainerServiceReturnStringListResult *tobject = T_TEST_CONTAINER_SERVICE_RETURN_STRING_LIST_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
}

static void
t_test_container_service_return_string_list_result_class_init (TTestContainerServiceReturnStringListResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_container_service_return_string_list_result_read;
  struct_class->write = t_test_container_service_return_string_list_result_write;

  gobject_class->finalize = t_test_container_service_return_string_list_result_finalize;
  gobject_class->get_property = t_test_container_service_return_string_list_result_get_property;
  gobject_class->set_property = t_test_container_service_return_string_list_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_CONTAINER_SERVICE_RETURN_STRING_LIST_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_test_container_service_return_string_list_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestContainerServiceReturnStringListResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_container_service_return_string_list_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestContainerServiceReturnStringListResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_container_service_return_string_list_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestContainerServiceReturnStringListResultType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a container_service_return_list_string_list_args object */
static gint32
t_test_container_service_return_list_string_list_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestContainerServiceReturnListStringListArgs * this_object = T_TEST_CONTAINER_SERVICE_RETURN_LIST_STRING_LIST_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_container_service_return_list_string_list_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestContainerServiceReturnListStringListArgs * this_object = T_TEST_CONTAINER_SERVICE_RETURN_LIST_STRING_LIST_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ContainerServiceReturnListStringListArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_container_service_return_list_string_list_args_instance_init (TTestContainerServiceReturnListStringListArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
t_test_container_service_return_list_string_list_args_finalize (GObject *object)
{
  TTestContainerServiceReturnListStringListArgs *tobject = T_TEST_CONTAINER_SERVICE_RETURN_LIST_STRING_LIST_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_container_service_return_list_string_list_args_class_init (TTestContainerServiceReturnListStringListArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_container_service_return_list_string_list_args_read;
  struct_class->write = t_test_container_service_return_list_string_list_args_write;

  gobject_class->finalize = t_test_container_service_return_list_string_list_args_finalize;
}

GType
t_test_container_service_return_list_string_list_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestContainerServiceReturnListStringListArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_container_service_return_list_string_list_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestContainerServiceReturnListStringListArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_container_service_return_list_string_list_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestContainerServiceReturnListStringListArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestContainerServiceReturnListStringListResultProperties
{
  PROP_T_TEST_CONTAINER_SERVICE_RETURN_LIST_STRING_LIST_RESULT_0,
  PROP_T_TEST_CONTAINER_SERVICE_RETURN_LIST_STRING_LIST_RESULT_SUCCESS
};

/* reads a container_service_return_list_string_list_result object */
static gint32
t_test_container_service_return_list_string_list_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestContainerServiceReturnListStringListResult * this_object = T_TEST_CONTAINER_SERVICE_RETURN_LIST_STRING_LIST_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GPtrArray * _elem6 = g_ptr_array_new_with_free_func (g_free);
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                for (i = 0; i < size; i++)
                {
                  gchar * _elem7 = NULL;
                  if (_elem7 != NULL)
                  {
                    g_free(_elem7);
                    _elem7 = NULL;
                  }

                  if ((ret = thrift_protocol_read_string (protocol, &_elem7, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_ptr_array_add (_elem6, _elem7);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              g_ptr_array_add (this_object->success, _elem6);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_container_service_return_list_string_list_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestContainerServiceReturnListStringListResult * this_object = T_TEST_CONTAINER_SERVICE_RETURN_LIST_STRING_LIST_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ContainerServiceReturnListStringListResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i8;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_LIST, (gint32) this_object->success->len, error)) < 0)
        return -1;
      xfer += ret;
      for (i8 = 0; i8 < this_object->success->len; i8++)
      {
        {
          guint i9;

          if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->success, i8))->len, error)) < 0)
            return -1;
          xfer += ret;
          for (i9 = 0; i9 < ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->success, i8))->len; i9++)
          {
            if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->success, i8)), i9)), error)) < 0)
              return -1;
          }
          if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
            return -1;
          xfer += ret;
        }
      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_container_service_return_list_string_list_result_set_property (GObject *object,
                                                                      guint property_id,
                                                                      const GValue *value,
                                                                      GParamSpec *pspec)
{
  TTestContainerServiceReturnListStringListResult *self = T_TEST_CONTAINER_SERVICE_RETURN_LIST_STRING_LIST_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_CONTAINER_SERVICE_RETURN_LIST_STRING_LIST_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_container_service_return_list_string_list_result_get_property (GObject *object,
                                                                      guint property_id,
                                                                      GValue *value,
                                                                      GParamSpec *pspec)
{
  TTestContainerServiceReturnListStringListResult *self = T_TEST_CONTAINER_SERVICE_RETURN_LIST_STRING_LIST_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_CONTAINER_SERVICE_RETURN_LIST_STRING_LIST_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_container_service_return_list_string_list_result_instance_init (TTestContainerServiceReturnListStringListResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func ((GDestroyNotify) g_ptr_array_unref);
  object->__isset_success = FALSE;
}

static void 
t_test_container_service_return_list_string_list_result_finalize (GObject *object)
{
  TTestContainerServiceReturnListStringListResult *tobject = T_TEST_CONTAINER_SERVICE_RETURN_LIST_STRING_LIST_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
}

static void
t_test_container_service_return_list_string_list_result_class_init (TTestContainerServiceReturnListStringListResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_container_service_return_list_string_list_result_read;
  struct_class->write = t_test_container_service_return_list_string_list_result_write;

  gobject_class->finalize = t_test_container_service_return_list_string_list_result_finalize;
  gobject_class->get_property = t_test_container_service_return_list_string_list_result_get_property;
  gobject_class->set_property = t_test_container_service_return_list_string_list_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_CONTAINER_SERVICE_RETURN_LIST_STRING_LIST_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_test_container_service_return_list_string_list_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestContainerServiceReturnListStringListResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_container_service_return_list_string_list_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestContainerServiceReturnListStringListResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_container_service_return_list_string_list_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestContainerServiceReturnListStringListResultType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a container_service_return_typedefd_list_string_list_args object */
static gint32
t_test_container_service_return_typedefd_list_string_list_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestContainerServiceReturnTypedefdListStringListArgs * this_object = T_TEST_CONTAINER_SERVICE_RETURN_TYPEDEFD_LIST_STRING_LIST_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_container_service_return_typedefd_list_string_list_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestContainerServiceReturnTypedefdListStringListArgs * this_object = T_TEST_CONTAINER_SERVICE_RETURN_TYPEDEFD_LIST_STRING_LIST_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ContainerServiceReturnTypedefdListStringListArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_container_service_return_typedefd_list_string_list_args_instance_init (TTestContainerServiceReturnTypedefdListStringListArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
t_test_container_service_return_typedefd_list_string_list_args_finalize (GObject *object)
{
  TTestContainerServiceReturnTypedefdListStringListArgs *tobject = T_TEST_CONTAINER_SERVICE_RETURN_TYPEDEFD_LIST_STRING_LIST_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_container_service_return_typedefd_list_string_list_args_class_init (TTestContainerServiceReturnTypedefdListStringListArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_container_service_return_typedefd_list_string_list_args_read;
  struct_class->write = t_test_container_service_return_typedefd_list_string_list_args_write;

  gobject_class->finalize = t_test_container_service_return_typedefd_list_string_list_args_finalize;
}

GType
t_test_container_service_return_typedefd_list_string_list_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestContainerServiceReturnTypedefdListStringListArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_container_service_return_typedefd_list_string_list_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestContainerServiceReturnTypedefdListStringListArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_container_service_return_typedefd_list_string_list_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestContainerServiceReturnTypedefdListStringListArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestContainerServiceReturnTypedefdListStringListResultProperties
{
  PROP_T_TEST_CONTAINER_SERVICE_RETURN_TYPEDEFD_LIST_STRING_LIST_RESULT_0,
  PROP_T_TEST_CONTAINER_SERVICE_RETURN_TYPEDEFD_LIST_STRING_LIST_RESULT_SUCCESS
};

/* reads a container_service_return_typedefd_list_string_list_result object */
static gint32
t_test_container_service_return_typedefd_list_string_list_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestContainerServiceReturnTypedefdListStringListResult * this_object = T_TEST_CONTAINER_SERVICE_RETURN_TYPEDEFD_LIST_STRING_LIST_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TTestStringList * _elem10 = g_ptr_array_new_with_free_func (g_free);
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                for (i = 0; i < size; i++)
                {
                  gchar * _elem11 = NULL;
                  if (_elem11 != NULL)
                  {
                    g_free(_elem11);
                    _elem11 = NULL;
                  }

                  if ((ret = thrift_protocol_read_string (protocol, &_elem11, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_ptr_array_add (_elem10, _elem11);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              g_ptr_array_add (this_object->success, _elem10);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_container_service_return_typedefd_list_string_list_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestContainerServiceReturnTypedefdListStringListResult * this_object = T_TEST_CONTAINER_SERVICE_RETURN_TYPEDEFD_LIST_STRING_LIST_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ContainerServiceReturnTypedefdListStringListResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i12;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_LIST, (gint32) this_object->success->len, error)) < 0)
        return -1;
      xfer += ret;
      for (i12 = 0; i12 < this_object->success->len; i12++)
      {
        {
          guint i13;

          if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->success, i12))->len, error)) < 0)
            return -1;
          xfer += ret;
          for (i13 = 0; i13 < ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->success, i12))->len; i13++)
          {
            if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->success, i12)), i13)), error)) < 0)
              return -1;
          }
          if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
            return -1;
          xfer += ret;
        }
      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_container_service_return_typedefd_list_string_list_result_set_property (GObject *object,
                                                                               guint property_id,
                                                                               const GValue *value,
                                                                               GParamSpec *pspec)
{
  TTestContainerServiceReturnTypedefdListStringListResult *self = T_TEST_CONTAINER_SERVICE_RETURN_TYPEDEFD_LIST_STRING_LIST_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_CONTAINER_SERVICE_RETURN_TYPEDEFD_LIST_STRING_LIST_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_container_service_return_typedefd_list_string_list_result_get_property (GObject *object,
                                                                               guint property_id,
                                                                               GValue *value,
                                                                               GParamSpec *pspec)
{
  TTestContainerServiceReturnTypedefdListStringListResult *self = T_TEST_CONTAINER_SERVICE_RETURN_TYPEDEFD_LIST_STRING_LIST_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_CONTAINER_SERVICE_RETURN_TYPEDEFD_LIST_STRING_LIST_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_container_service_return_typedefd_list_string_list_result_instance_init (TTestContainerServiceReturnTypedefdListStringListResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func ((GDestroyNotify) g_ptr_array_unref);
  object->__isset_success = FALSE;
}

static void 
t_test_container_service_return_typedefd_list_string_list_result_finalize (GObject *object)
{
  TTestContainerServiceReturnTypedefdListStringListResult *tobject = T_TEST_CONTAINER_SERVICE_RETURN_TYPEDEFD_LIST_STRING_LIST_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
}

static void
t_test_container_service_return_typedefd_list_string_list_result_class_init (TTestContainerServiceReturnTypedefdListStringListResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_container_service_return_typedefd_list_string_list_result_read;
  struct_class->write = t_test_container_service_return_typedefd_list_string_list_result_write;

  gobject_class->finalize = t_test_container_service_return_typedefd_list_string_list_result_finalize;
  gobject_class->get_property = t_test_container_service_return_typedefd_list_string_list_result_get_property;
  gobject_class->set_property = t_test_container_service_return_typedefd_list_string_list_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_CONTAINER_SERVICE_RETURN_TYPEDEFD_LIST_STRING_LIST_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_test_container_service_return_typedefd_list_string_list_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestContainerServiceReturnTypedefdListStringListResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_container_service_return_typedefd_list_string_list_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestContainerServiceReturnTypedefdListStringListResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_container_service_return_typedefd_list_string_list_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestContainerServiceReturnTypedefdListStringListResultType",
                                   &type_info, 0);
  }

  return type;
}

