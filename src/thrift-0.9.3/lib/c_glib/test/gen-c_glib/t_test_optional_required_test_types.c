/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "t_test_optional_required_test_types.h"
#include <thrift/c_glib/thrift.h>

enum _TTestOldSchoolProperties
{
  PROP_T_TEST_OLD_SCHOOL_0,
  PROP_T_TEST_OLD_SCHOOL_IM_INT,
  PROP_T_TEST_OLD_SCHOOL_IM_STR,
  PROP_T_TEST_OLD_SCHOOL_IM_BIG
};

/* reads a old_school object */
static gint32
t_test_old_school_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestOldSchool * this_object = T_TEST_OLD_SCHOOL(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->im_int, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_im_int = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->im_str != NULL)
          {
            g_free(this_object->im_str);
            this_object->im_str = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->im_str, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_im_str = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GHashTable * _elem0 = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_free);
              {
                guint32 size;
                guint32 i;
                ThriftType key_type;
                ThriftType value_type;

                /* read the map begin marker */
                if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through each of the map's fields */
                for (i = 0; i < size; i++)
                {
                  gint32* key1 = g_new (gint32, 1);
                  gchar * val2 = NULL;
                  if ((ret = thrift_protocol_read_i32 (protocol, &*key1, error)) < 0)
                    return -1;
                  xfer += ret;
                  if (val2 != NULL)
                  {
                    g_free(val2);
                    val2 = NULL;
                  }

                  if ((ret = thrift_protocol_read_string (protocol, &val2, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_hash_table_insert ((GHashTable *)_elem0, (gpointer) key1, (gpointer) val2);
                }

                /* read the map end marker */
                if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              g_ptr_array_add (this_object->im_big, _elem0);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_im_big = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_old_school_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestOldSchool * this_object = T_TEST_OLD_SCHOOL(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "OldSchool", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "im_int", T_I16, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->im_int, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "im_str", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->im_str, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "im_big", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i3;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_MAP, (gint32) this_object->im_big->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i3 = 0; i3 < this_object->im_big->len; i3++)
    {
      {
        gint32* key4 = g_new (gint32, 1);
        gchar * val5 = NULL;
        GList *key_list = NULL, *iter = NULL;
        gint32** keys;
        int i = 0, key_count;

        if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_STRING, (gint32) g_hash_table_size ((GHashTable *) ((GHashTable*)g_ptr_array_index ((GPtrArray *) this_object->im_big, i3))), error)) < 0)
          return -1;
        xfer += ret;
        g_hash_table_foreach ((GHashTable *) ((GHashTable*)g_ptr_array_index ((GPtrArray *) this_object->im_big, i3)), thrift_hash_table_get_keys, &key_list);
        key_count = g_list_length (key_list);
        keys = g_newa (gint32*, key_count);
        for (iter = g_list_first (key_list); iter; iter = iter->next)
          keys[i++] = (gint32*) iter->data;
        g_list_free (key_list);

        for (i = 0; i < key_count; ++i)
        {
          key4 = keys[i];
          val5 = (gchar *) g_hash_table_lookup (((GHashTable *) ((GHashTable*)g_ptr_array_index ((GPtrArray *) this_object->im_big, i3))), (gpointer) key4);

          if ((ret = thrift_protocol_write_i32 (protocol, * key4, error)) < 0)
            return -1;
          if ((ret = thrift_protocol_write_string (protocol,  val5, error)) < 0)
            return -1;
        }
        if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_old_school_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  TTestOldSchool *self = T_TEST_OLD_SCHOOL (object);

  switch (property_id)
  {
    case PROP_T_TEST_OLD_SCHOOL_IM_INT:
      self->im_int = g_value_get_int (value);
      self->__isset_im_int = TRUE;
      break;

    case PROP_T_TEST_OLD_SCHOOL_IM_STR:
      if (self->im_str != NULL)
        g_free (self->im_str);
      self->im_str = g_value_dup_string (value);
      self->__isset_im_str = TRUE;
      break;

    case PROP_T_TEST_OLD_SCHOOL_IM_BIG:
      if (self->im_big != NULL)
        g_ptr_array_unref (self->im_big);
      self->im_big = g_value_dup_boxed (value);
      self->__isset_im_big = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_old_school_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  TTestOldSchool *self = T_TEST_OLD_SCHOOL (object);

  switch (property_id)
  {
    case PROP_T_TEST_OLD_SCHOOL_IM_INT:
      g_value_set_int (value, self->im_int);
      break;

    case PROP_T_TEST_OLD_SCHOOL_IM_STR:
      g_value_set_string (value, self->im_str);
      break;

    case PROP_T_TEST_OLD_SCHOOL_IM_BIG:
      g_value_set_boxed (value, self->im_big);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_old_school_instance_init (TTestOldSchool * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->im_int = 0;
  object->__isset_im_int = FALSE;
  object->im_str = NULL;
  object->__isset_im_str = FALSE;
  object->im_big = g_ptr_array_new_with_free_func ((GDestroyNotify) g_hash_table_destroy);
  object->__isset_im_big = FALSE;
}

static void 
t_test_old_school_finalize (GObject *object)
{
  TTestOldSchool *tobject = T_TEST_OLD_SCHOOL (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->im_str != NULL)
  {
    g_free(tobject->im_str);
    tobject->im_str = NULL;
  }
  if (tobject->im_big != NULL)
  {
    g_ptr_array_unref (tobject->im_big);
    tobject->im_big = NULL;
  }
}

static void
t_test_old_school_class_init (TTestOldSchoolClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_old_school_read;
  struct_class->write = t_test_old_school_write;

  gobject_class->finalize = t_test_old_school_finalize;
  gobject_class->get_property = t_test_old_school_get_property;
  gobject_class->set_property = t_test_old_school_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_OLD_SCHOOL_IM_INT,
     g_param_spec_int ("im_int",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_OLD_SCHOOL_IM_STR,
     g_param_spec_string ("im_str",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_OLD_SCHOOL_IM_BIG,
     g_param_spec_boxed ("im_big",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_test_old_school_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestOldSchoolClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_old_school_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestOldSchool),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_old_school_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestOldSchoolType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestSimpleProperties
{
  PROP_T_TEST_SIMPLE_0,
  PROP_T_TEST_SIMPLE_IM_DEFAULT,
  PROP_T_TEST_SIMPLE_IM_REQUIRED,
  PROP_T_TEST_SIMPLE_IM_OPTIONAL
};

/* reads a simple object */
static gint32
t_test_simple_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestSimple * this_object = T_TEST_SIMPLE(object);
  gboolean isset_im_required = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->im_default, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_im_default = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->im_required, error)) < 0)
            return -1;
          xfer += ret;
          isset_im_required = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->im_optional, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_im_optional = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_im_required)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_test_simple_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestSimple * this_object = T_TEST_SIMPLE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Simple", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "im_default", T_I16, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->im_default, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "im_required", T_I16, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->im_required, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_im_optional == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "im_optional", T_I16, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i16 (protocol, this_object->im_optional, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_simple_set_property (GObject *object,
                            guint property_id,
                            const GValue *value,
                            GParamSpec *pspec)
{
  TTestSimple *self = T_TEST_SIMPLE (object);

  switch (property_id)
  {
    case PROP_T_TEST_SIMPLE_IM_DEFAULT:
      self->im_default = g_value_get_int (value);
      self->__isset_im_default = TRUE;
      break;

    case PROP_T_TEST_SIMPLE_IM_REQUIRED:
      self->im_required = g_value_get_int (value);
      break;

    case PROP_T_TEST_SIMPLE_IM_OPTIONAL:
      self->im_optional = g_value_get_int (value);
      self->__isset_im_optional = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_simple_get_property (GObject *object,
                            guint property_id,
                            GValue *value,
                            GParamSpec *pspec)
{
  TTestSimple *self = T_TEST_SIMPLE (object);

  switch (property_id)
  {
    case PROP_T_TEST_SIMPLE_IM_DEFAULT:
      g_value_set_int (value, self->im_default);
      break;

    case PROP_T_TEST_SIMPLE_IM_REQUIRED:
      g_value_set_int (value, self->im_required);
      break;

    case PROP_T_TEST_SIMPLE_IM_OPTIONAL:
      g_value_set_int (value, self->im_optional);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_simple_instance_init (TTestSimple * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->im_default = 0;
  object->__isset_im_default = FALSE;
  object->im_required = 0;
  object->im_optional = 0;
  object->__isset_im_optional = FALSE;
}

static void 
t_test_simple_finalize (GObject *object)
{
  TTestSimple *tobject = T_TEST_SIMPLE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_simple_class_init (TTestSimpleClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_simple_read;
  struct_class->write = t_test_simple_write;

  gobject_class->finalize = t_test_simple_finalize;
  gobject_class->get_property = t_test_simple_get_property;
  gobject_class->set_property = t_test_simple_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_SIMPLE_IM_DEFAULT,
     g_param_spec_int ("im_default",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_SIMPLE_IM_REQUIRED,
     g_param_spec_int ("im_required",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_SIMPLE_IM_OPTIONAL,
     g_param_spec_int ("im_optional",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));
}

GType
t_test_simple_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestSimpleClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_simple_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestSimple),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_simple_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestSimpleType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestTricky1Properties
{
  PROP_T_TEST_TRICKY1_0,
  PROP_T_TEST_TRICKY1_IM_DEFAULT
};

/* reads a tricky1 object */
static gint32
t_test_tricky1_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestTricky1 * this_object = T_TEST_TRICKY1(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->im_default, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_im_default = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_tricky1_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestTricky1 * this_object = T_TEST_TRICKY1(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Tricky1", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "im_default", T_I16, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->im_default, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_tricky1_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  TTestTricky1 *self = T_TEST_TRICKY1 (object);

  switch (property_id)
  {
    case PROP_T_TEST_TRICKY1_IM_DEFAULT:
      self->im_default = g_value_get_int (value);
      self->__isset_im_default = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_tricky1_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  TTestTricky1 *self = T_TEST_TRICKY1 (object);

  switch (property_id)
  {
    case PROP_T_TEST_TRICKY1_IM_DEFAULT:
      g_value_set_int (value, self->im_default);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_tricky1_instance_init (TTestTricky1 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->im_default = 0;
  object->__isset_im_default = FALSE;
}

static void 
t_test_tricky1_finalize (GObject *object)
{
  TTestTricky1 *tobject = T_TEST_TRICKY1 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_tricky1_class_init (TTestTricky1Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_tricky1_read;
  struct_class->write = t_test_tricky1_write;

  gobject_class->finalize = t_test_tricky1_finalize;
  gobject_class->get_property = t_test_tricky1_get_property;
  gobject_class->set_property = t_test_tricky1_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_TRICKY1_IM_DEFAULT,
     g_param_spec_int ("im_default",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));
}

GType
t_test_tricky1_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestTricky1Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_tricky1_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestTricky1),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_tricky1_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestTricky1Type",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestTricky2Properties
{
  PROP_T_TEST_TRICKY2_0,
  PROP_T_TEST_TRICKY2_IM_OPTIONAL
};

/* reads a tricky2 object */
static gint32
t_test_tricky2_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestTricky2 * this_object = T_TEST_TRICKY2(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->im_optional, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_im_optional = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_tricky2_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestTricky2 * this_object = T_TEST_TRICKY2(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Tricky2", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_im_optional == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "im_optional", T_I16, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i16 (protocol, this_object->im_optional, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_tricky2_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  TTestTricky2 *self = T_TEST_TRICKY2 (object);

  switch (property_id)
  {
    case PROP_T_TEST_TRICKY2_IM_OPTIONAL:
      self->im_optional = g_value_get_int (value);
      self->__isset_im_optional = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_tricky2_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  TTestTricky2 *self = T_TEST_TRICKY2 (object);

  switch (property_id)
  {
    case PROP_T_TEST_TRICKY2_IM_OPTIONAL:
      g_value_set_int (value, self->im_optional);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_tricky2_instance_init (TTestTricky2 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->im_optional = 0;
  object->__isset_im_optional = FALSE;
}

static void 
t_test_tricky2_finalize (GObject *object)
{
  TTestTricky2 *tobject = T_TEST_TRICKY2 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_tricky2_class_init (TTestTricky2Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_tricky2_read;
  struct_class->write = t_test_tricky2_write;

  gobject_class->finalize = t_test_tricky2_finalize;
  gobject_class->get_property = t_test_tricky2_get_property;
  gobject_class->set_property = t_test_tricky2_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_TRICKY2_IM_OPTIONAL,
     g_param_spec_int ("im_optional",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));
}

GType
t_test_tricky2_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestTricky2Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_tricky2_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestTricky2),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_tricky2_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestTricky2Type",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestTricky3Properties
{
  PROP_T_TEST_TRICKY3_0,
  PROP_T_TEST_TRICKY3_IM_REQUIRED
};

/* reads a tricky3 object */
static gint32
t_test_tricky3_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestTricky3 * this_object = T_TEST_TRICKY3(object);
  gboolean isset_im_required = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->im_required, error)) < 0)
            return -1;
          xfer += ret;
          isset_im_required = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_im_required)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_test_tricky3_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestTricky3 * this_object = T_TEST_TRICKY3(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Tricky3", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "im_required", T_I16, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->im_required, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_tricky3_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  TTestTricky3 *self = T_TEST_TRICKY3 (object);

  switch (property_id)
  {
    case PROP_T_TEST_TRICKY3_IM_REQUIRED:
      self->im_required = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_tricky3_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  TTestTricky3 *self = T_TEST_TRICKY3 (object);

  switch (property_id)
  {
    case PROP_T_TEST_TRICKY3_IM_REQUIRED:
      g_value_set_int (value, self->im_required);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_tricky3_instance_init (TTestTricky3 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->im_required = 0;
}

static void 
t_test_tricky3_finalize (GObject *object)
{
  TTestTricky3 *tobject = T_TEST_TRICKY3 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_tricky3_class_init (TTestTricky3Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_tricky3_read;
  struct_class->write = t_test_tricky3_write;

  gobject_class->finalize = t_test_tricky3_finalize;
  gobject_class->get_property = t_test_tricky3_get_property;
  gobject_class->set_property = t_test_tricky3_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_TRICKY3_IM_REQUIRED,
     g_param_spec_int ("im_required",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));
}

GType
t_test_tricky3_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestTricky3Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_tricky3_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestTricky3),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_tricky3_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestTricky3Type",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestOptionalDefaultProperties
{
  PROP_T_TEST_OPTIONAL_DEFAULT_0,
  PROP_T_TEST_OPTIONAL_DEFAULT_OPT_INT,
  PROP_T_TEST_OPTIONAL_DEFAULT_OPT_STR
};

/* reads a optional_default object */
static gint32
t_test_optional_default_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestOptionalDefault * this_object = T_TEST_OPTIONAL_DEFAULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->opt_int, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_opt_int = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->opt_str != NULL)
          {
            g_free(this_object->opt_str);
            this_object->opt_str = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->opt_str, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_opt_str = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_optional_default_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestOptionalDefault * this_object = T_TEST_OPTIONAL_DEFAULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "OptionalDefault", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_opt_int == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "opt_int", T_I16, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i16 (protocol, this_object->opt_int, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_opt_str == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "opt_str", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->opt_str, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_optional_default_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  TTestOptionalDefault *self = T_TEST_OPTIONAL_DEFAULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_OPTIONAL_DEFAULT_OPT_INT:
      self->opt_int = g_value_get_int (value);
      self->__isset_opt_int = TRUE;
      break;

    case PROP_T_TEST_OPTIONAL_DEFAULT_OPT_STR:
      if (self->opt_str != NULL)
        g_free (self->opt_str);
      self->opt_str = g_value_dup_string (value);
      self->__isset_opt_str = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_optional_default_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  TTestOptionalDefault *self = T_TEST_OPTIONAL_DEFAULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_OPTIONAL_DEFAULT_OPT_INT:
      g_value_set_int (value, self->opt_int);
      break;

    case PROP_T_TEST_OPTIONAL_DEFAULT_OPT_STR:
      g_value_set_string (value, self->opt_str);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_optional_default_instance_init (TTestOptionalDefault * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->opt_int = 1234;
  object->__isset_opt_int = FALSE;
  object->opt_str = g_strdup ("default");
  object->__isset_opt_str = FALSE;
}

static void 
t_test_optional_default_finalize (GObject *object)
{
  TTestOptionalDefault *tobject = T_TEST_OPTIONAL_DEFAULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->opt_str != NULL)
  {
    g_free(tobject->opt_str);
    tobject->opt_str = NULL;
  }
}

static void
t_test_optional_default_class_init (TTestOptionalDefaultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_optional_default_read;
  struct_class->write = t_test_optional_default_write;

  gobject_class->finalize = t_test_optional_default_finalize;
  gobject_class->get_property = t_test_optional_default_get_property;
  gobject_class->set_property = t_test_optional_default_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_OPTIONAL_DEFAULT_OPT_INT,
     g_param_spec_int ("opt_int",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       1234,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_OPTIONAL_DEFAULT_OPT_STR,
     g_param_spec_string ("opt_str",
                          NULL,
                          NULL,
                          "default",
                          G_PARAM_READWRITE));
}

GType
t_test_optional_default_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestOptionalDefaultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_optional_default_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestOptionalDefault),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_optional_default_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestOptionalDefaultType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestComplexProperties
{
  PROP_T_TEST_COMPLEX_0,
  PROP_T_TEST_COMPLEX_CP_DEFAULT,
  PROP_T_TEST_COMPLEX_CP_REQUIRED,
  PROP_T_TEST_COMPLEX_CP_OPTIONAL,
  PROP_T_TEST_COMPLEX_THE_MAP,
  PROP_T_TEST_COMPLEX_REQ_SIMP,
  PROP_T_TEST_COMPLEX_OPT_SIMP
};

/* reads a complex object */
static gint32
t_test_complex_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestComplex * this_object = T_TEST_COMPLEX(object);
  gboolean isset_cp_required = FALSE;
  gboolean isset_req_simp = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->cp_default, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cp_default = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->cp_required, error)) < 0)
            return -1;
          xfer += ret;
          isset_cp_required = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->cp_optional, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cp_optional = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint16* key6 = g_new (gint16, 1);
              TTestSimple * val7 = NULL;
              if ((ret = thrift_protocol_read_i16 (protocol, &*key6, error)) < 0)
                return -1;
              xfer += ret;
              if ( val7 != NULL)
              {
                g_object_unref (val7);
              }
              val7 = g_object_new (T_TEST_TYPE_SIMPLE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (val7), protocol, error)) < 0)
              {
                g_object_unref (val7);
                return -1;
              }
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->the_map, (gpointer) key6, (gpointer) val7);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_the_map = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->req_simp), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_req_simp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->opt_simp), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_opt_simp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_cp_required)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_req_simp)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_test_complex_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestComplex * this_object = T_TEST_COMPLEX(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Complex", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cp_default", T_I16, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->cp_default, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cp_required", T_I16, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->cp_required, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_cp_optional == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "cp_optional", T_I16, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i16 (protocol, this_object->cp_optional, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "the_map", T_MAP, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint16* key8 = g_new (gint16, 1);
    TTestSimple * val9 = NULL;
    GList *key_list = NULL, *iter = NULL;
    gint16** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_I16, T_STRUCT, (gint32) g_hash_table_size ((GHashTable *) this_object->the_map), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->the_map, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint16*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint16*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key8 = keys[i];
      val9 = (TTestSimple *) g_hash_table_lookup (((GHashTable *) this_object->the_map), (gpointer) key8);

      if ((ret = thrift_protocol_write_i16 (protocol, * key8, error)) < 0)
        return -1;
      if ((ret = thrift_struct_write (THRIFT_STRUCT ( val9), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "req_simp", T_STRUCT, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->req_simp), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_opt_simp == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "opt_simp", T_STRUCT, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->opt_simp), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_complex_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  TTestComplex *self = T_TEST_COMPLEX (object);

  switch (property_id)
  {
    case PROP_T_TEST_COMPLEX_CP_DEFAULT:
      self->cp_default = g_value_get_int (value);
      self->__isset_cp_default = TRUE;
      break;

    case PROP_T_TEST_COMPLEX_CP_REQUIRED:
      self->cp_required = g_value_get_int (value);
      break;

    case PROP_T_TEST_COMPLEX_CP_OPTIONAL:
      self->cp_optional = g_value_get_int (value);
      self->__isset_cp_optional = TRUE;
      break;

    case PROP_T_TEST_COMPLEX_THE_MAP:
      if (self->the_map != NULL)
        g_hash_table_unref (self->the_map);
      self->the_map = g_value_dup_boxed (value);
      self->__isset_the_map = TRUE;
      break;

    case PROP_T_TEST_COMPLEX_REQ_SIMP:
      if (self->req_simp != NULL)
        g_object_unref (self->req_simp);
      self->req_simp = g_value_dup_object (value);
      break;

    case PROP_T_TEST_COMPLEX_OPT_SIMP:
      if (self->opt_simp != NULL)
        g_object_unref (self->opt_simp);
      self->opt_simp = g_value_dup_object (value);
      self->__isset_opt_simp = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_complex_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  TTestComplex *self = T_TEST_COMPLEX (object);

  switch (property_id)
  {
    case PROP_T_TEST_COMPLEX_CP_DEFAULT:
      g_value_set_int (value, self->cp_default);
      break;

    case PROP_T_TEST_COMPLEX_CP_REQUIRED:
      g_value_set_int (value, self->cp_required);
      break;

    case PROP_T_TEST_COMPLEX_CP_OPTIONAL:
      g_value_set_int (value, self->cp_optional);
      break;

    case PROP_T_TEST_COMPLEX_THE_MAP:
      g_value_set_boxed (value, self->the_map);
      break;

    case PROP_T_TEST_COMPLEX_REQ_SIMP:
      g_value_set_object (value, self->req_simp);
      break;

    case PROP_T_TEST_COMPLEX_OPT_SIMP:
      g_value_set_object (value, self->opt_simp);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_complex_instance_init (TTestComplex * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->cp_default = 0;
  object->__isset_cp_default = FALSE;
  object->cp_required = 0;
  object->cp_optional = 0;
  object->__isset_cp_optional = FALSE;
  object->the_map = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_object_unref);
  object->__isset_the_map = FALSE;
  object->req_simp = g_object_new (T_TEST_TYPE_SIMPLE, NULL);
  object->opt_simp = g_object_new (T_TEST_TYPE_SIMPLE, NULL);
  object->__isset_opt_simp = FALSE;
}

static void 
t_test_complex_finalize (GObject *object)
{
  TTestComplex *tobject = T_TEST_COMPLEX (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->the_map != NULL)
  {
    g_hash_table_destroy (tobject->the_map);
    tobject->the_map = NULL;
  }
  if (tobject->req_simp != NULL)
  {
    g_object_unref(tobject->req_simp);
    tobject->req_simp = NULL;
  }
  if (tobject->opt_simp != NULL)
  {
    g_object_unref(tobject->opt_simp);
    tobject->opt_simp = NULL;
  }
}

static void
t_test_complex_class_init (TTestComplexClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_complex_read;
  struct_class->write = t_test_complex_write;

  gobject_class->finalize = t_test_complex_finalize;
  gobject_class->get_property = t_test_complex_get_property;
  gobject_class->set_property = t_test_complex_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPLEX_CP_DEFAULT,
     g_param_spec_int ("cp_default",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPLEX_CP_REQUIRED,
     g_param_spec_int ("cp_required",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPLEX_CP_OPTIONAL,
     g_param_spec_int ("cp_optional",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPLEX_THE_MAP,
     g_param_spec_boxed ("the_map",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPLEX_REQ_SIMP,
     g_param_spec_object ("req_simp",
                         NULL,
                         NULL,
                         T_TEST_TYPE_SIMPLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_COMPLEX_OPT_SIMP,
     g_param_spec_object ("opt_simp",
                         NULL,
                         NULL,
                         T_TEST_TYPE_SIMPLE,
                         G_PARAM_READWRITE));
}

GType
t_test_complex_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestComplexClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_complex_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestComplex),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_complex_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestComplexType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestManyOptProperties
{
  PROP_T_TEST_MANY_OPT_0,
  PROP_T_TEST_MANY_OPT_OPT1,
  PROP_T_TEST_MANY_OPT_OPT2,
  PROP_T_TEST_MANY_OPT_OPT3,
  PROP_T_TEST_MANY_OPT_DEF4,
  PROP_T_TEST_MANY_OPT_OPT5,
  PROP_T_TEST_MANY_OPT_OPT6
};

/* reads a many_opt object */
static gint32
t_test_many_opt_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestManyOpt * this_object = T_TEST_MANY_OPT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->opt1, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_opt1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->opt2, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_opt2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->opt3, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_opt3 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->def4, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_def4 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->opt5, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_opt5 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->opt6, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_opt6 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_many_opt_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestManyOpt * this_object = T_TEST_MANY_OPT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ManyOpt", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_opt1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "opt1", T_I32, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->opt1, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_opt2 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "opt2", T_I32, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->opt2, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_opt3 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "opt3", T_I32, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->opt3, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "def4", T_I32, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->def4, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_opt5 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "opt5", T_I32, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->opt5, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_opt6 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "opt6", T_I32, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->opt6, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_many_opt_set_property (GObject *object,
                              guint property_id,
                              const GValue *value,
                              GParamSpec *pspec)
{
  TTestManyOpt *self = T_TEST_MANY_OPT (object);

  switch (property_id)
  {
    case PROP_T_TEST_MANY_OPT_OPT1:
      self->opt1 = g_value_get_int (value);
      self->__isset_opt1 = TRUE;
      break;

    case PROP_T_TEST_MANY_OPT_OPT2:
      self->opt2 = g_value_get_int (value);
      self->__isset_opt2 = TRUE;
      break;

    case PROP_T_TEST_MANY_OPT_OPT3:
      self->opt3 = g_value_get_int (value);
      self->__isset_opt3 = TRUE;
      break;

    case PROP_T_TEST_MANY_OPT_DEF4:
      self->def4 = g_value_get_int (value);
      self->__isset_def4 = TRUE;
      break;

    case PROP_T_TEST_MANY_OPT_OPT5:
      self->opt5 = g_value_get_int (value);
      self->__isset_opt5 = TRUE;
      break;

    case PROP_T_TEST_MANY_OPT_OPT6:
      self->opt6 = g_value_get_int (value);
      self->__isset_opt6 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_many_opt_get_property (GObject *object,
                              guint property_id,
                              GValue *value,
                              GParamSpec *pspec)
{
  TTestManyOpt *self = T_TEST_MANY_OPT (object);

  switch (property_id)
  {
    case PROP_T_TEST_MANY_OPT_OPT1:
      g_value_set_int (value, self->opt1);
      break;

    case PROP_T_TEST_MANY_OPT_OPT2:
      g_value_set_int (value, self->opt2);
      break;

    case PROP_T_TEST_MANY_OPT_OPT3:
      g_value_set_int (value, self->opt3);
      break;

    case PROP_T_TEST_MANY_OPT_DEF4:
      g_value_set_int (value, self->def4);
      break;

    case PROP_T_TEST_MANY_OPT_OPT5:
      g_value_set_int (value, self->opt5);
      break;

    case PROP_T_TEST_MANY_OPT_OPT6:
      g_value_set_int (value, self->opt6);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_many_opt_instance_init (TTestManyOpt * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->opt1 = 0;
  object->__isset_opt1 = FALSE;
  object->opt2 = 0;
  object->__isset_opt2 = FALSE;
  object->opt3 = 0;
  object->__isset_opt3 = FALSE;
  object->def4 = 0;
  object->__isset_def4 = FALSE;
  object->opt5 = 0;
  object->__isset_opt5 = FALSE;
  object->opt6 = 0;
  object->__isset_opt6 = FALSE;
}

static void 
t_test_many_opt_finalize (GObject *object)
{
  TTestManyOpt *tobject = T_TEST_MANY_OPT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_many_opt_class_init (TTestManyOptClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_many_opt_read;
  struct_class->write = t_test_many_opt_write;

  gobject_class->finalize = t_test_many_opt_finalize;
  gobject_class->get_property = t_test_many_opt_get_property;
  gobject_class->set_property = t_test_many_opt_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_MANY_OPT_OPT1,
     g_param_spec_int ("opt1",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_MANY_OPT_OPT2,
     g_param_spec_int ("opt2",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_MANY_OPT_OPT3,
     g_param_spec_int ("opt3",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_MANY_OPT_DEF4,
     g_param_spec_int ("def4",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_MANY_OPT_OPT5,
     g_param_spec_int ("opt5",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_MANY_OPT_OPT6,
     g_param_spec_int ("opt6",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
t_test_many_opt_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestManyOptClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_many_opt_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestManyOpt),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_many_opt_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestManyOptType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestJavaTestHelperProperties
{
  PROP_T_TEST_JAVA_TEST_HELPER_0,
  PROP_T_TEST_JAVA_TEST_HELPER_REQ_INT,
  PROP_T_TEST_JAVA_TEST_HELPER_OPT_INT,
  PROP_T_TEST_JAVA_TEST_HELPER_REQ_OBJ,
  PROP_T_TEST_JAVA_TEST_HELPER_OPT_OBJ,
  PROP_T_TEST_JAVA_TEST_HELPER_REQ_BIN,
  PROP_T_TEST_JAVA_TEST_HELPER_OPT_BIN
};

/* reads a java_test_helper object */
static gint32
t_test_java_test_helper_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestJavaTestHelper * this_object = T_TEST_JAVA_TEST_HELPER(object);
  gboolean isset_req_int = FALSE;
  gboolean isset_req_obj = FALSE;
  gboolean isset_req_bin = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->req_int, error)) < 0)
            return -1;
          xfer += ret;
          isset_req_int = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->opt_int, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_opt_int = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->req_obj != NULL)
          {
            g_free(this_object->req_obj);
            this_object->req_obj = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->req_obj, error)) < 0)
            return -1;
          xfer += ret;
          isset_req_obj = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->opt_obj != NULL)
          {
            g_free(this_object->opt_obj);
            this_object->opt_obj = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->opt_obj, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_opt_obj = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->req_bin != NULL)
          {
            g_free(this_object->req_bin);
            this_object->req_bin = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->req_bin = g_byte_array_new();
          g_byte_array_append (this_object->req_bin, (guint8 *) data, (guint) len);
          g_free (data);
          isset_req_bin = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->opt_bin != NULL)
          {
            g_free(this_object->opt_bin);
            this_object->opt_bin = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->opt_bin = g_byte_array_new();
          g_byte_array_append (this_object->opt_bin, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_opt_bin = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_req_int)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_req_obj)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_req_bin)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_test_java_test_helper_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestJavaTestHelper * this_object = T_TEST_JAVA_TEST_HELPER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "JavaTestHelper", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "req_int", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->req_int, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_opt_int == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "opt_int", T_I32, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->opt_int, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "req_obj", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->req_obj, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_opt_obj == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "opt_obj", T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->opt_obj, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "req_bin", T_STRING, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->req_bin)->data, ((GByteArray *) this_object->req_bin)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_opt_bin == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "opt_bin", T_STRING, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->opt_bin)->data, ((GByteArray *) this_object->opt_bin)->len, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_java_test_helper_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  TTestJavaTestHelper *self = T_TEST_JAVA_TEST_HELPER (object);

  switch (property_id)
  {
    case PROP_T_TEST_JAVA_TEST_HELPER_REQ_INT:
      self->req_int = g_value_get_int (value);
      break;

    case PROP_T_TEST_JAVA_TEST_HELPER_OPT_INT:
      self->opt_int = g_value_get_int (value);
      self->__isset_opt_int = TRUE;
      break;

    case PROP_T_TEST_JAVA_TEST_HELPER_REQ_OBJ:
      if (self->req_obj != NULL)
        g_free (self->req_obj);
      self->req_obj = g_value_dup_string (value);
      break;

    case PROP_T_TEST_JAVA_TEST_HELPER_OPT_OBJ:
      if (self->opt_obj != NULL)
        g_free (self->opt_obj);
      self->opt_obj = g_value_dup_string (value);
      self->__isset_opt_obj = TRUE;
      break;

    case PROP_T_TEST_JAVA_TEST_HELPER_REQ_BIN:
      if (self->req_bin != NULL)
        g_byte_array_unref (self->req_bin);
      self->req_bin = g_value_dup_boxed (value);
      break;

    case PROP_T_TEST_JAVA_TEST_HELPER_OPT_BIN:
      if (self->opt_bin != NULL)
        g_byte_array_unref (self->opt_bin);
      self->opt_bin = g_value_dup_boxed (value);
      self->__isset_opt_bin = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_java_test_helper_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  TTestJavaTestHelper *self = T_TEST_JAVA_TEST_HELPER (object);

  switch (property_id)
  {
    case PROP_T_TEST_JAVA_TEST_HELPER_REQ_INT:
      g_value_set_int (value, self->req_int);
      break;

    case PROP_T_TEST_JAVA_TEST_HELPER_OPT_INT:
      g_value_set_int (value, self->opt_int);
      break;

    case PROP_T_TEST_JAVA_TEST_HELPER_REQ_OBJ:
      g_value_set_string (value, self->req_obj);
      break;

    case PROP_T_TEST_JAVA_TEST_HELPER_OPT_OBJ:
      g_value_set_string (value, self->opt_obj);
      break;

    case PROP_T_TEST_JAVA_TEST_HELPER_REQ_BIN:
      g_value_set_boxed (value, self->req_bin);
      break;

    case PROP_T_TEST_JAVA_TEST_HELPER_OPT_BIN:
      g_value_set_boxed (value, self->opt_bin);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_java_test_helper_instance_init (TTestJavaTestHelper * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->req_int = 0;
  object->opt_int = 0;
  object->__isset_opt_int = FALSE;
  object->req_obj = NULL;
  object->opt_obj = NULL;
  object->__isset_opt_obj = FALSE;
  object->req_bin = NULL;
  object->opt_bin = NULL;
  object->__isset_opt_bin = FALSE;
}

static void 
t_test_java_test_helper_finalize (GObject *object)
{
  TTestJavaTestHelper *tobject = T_TEST_JAVA_TEST_HELPER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->req_obj != NULL)
  {
    g_free(tobject->req_obj);
    tobject->req_obj = NULL;
  }
  if (tobject->opt_obj != NULL)
  {
    g_free(tobject->opt_obj);
    tobject->opt_obj = NULL;
  }
  if (tobject->req_bin != NULL)
  {
    thrift_string_free(tobject->req_bin);
    tobject->req_bin = NULL;
  }
  if (tobject->opt_bin != NULL)
  {
    thrift_string_free(tobject->opt_bin);
    tobject->opt_bin = NULL;
  }
}

static void
t_test_java_test_helper_class_init (TTestJavaTestHelperClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_java_test_helper_read;
  struct_class->write = t_test_java_test_helper_write;

  gobject_class->finalize = t_test_java_test_helper_finalize;
  gobject_class->get_property = t_test_java_test_helper_get_property;
  gobject_class->set_property = t_test_java_test_helper_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_JAVA_TEST_HELPER_REQ_INT,
     g_param_spec_int ("req_int",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_JAVA_TEST_HELPER_OPT_INT,
     g_param_spec_int ("opt_int",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_JAVA_TEST_HELPER_REQ_OBJ,
     g_param_spec_string ("req_obj",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_JAVA_TEST_HELPER_OPT_OBJ,
     g_param_spec_string ("opt_obj",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_JAVA_TEST_HELPER_REQ_BIN,
     g_param_spec_boxed ("req_bin",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_JAVA_TEST_HELPER_OPT_BIN,
     g_param_spec_boxed ("opt_bin",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_test_java_test_helper_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestJavaTestHelperClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_java_test_helper_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestJavaTestHelper),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_java_test_helper_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestJavaTestHelperType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */

