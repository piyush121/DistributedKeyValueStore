/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "EnumTest_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kMyEnum1Values[] = {
  MyEnum1::ME1_0,
  MyEnum1::ME1_1,
  MyEnum1::ME1_2,
  MyEnum1::ME1_3,
  MyEnum1::ME1_5,
  MyEnum1::ME1_6
};
const char* _kMyEnum1Names[] = {
  "ME1_0",
  "ME1_1",
  "ME1_2",
  "ME1_3",
  "ME1_5",
  "ME1_6"
};
const std::map<int, const char*> _MyEnum1_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kMyEnum1Values, _kMyEnum1Names), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kMyEnum2Values[] = {
  MyEnum2::ME2_0,
  MyEnum2::ME2_1,
  MyEnum2::ME2_2
};
const char* _kMyEnum2Names[] = {
  "ME2_0",
  "ME2_1",
  "ME2_2"
};
const std::map<int, const char*> _MyEnum2_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kMyEnum2Values, _kMyEnum2Names), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kMyEnum2_againValues[] = {
  MyEnum2_again::ME0_1,
  MyEnum2_again::ME1_1,
  MyEnum2_again::ME2_1,
  MyEnum2_again::ME3_1
};
const char* _kMyEnum2_againNames[] = {
  "ME0_1",
  "ME1_1",
  "ME2_1",
  "ME3_1"
};
const std::map<int, const char*> _MyEnum2_again_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kMyEnum2_againValues, _kMyEnum2_againNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kMyEnum3Values[] = {
  MyEnum3::ME3_0,
  MyEnum3::ME3_1,
  MyEnum3::ME3_N2,
  MyEnum3::ME3_N1,
  MyEnum3::ME3_D0,
  MyEnum3::ME3_D1,
  MyEnum3::ME3_9,
  MyEnum3::ME3_10
};
const char* _kMyEnum3Names[] = {
  "ME3_0",
  "ME3_1",
  "ME3_N2",
  "ME3_N1",
  "ME3_D0",
  "ME3_D1",
  "ME3_9",
  "ME3_10"
};
const std::map<int, const char*> _MyEnum3_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kMyEnum3Values, _kMyEnum3Names), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kMyEnum4Values[] = {
  MyEnum4::ME4_A,
  MyEnum4::ME4_B,
  MyEnum4::ME4_C
};
const char* _kMyEnum4Names[] = {
  "ME4_A",
  "ME4_B",
  "ME4_C"
};
const std::map<int, const char*> _MyEnum4_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kMyEnum4Values, _kMyEnum4Names), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


MyStruct::~MyStruct() throw() {
}


void MyStruct::__set_me2_2(const MyEnum2::type val) {
  this->me2_2 = val;
}

void MyStruct::__set_me3_n2(const MyEnum3::type val) {
  this->me3_n2 = val;
}

void MyStruct::__set_me3_d1(const MyEnum3::type val) {
  this->me3_d1 = val;
}

uint32_t MyStruct::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->me2_2 = (MyEnum2::type)ecast0;
          this->__isset.me2_2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1;
          xfer += iprot->readI32(ecast1);
          this->me3_n2 = (MyEnum3::type)ecast1;
          this->__isset.me3_n2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast2;
          xfer += iprot->readI32(ecast2);
          this->me3_d1 = (MyEnum3::type)ecast2;
          this->__isset.me3_d1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MyStruct::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MyStruct");

  xfer += oprot->writeFieldBegin("me2_2", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->me2_2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("me3_n2", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->me3_n2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("me3_d1", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->me3_d1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MyStruct &a, MyStruct &b) {
  using ::std::swap;
  swap(a.me2_2, b.me2_2);
  swap(a.me3_n2, b.me3_n2);
  swap(a.me3_d1, b.me3_d1);
  swap(a.__isset, b.__isset);
}

MyStruct::MyStruct(const MyStruct& other3) {
  me2_2 = other3.me2_2;
  me3_n2 = other3.me3_n2;
  me3_d1 = other3.me3_d1;
  __isset = other3.__isset;
}
MyStruct& MyStruct::operator=(const MyStruct& other4) {
  me2_2 = other4.me2_2;
  me3_n2 = other4.me3_n2;
  me3_d1 = other4.me3_d1;
  __isset = other4.__isset;
  return *this;
}
void MyStruct::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MyStruct(";
  out << "me2_2=" << to_string(me2_2);
  out << ", " << "me3_n2=" << to_string(me3_n2);
  out << ", " << "me3_d1=" << to_string(me3_d1);
  out << ")";
}


