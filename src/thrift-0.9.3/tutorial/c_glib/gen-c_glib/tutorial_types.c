/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "tutorial_types.h"
#include <thrift/c_glib/thrift.h>

/* return the name of the constant */
const char *
toString_Operation(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case OPERATION_ADD:return "OPERATION_ADD";
  case OPERATION_SUBTRACT:return "OPERATION_SUBTRACT";
  case OPERATION_MULTIPLY:return "OPERATION_MULTIPLY";
  case OPERATION_DIVIDE:return "OPERATION_DIVIDE";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

enum _WorkProperties
{
  PROP_WORK_0,
  PROP_WORK_NUM1,
  PROP_WORK_NUM2,
  PROP_WORK_OP,
  PROP_WORK_COMMENT
};

/* reads a work object */
static gint32
work_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Work * this_object = WORK(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->num1, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_num1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->num2, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_num2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          gint32 ecast0;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast0, error)) < 0)
            return -1;
          xfer += ret;
          this_object->op = (Operation)ecast0;
          this_object->__isset_op = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->comment != NULL)
          {
            g_free(this_object->comment);
            this_object->comment = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->comment, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_comment = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
work_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Work * this_object = WORK(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Work", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "num1", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->num1, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "num2", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->num2, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "op", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->op, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_comment == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "comment", T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->comment, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
work_set_property (GObject *object,
                   guint property_id,
                   const GValue *value,
                   GParamSpec *pspec)
{
  Work *self = WORK (object);

  switch (property_id)
  {
    case PROP_WORK_NUM1:
      self->num1 = g_value_get_int (value);
      self->__isset_num1 = TRUE;
      break;

    case PROP_WORK_NUM2:
      self->num2 = g_value_get_int (value);
      self->__isset_num2 = TRUE;
      break;

    case PROP_WORK_OP:
      self->op = g_value_get_int (value);
      self->__isset_op = TRUE;
      break;

    case PROP_WORK_COMMENT:
      if (self->comment != NULL)
        g_free (self->comment);
      self->comment = g_value_dup_string (value);
      self->__isset_comment = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
work_get_property (GObject *object,
                   guint property_id,
                   GValue *value,
                   GParamSpec *pspec)
{
  Work *self = WORK (object);

  switch (property_id)
  {
    case PROP_WORK_NUM1:
      g_value_set_int (value, self->num1);
      break;

    case PROP_WORK_NUM2:
      g_value_set_int (value, self->num2);
      break;

    case PROP_WORK_OP:
      g_value_set_int (value, self->op);
      break;

    case PROP_WORK_COMMENT:
      g_value_set_string (value, self->comment);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
work_instance_init (Work * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->num1 = 0;
  object->__isset_num1 = FALSE;
  object->num2 = 0;
  object->__isset_num2 = FALSE;
  object->__isset_op = FALSE;
  object->comment = NULL;
  object->__isset_comment = FALSE;
}

static void 
work_finalize (GObject *object)
{
  Work *tobject = WORK (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->comment != NULL)
  {
    g_free(tobject->comment);
    tobject->comment = NULL;
  }
}

static void
work_class_init (WorkClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = work_read;
  struct_class->write = work_write;

  gobject_class->finalize = work_finalize;
  gobject_class->get_property = work_get_property;
  gobject_class->set_property = work_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_WORK_NUM1,
     g_param_spec_int ("num1",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_WORK_NUM2,
     g_param_spec_int ("num2",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_WORK_OP,
     g_param_spec_int ("op",
                       NULL,
                       NULL,
                       1,
                       4,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_WORK_COMMENT,
     g_param_spec_string ("comment",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
work_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (WorkClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) work_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Work),
      0, /* n_preallocs */
      (GInstanceInitFunc) work_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "WorkType",
                                   &type_info, 0);
  }

  return type;
}

enum _InvalidOperationProperties
{
  PROP_INVALID_OPERATION_0,
  PROP_INVALID_OPERATION_WHAT_OP,
  PROP_INVALID_OPERATION_WHY
};

/* reads a invalid_operation object */
static gint32
invalid_operation_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  InvalidOperation * this_object = INVALID_OPERATION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->whatOp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_whatOp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->why != NULL)
          {
            g_free(this_object->why);
            this_object->why = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->why, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_why = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
invalid_operation_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  InvalidOperation * this_object = INVALID_OPERATION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "InvalidOperation", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "whatOp", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->whatOp, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "why", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->why, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
invalid_operation_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  InvalidOperation *self = INVALID_OPERATION (object);

  switch (property_id)
  {
    case PROP_INVALID_OPERATION_WHAT_OP:
      self->whatOp = g_value_get_int (value);
      self->__isset_whatOp = TRUE;
      break;

    case PROP_INVALID_OPERATION_WHY:
      if (self->why != NULL)
        g_free (self->why);
      self->why = g_value_dup_string (value);
      self->__isset_why = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
invalid_operation_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  InvalidOperation *self = INVALID_OPERATION (object);

  switch (property_id)
  {
    case PROP_INVALID_OPERATION_WHAT_OP:
      g_value_set_int (value, self->whatOp);
      break;

    case PROP_INVALID_OPERATION_WHY:
      g_value_set_string (value, self->why);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
invalid_operation_instance_init (InvalidOperation * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->whatOp = 0;
  object->__isset_whatOp = FALSE;
  object->why = NULL;
  object->__isset_why = FALSE;
}

static void 
invalid_operation_finalize (GObject *object)
{
  InvalidOperation *tobject = INVALID_OPERATION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->why != NULL)
  {
    g_free(tobject->why);
    tobject->why = NULL;
  }
}

static void
invalid_operation_class_init (InvalidOperationClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = invalid_operation_read;
  struct_class->write = invalid_operation_write;

  gobject_class->finalize = invalid_operation_finalize;
  gobject_class->get_property = invalid_operation_get_property;
  gobject_class->set_property = invalid_operation_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_INVALID_OPERATION_WHAT_OP,
     g_param_spec_int ("whatOp",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_INVALID_OPERATION_WHY,
     g_param_spec_string ("why",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
invalid_operation_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (InvalidOperationClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) invalid_operation_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (InvalidOperation),
      0, /* n_preallocs */
      (GInstanceInitFunc) invalid_operation_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "InvalidOperationType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define INVALID_OPERATION_ERROR_DOMAIN "invalid_operation_error_quark"
GQuark
invalid_operation_error_quark (void)
{
  return g_quark_from_static_string (INVALID_OPERATION_ERROR_DOMAIN);
}

/* constants */
static GHashTable *
mapconstant_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {

    constant = g_hash_table_new (NULL, NULL);
  }
  return constant;
}


/* reads a calculator_ping_args object */
static gint32
calculator_ping_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CalculatorPingArgs * this_object = CALCULATOR_PING_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
calculator_ping_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CalculatorPingArgs * this_object = CALCULATOR_PING_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CalculatorPingArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
calculator_ping_args_instance_init (CalculatorPingArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
calculator_ping_args_finalize (GObject *object)
{
  CalculatorPingArgs *tobject = CALCULATOR_PING_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
calculator_ping_args_class_init (CalculatorPingArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = calculator_ping_args_read;
  struct_class->write = calculator_ping_args_write;

  gobject_class->finalize = calculator_ping_args_finalize;
}

GType
calculator_ping_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CalculatorPingArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) calculator_ping_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CalculatorPingArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) calculator_ping_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CalculatorPingArgsType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a calculator_ping_result object */
static gint32
calculator_ping_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CalculatorPingResult * this_object = CALCULATOR_PING_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
calculator_ping_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CalculatorPingResult * this_object = CALCULATOR_PING_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CalculatorPingResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
calculator_ping_result_instance_init (CalculatorPingResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
calculator_ping_result_finalize (GObject *object)
{
  CalculatorPingResult *tobject = CALCULATOR_PING_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
calculator_ping_result_class_init (CalculatorPingResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = calculator_ping_result_read;
  struct_class->write = calculator_ping_result_write;

  gobject_class->finalize = calculator_ping_result_finalize;
}

GType
calculator_ping_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CalculatorPingResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) calculator_ping_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CalculatorPingResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) calculator_ping_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CalculatorPingResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _CalculatorAddArgsProperties
{
  PROP_CALCULATOR_ADD_ARGS_0,
  PROP_CALCULATOR_ADD_ARGS_NUM1,
  PROP_CALCULATOR_ADD_ARGS_NUM2
};

/* reads a calculator_add_args object */
static gint32
calculator_add_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CalculatorAddArgs * this_object = CALCULATOR_ADD_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->num1, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_num1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->num2, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_num2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
calculator_add_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CalculatorAddArgs * this_object = CALCULATOR_ADD_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CalculatorAddArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "num1", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->num1, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "num2", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->num2, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
calculator_add_args_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  CalculatorAddArgs *self = CALCULATOR_ADD_ARGS (object);

  switch (property_id)
  {
    case PROP_CALCULATOR_ADD_ARGS_NUM1:
      self->num1 = g_value_get_int (value);
      self->__isset_num1 = TRUE;
      break;

    case PROP_CALCULATOR_ADD_ARGS_NUM2:
      self->num2 = g_value_get_int (value);
      self->__isset_num2 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
calculator_add_args_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  CalculatorAddArgs *self = CALCULATOR_ADD_ARGS (object);

  switch (property_id)
  {
    case PROP_CALCULATOR_ADD_ARGS_NUM1:
      g_value_set_int (value, self->num1);
      break;

    case PROP_CALCULATOR_ADD_ARGS_NUM2:
      g_value_set_int (value, self->num2);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
calculator_add_args_instance_init (CalculatorAddArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->num1 = 0;
  object->__isset_num1 = FALSE;
  object->num2 = 0;
  object->__isset_num2 = FALSE;
}

static void 
calculator_add_args_finalize (GObject *object)
{
  CalculatorAddArgs *tobject = CALCULATOR_ADD_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
calculator_add_args_class_init (CalculatorAddArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = calculator_add_args_read;
  struct_class->write = calculator_add_args_write;

  gobject_class->finalize = calculator_add_args_finalize;
  gobject_class->get_property = calculator_add_args_get_property;
  gobject_class->set_property = calculator_add_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CALCULATOR_ADD_ARGS_NUM1,
     g_param_spec_int ("num1",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CALCULATOR_ADD_ARGS_NUM2,
     g_param_spec_int ("num2",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
calculator_add_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CalculatorAddArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) calculator_add_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CalculatorAddArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) calculator_add_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CalculatorAddArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _CalculatorAddResultProperties
{
  PROP_CALCULATOR_ADD_RESULT_0,
  PROP_CALCULATOR_ADD_RESULT_SUCCESS
};

/* reads a calculator_add_result object */
static gint32
calculator_add_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CalculatorAddResult * this_object = CALCULATOR_ADD_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
calculator_add_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CalculatorAddResult * this_object = CALCULATOR_ADD_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CalculatorAddResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
calculator_add_result_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  CalculatorAddResult *self = CALCULATOR_ADD_RESULT (object);

  switch (property_id)
  {
    case PROP_CALCULATOR_ADD_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
calculator_add_result_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  CalculatorAddResult *self = CALCULATOR_ADD_RESULT (object);

  switch (property_id)
  {
    case PROP_CALCULATOR_ADD_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
calculator_add_result_instance_init (CalculatorAddResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
calculator_add_result_finalize (GObject *object)
{
  CalculatorAddResult *tobject = CALCULATOR_ADD_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
calculator_add_result_class_init (CalculatorAddResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = calculator_add_result_read;
  struct_class->write = calculator_add_result_write;

  gobject_class->finalize = calculator_add_result_finalize;
  gobject_class->get_property = calculator_add_result_get_property;
  gobject_class->set_property = calculator_add_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CALCULATOR_ADD_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
calculator_add_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CalculatorAddResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) calculator_add_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CalculatorAddResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) calculator_add_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CalculatorAddResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _CalculatorCalculateArgsProperties
{
  PROP_CALCULATOR_CALCULATE_ARGS_0,
  PROP_CALCULATOR_CALCULATE_ARGS_LOGID,
  PROP_CALCULATOR_CALCULATE_ARGS_W
};

/* reads a calculator_calculate_args object */
static gint32
calculator_calculate_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CalculatorCalculateArgs * this_object = CALCULATOR_CALCULATE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->logid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_logid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->w), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_w = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
calculator_calculate_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CalculatorCalculateArgs * this_object = CALCULATOR_CALCULATE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CalculatorCalculateArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "logid", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->logid, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "w", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->w), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
calculator_calculate_args_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  CalculatorCalculateArgs *self = CALCULATOR_CALCULATE_ARGS (object);

  switch (property_id)
  {
    case PROP_CALCULATOR_CALCULATE_ARGS_LOGID:
      self->logid = g_value_get_int (value);
      self->__isset_logid = TRUE;
      break;

    case PROP_CALCULATOR_CALCULATE_ARGS_W:
      if (self->w != NULL)
        g_object_unref (self->w);
      self->w = g_value_dup_object (value);
      self->__isset_w = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
calculator_calculate_args_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  CalculatorCalculateArgs *self = CALCULATOR_CALCULATE_ARGS (object);

  switch (property_id)
  {
    case PROP_CALCULATOR_CALCULATE_ARGS_LOGID:
      g_value_set_int (value, self->logid);
      break;

    case PROP_CALCULATOR_CALCULATE_ARGS_W:
      g_value_set_object (value, self->w);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
calculator_calculate_args_instance_init (CalculatorCalculateArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->logid = 0;
  object->__isset_logid = FALSE;
  object->w = g_object_new (TYPE_WORK, NULL);
  object->__isset_w = FALSE;
}

static void 
calculator_calculate_args_finalize (GObject *object)
{
  CalculatorCalculateArgs *tobject = CALCULATOR_CALCULATE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->w != NULL)
  {
    g_object_unref(tobject->w);
    tobject->w = NULL;
  }
}

static void
calculator_calculate_args_class_init (CalculatorCalculateArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = calculator_calculate_args_read;
  struct_class->write = calculator_calculate_args_write;

  gobject_class->finalize = calculator_calculate_args_finalize;
  gobject_class->get_property = calculator_calculate_args_get_property;
  gobject_class->set_property = calculator_calculate_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CALCULATOR_CALCULATE_ARGS_LOGID,
     g_param_spec_int ("logid",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CALCULATOR_CALCULATE_ARGS_W,
     g_param_spec_object ("w",
                         NULL,
                         NULL,
                         TYPE_WORK,
                         G_PARAM_READWRITE));
}

GType
calculator_calculate_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CalculatorCalculateArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) calculator_calculate_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CalculatorCalculateArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) calculator_calculate_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CalculatorCalculateArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _CalculatorCalculateResultProperties
{
  PROP_CALCULATOR_CALCULATE_RESULT_0,
  PROP_CALCULATOR_CALCULATE_RESULT_SUCCESS,
  PROP_CALCULATOR_CALCULATE_RESULT_OUCH
};

/* reads a calculator_calculate_result object */
static gint32
calculator_calculate_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CalculatorCalculateResult * this_object = CALCULATOR_CALCULATE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ouch != NULL)
          {
            g_object_unref (this_object->ouch);
          }
          this_object->ouch = g_object_new (TYPE_INVALID_OPERATION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ouch), protocol, error)) < 0)
          {
            g_object_unref (this_object->ouch);
            this_object->ouch = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ouch = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
calculator_calculate_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CalculatorCalculateResult * this_object = CALCULATOR_CALCULATE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CalculatorCalculateResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ouch == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ouch", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ouch), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
calculator_calculate_result_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  CalculatorCalculateResult *self = CALCULATOR_CALCULATE_RESULT (object);

  switch (property_id)
  {
    case PROP_CALCULATOR_CALCULATE_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_CALCULATOR_CALCULATE_RESULT_OUCH:
      if (self->ouch != NULL)
        g_object_unref (self->ouch);
      self->ouch = g_value_dup_object (value);
      self->__isset_ouch = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
calculator_calculate_result_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  CalculatorCalculateResult *self = CALCULATOR_CALCULATE_RESULT (object);

  switch (property_id)
  {
    case PROP_CALCULATOR_CALCULATE_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_CALCULATOR_CALCULATE_RESULT_OUCH:
      g_value_set_object (value, self->ouch);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
calculator_calculate_result_instance_init (CalculatorCalculateResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ouch = NULL;
  object->__isset_ouch = FALSE;
}

static void 
calculator_calculate_result_finalize (GObject *object)
{
  CalculatorCalculateResult *tobject = CALCULATOR_CALCULATE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ouch != NULL)
  {
    g_object_unref(tobject->ouch);
    tobject->ouch = NULL;
  }
}

static void
calculator_calculate_result_class_init (CalculatorCalculateResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = calculator_calculate_result_read;
  struct_class->write = calculator_calculate_result_write;

  gobject_class->finalize = calculator_calculate_result_finalize;
  gobject_class->get_property = calculator_calculate_result_get_property;
  gobject_class->set_property = calculator_calculate_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CALCULATOR_CALCULATE_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CALCULATOR_CALCULATE_RESULT_OUCH,
     g_param_spec_object ("ouch",
                         NULL,
                         NULL,
                         TYPE_INVALID_OPERATION,
                         G_PARAM_READWRITE));
}

GType
calculator_calculate_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CalculatorCalculateResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) calculator_calculate_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CalculatorCalculateResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) calculator_calculate_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CalculatorCalculateResultType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a calculator_zip_args object */
static gint32
calculator_zip_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CalculatorZipArgs * this_object = CALCULATOR_ZIP_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
calculator_zip_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CalculatorZipArgs * this_object = CALCULATOR_ZIP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CalculatorZipArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
calculator_zip_args_instance_init (CalculatorZipArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
calculator_zip_args_finalize (GObject *object)
{
  CalculatorZipArgs *tobject = CALCULATOR_ZIP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
calculator_zip_args_class_init (CalculatorZipArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = calculator_zip_args_read;
  struct_class->write = calculator_zip_args_write;

  gobject_class->finalize = calculator_zip_args_finalize;
}

GType
calculator_zip_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CalculatorZipArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) calculator_zip_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CalculatorZipArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) calculator_zip_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CalculatorZipArgsType",
                                   &type_info, 0);
  }

  return type;
}

