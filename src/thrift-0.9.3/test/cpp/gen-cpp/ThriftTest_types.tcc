/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef ThriftTest_TYPES_TCC
#define ThriftTest_TYPES_TCC

#include "ThriftTest_types.h"

namespace thrift { namespace test {

template <class Protocol_>
uint32_t Bonk::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t Bonk::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Bonk");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t Bools::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->im_true);
          this->__isset.im_true = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->im_false);
          this->__isset.im_false = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t Bools::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Bools");

  xfer += oprot->writeFieldBegin("im_true", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->im_true);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("im_false", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->im_false);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t Xtruct::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->string_thing);
          this->__isset.string_thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->byte_thing);
          this->__isset.byte_thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->i32_thing);
          this->__isset.i32_thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->i64_thing);
          this->__isset.i64_thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t Xtruct::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Xtruct");

  xfer += oprot->writeFieldBegin("string_thing", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->string_thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byte_thing", ::apache::thrift::protocol::T_BYTE, 4);
  xfer += oprot->writeByte(this->byte_thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i32_thing", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->i32_thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i64_thing", ::apache::thrift::protocol::T_I64, 11);
  xfer += oprot->writeI64(this->i64_thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t Xtruct2::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->byte_thing);
          this->__isset.byte_thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->struct_thing.read(iprot);
          this->__isset.struct_thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->i32_thing);
          this->__isset.i32_thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t Xtruct2::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Xtruct2");

  xfer += oprot->writeFieldBegin("byte_thing", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->byte_thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("struct_thing", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->struct_thing.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i32_thing", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->i32_thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t Xtruct3::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->string_thing);
          this->__isset.string_thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->changed);
          this->__isset.changed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->i32_thing);
          this->__isset.i32_thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->i64_thing);
          this->__isset.i64_thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t Xtruct3::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Xtruct3");

  xfer += oprot->writeFieldBegin("string_thing", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->string_thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("changed", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->changed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i32_thing", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->i32_thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i64_thing", ::apache::thrift::protocol::T_I64, 11);
  xfer += oprot->writeI64(this->i64_thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t Insanity::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->userMap.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _ktype11;
            ::apache::thrift::protocol::TType _vtype12;
            xfer += iprot->readMapBegin(_ktype11, _vtype12, _size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              Numberz::type _key15;
              int32_t ecast17;
              xfer += iprot->readI32(ecast17);
              _key15 = (Numberz::type)ecast17;
              UserId& _val16 = this->userMap[_key15];
              xfer += iprot->readI64(_val16);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.userMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->xtructs.clear();
            uint32_t _size18;
            ::apache::thrift::protocol::TType _etype21;
            xfer += iprot->readListBegin(_etype21, _size18);
            this->xtructs.resize(_size18);
            uint32_t _i22;
            for (_i22 = 0; _i22 < _size18; ++_i22)
            {
              xfer += this->xtructs[_i22].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.xtructs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t Insanity::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Insanity");

  xfer += oprot->writeFieldBegin("userMap", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->userMap.size()));
    std::map<Numberz::type, UserId> ::const_iterator _iter23;
    for (_iter23 = this->userMap.begin(); _iter23 != this->userMap.end(); ++_iter23)
    {
      xfer += oprot->writeI32((int32_t)_iter23->first);
      xfer += oprot->writeI64(_iter23->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("xtructs", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->xtructs.size()));
    std::vector<Xtruct> ::const_iterator _iter24;
    for (_iter24 = this->xtructs.begin(); _iter24 != this->xtructs.end(); ++_iter24)
    {
      xfer += (*_iter24).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t CrazyNesting::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_list_field = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->string_field);
          this->__isset.string_field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->set_field.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _etype30;
            xfer += iprot->readSetBegin(_etype30, _size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              Insanity _elem32;
              xfer += _elem32.read(iprot);
              this->set_field.insert(_elem32);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.set_field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->list_field.clear();
            uint32_t _size33;
            ::apache::thrift::protocol::TType _etype36;
            xfer += iprot->readListBegin(_etype36, _size33);
            this->list_field.resize(_size33);
            uint32_t _i37;
            for (_i37 = 0; _i37 < _size33; ++_i37)
            {
              {
                this->list_field[_i37].clear();
                uint32_t _size38;
                ::apache::thrift::protocol::TType _ktype39;
                ::apache::thrift::protocol::TType _vtype40;
                xfer += iprot->readMapBegin(_ktype39, _vtype40, _size38);
                uint32_t _i42;
                for (_i42 = 0; _i42 < _size38; ++_i42)
                {
                  std::set<int32_t>  _key43;
                  {
                    _key43.clear();
                    uint32_t _size45;
                    ::apache::thrift::protocol::TType _etype48;
                    xfer += iprot->readSetBegin(_etype48, _size45);
                    uint32_t _i49;
                    for (_i49 = 0; _i49 < _size45; ++_i49)
                    {
                      int32_t _elem50;
                      xfer += iprot->readI32(_elem50);
                      _key43.insert(_elem50);
                    }
                    xfer += iprot->readSetEnd();
                  }
                  std::map<int32_t, std::set<std::vector<std::map<Insanity, std::string> > > > & _val44 = this->list_field[_i37][_key43];
                  {
                    _val44.clear();
                    uint32_t _size51;
                    ::apache::thrift::protocol::TType _ktype52;
                    ::apache::thrift::protocol::TType _vtype53;
                    xfer += iprot->readMapBegin(_ktype52, _vtype53, _size51);
                    uint32_t _i55;
                    for (_i55 = 0; _i55 < _size51; ++_i55)
                    {
                      int32_t _key56;
                      xfer += iprot->readI32(_key56);
                      std::set<std::vector<std::map<Insanity, std::string> > > & _val57 = _val44[_key56];
                      {
                        _val57.clear();
                        uint32_t _size58;
                        ::apache::thrift::protocol::TType _etype61;
                        xfer += iprot->readSetBegin(_etype61, _size58);
                        uint32_t _i62;
                        for (_i62 = 0; _i62 < _size58; ++_i62)
                        {
                          std::vector<std::map<Insanity, std::string> >  _elem63;
                          {
                            _elem63.clear();
                            uint32_t _size64;
                            ::apache::thrift::protocol::TType _etype67;
                            xfer += iprot->readListBegin(_etype67, _size64);
                            _elem63.resize(_size64);
                            uint32_t _i68;
                            for (_i68 = 0; _i68 < _size64; ++_i68)
                            {
                              {
                                _elem63[_i68].clear();
                                uint32_t _size69;
                                ::apache::thrift::protocol::TType _ktype70;
                                ::apache::thrift::protocol::TType _vtype71;
                                xfer += iprot->readMapBegin(_ktype70, _vtype71, _size69);
                                uint32_t _i73;
                                for (_i73 = 0; _i73 < _size69; ++_i73)
                                {
                                  Insanity _key74;
                                  xfer += _key74.read(iprot);
                                  std::string& _val75 = _elem63[_i68][_key74];
                                  xfer += iprot->readString(_val75);
                                }
                                xfer += iprot->readMapEnd();
                              }
                            }
                            xfer += iprot->readListEnd();
                          }
                          _val57.insert(_elem63);
                        }
                        xfer += iprot->readSetEnd();
                      }
                    }
                    xfer += iprot->readMapEnd();
                  }
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_list_field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->binary_field);
          this->__isset.binary_field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_list_field)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t CrazyNesting::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CrazyNesting");

  xfer += oprot->writeFieldBegin("string_field", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->string_field);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.set_field) {
    xfer += oprot->writeFieldBegin("set_field", ::apache::thrift::protocol::T_SET, 2);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->set_field.size()));
      std::set<Insanity> ::const_iterator _iter76;
      for (_iter76 = this->set_field.begin(); _iter76 != this->set_field.end(); ++_iter76)
      {
        xfer += (*_iter76).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("list_field", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->list_field.size()));
    std::vector<std::map<std::set<int32_t> , std::map<int32_t, std::set<std::vector<std::map<Insanity, std::string> > > > > > ::const_iterator _iter77;
    for (_iter77 = this->list_field.begin(); _iter77 != this->list_field.end(); ++_iter77)
    {
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_SET, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>((*_iter77).size()));
        std::map<std::set<int32_t> , std::map<int32_t, std::set<std::vector<std::map<Insanity, std::string> > > > > ::const_iterator _iter78;
        for (_iter78 = (*_iter77).begin(); _iter78 != (*_iter77).end(); ++_iter78)
        {
          {
            xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(_iter78->first.size()));
            std::set<int32_t> ::const_iterator _iter79;
            for (_iter79 = _iter78->first.begin(); _iter79 != _iter78->first.end(); ++_iter79)
            {
              xfer += oprot->writeI32((*_iter79));
            }
            xfer += oprot->writeSetEnd();
          }
          {
            xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(_iter78->second.size()));
            std::map<int32_t, std::set<std::vector<std::map<Insanity, std::string> > > > ::const_iterator _iter80;
            for (_iter80 = _iter78->second.begin(); _iter80 != _iter78->second.end(); ++_iter80)
            {
              xfer += oprot->writeI32(_iter80->first);
              {
                xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(_iter80->second.size()));
                std::set<std::vector<std::map<Insanity, std::string> > > ::const_iterator _iter81;
                for (_iter81 = _iter80->second.begin(); _iter81 != _iter80->second.end(); ++_iter81)
                {
                  {
                    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>((*_iter81).size()));
                    std::vector<std::map<Insanity, std::string> > ::const_iterator _iter82;
                    for (_iter82 = (*_iter81).begin(); _iter82 != (*_iter81).end(); ++_iter82)
                    {
                      {
                        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRUCT, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter82).size()));
                        std::map<Insanity, std::string> ::const_iterator _iter83;
                        for (_iter83 = (*_iter82).begin(); _iter83 != (*_iter82).end(); ++_iter83)
                        {
                          xfer += _iter83->first.write(oprot);
                          xfer += oprot->writeString(_iter83->second);
                        }
                        xfer += oprot->writeMapEnd();
                      }
                    }
                    xfer += oprot->writeListEnd();
                  }
                }
                xfer += oprot->writeSetEnd();
              }
            }
            xfer += oprot->writeMapEnd();
          }
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("binary_field", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->binary_field);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t Xception::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->errorCode);
          this->__isset.errorCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t Xception::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Xception");

  xfer += oprot->writeFieldBegin("errorCode", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->errorCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t Xception2::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->errorCode);
          this->__isset.errorCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->struct_thing.read(iprot);
          this->__isset.struct_thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t Xception2::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Xception2");

  xfer += oprot->writeFieldBegin("errorCode", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->errorCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("struct_thing", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->struct_thing.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t EmptyStruct::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t EmptyStruct::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EmptyStruct");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t OneField::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->field.read(iprot);
          this->__isset.field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t OneField::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OneField");

  xfer += oprot->writeFieldBegin("field", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->field.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t VersioningTestV1::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->begin_in_both);
          this->__isset.begin_in_both = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->old_string);
          this->__isset.old_string = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->end_in_both);
          this->__isset.end_in_both = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t VersioningTestV1::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VersioningTestV1");

  xfer += oprot->writeFieldBegin("begin_in_both", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->begin_in_both);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("old_string", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->old_string);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_in_both", ::apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32(this->end_in_both);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t VersioningTestV2::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->begin_in_both);
          this->__isset.begin_in_both = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->newint);
          this->__isset.newint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->newbyte);
          this->__isset.newbyte = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->newshort);
          this->__isset.newshort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->newlong);
          this->__isset.newlong = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->newdouble);
          this->__isset.newdouble = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->newstruct.read(iprot);
          this->__isset.newstruct = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->newlist.clear();
            uint32_t _size96;
            ::apache::thrift::protocol::TType _etype99;
            xfer += iprot->readListBegin(_etype99, _size96);
            this->newlist.resize(_size96);
            uint32_t _i100;
            for (_i100 = 0; _i100 < _size96; ++_i100)
            {
              xfer += iprot->readI32(this->newlist[_i100]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.newlist = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->newset.clear();
            uint32_t _size101;
            ::apache::thrift::protocol::TType _etype104;
            xfer += iprot->readSetBegin(_etype104, _size101);
            uint32_t _i105;
            for (_i105 = 0; _i105 < _size101; ++_i105)
            {
              int32_t _elem106;
              xfer += iprot->readI32(_elem106);
              this->newset.insert(_elem106);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.newset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->newmap.clear();
            uint32_t _size107;
            ::apache::thrift::protocol::TType _ktype108;
            ::apache::thrift::protocol::TType _vtype109;
            xfer += iprot->readMapBegin(_ktype108, _vtype109, _size107);
            uint32_t _i111;
            for (_i111 = 0; _i111 < _size107; ++_i111)
            {
              int32_t _key112;
              xfer += iprot->readI32(_key112);
              int32_t& _val113 = this->newmap[_key112];
              xfer += iprot->readI32(_val113);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.newmap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->newstring);
          this->__isset.newstring = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->end_in_both);
          this->__isset.end_in_both = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t VersioningTestV2::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VersioningTestV2");

  xfer += oprot->writeFieldBegin("begin_in_both", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->begin_in_both);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newint", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->newint);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newbyte", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->newbyte);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newshort", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->newshort);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newlong", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->newlong);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newdouble", ::apache::thrift::protocol::T_DOUBLE, 6);
  xfer += oprot->writeDouble(this->newdouble);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newstruct", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->newstruct.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newlist", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->newlist.size()));
    std::vector<int32_t> ::const_iterator _iter114;
    for (_iter114 = this->newlist.begin(); _iter114 != this->newlist.end(); ++_iter114)
    {
      xfer += oprot->writeI32((*_iter114));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newset", ::apache::thrift::protocol::T_SET, 9);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->newset.size()));
    std::set<int32_t> ::const_iterator _iter115;
    for (_iter115 = this->newset.begin(); _iter115 != this->newset.end(); ++_iter115)
    {
      xfer += oprot->writeI32((*_iter115));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newmap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->newmap.size()));
    std::map<int32_t, int32_t> ::const_iterator _iter116;
    for (_iter116 = this->newmap.begin(); _iter116 != this->newmap.end(); ++_iter116)
    {
      xfer += oprot->writeI32(_iter116->first);
      xfer += oprot->writeI32(_iter116->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newstring", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->newstring);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_in_both", ::apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32(this->end_in_both);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ListTypeVersioningV1::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->myints.clear();
            uint32_t _size119;
            ::apache::thrift::protocol::TType _etype122;
            xfer += iprot->readListBegin(_etype122, _size119);
            this->myints.resize(_size119);
            uint32_t _i123;
            for (_i123 = 0; _i123 < _size119; ++_i123)
            {
              xfer += iprot->readI32(this->myints[_i123]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.myints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hello);
          this->__isset.hello = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ListTypeVersioningV1::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ListTypeVersioningV1");

  xfer += oprot->writeFieldBegin("myints", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->myints.size()));
    std::vector<int32_t> ::const_iterator _iter124;
    for (_iter124 = this->myints.begin(); _iter124 != this->myints.end(); ++_iter124)
    {
      xfer += oprot->writeI32((*_iter124));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hello", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->hello);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ListTypeVersioningV2::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->strings.clear();
            uint32_t _size127;
            ::apache::thrift::protocol::TType _etype130;
            xfer += iprot->readListBegin(_etype130, _size127);
            this->strings.resize(_size127);
            uint32_t _i131;
            for (_i131 = 0; _i131 < _size127; ++_i131)
            {
              xfer += iprot->readString(this->strings[_i131]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.strings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hello);
          this->__isset.hello = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ListTypeVersioningV2::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ListTypeVersioningV2");

  xfer += oprot->writeFieldBegin("strings", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->strings.size()));
    std::vector<std::string> ::const_iterator _iter132;
    for (_iter132 = this->strings.begin(); _iter132 != this->strings.end(); ++_iter132)
    {
      xfer += oprot->writeString((*_iter132));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hello", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->hello);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t GuessProtocolStruct::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->map_field.clear();
            uint32_t _size135;
            ::apache::thrift::protocol::TType _ktype136;
            ::apache::thrift::protocol::TType _vtype137;
            xfer += iprot->readMapBegin(_ktype136, _vtype137, _size135);
            uint32_t _i139;
            for (_i139 = 0; _i139 < _size135; ++_i139)
            {
              std::string _key140;
              xfer += iprot->readString(_key140);
              std::string& _val141 = this->map_field[_key140];
              xfer += iprot->readString(_val141);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.map_field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t GuessProtocolStruct::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GuessProtocolStruct");

  xfer += oprot->writeFieldBegin("map_field", ::apache::thrift::protocol::T_MAP, 7);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->map_field.size()));
    std::map<std::string, std::string> ::const_iterator _iter142;
    for (_iter142 = this->map_field.begin(); _iter142 != this->map_field.end(); ++_iter142)
    {
      xfer += oprot->writeString(_iter142->first);
      xfer += oprot->writeString(_iter142->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t LargeDeltas::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->b1.read(iprot);
          this->__isset.b1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->b10.read(iprot);
          this->__isset.b10 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 100:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->b100.read(iprot);
          this->__isset.b100 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 500:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->check_true);
          this->__isset.check_true = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1000:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->b1000.read(iprot);
          this->__isset.b1000 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1500:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->check_false);
          this->__isset.check_false = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2000:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->vertwo2000.read(iprot);
          this->__isset.vertwo2000 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2500:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->a_set2500.clear();
            uint32_t _size145;
            ::apache::thrift::protocol::TType _etype148;
            xfer += iprot->readSetBegin(_etype148, _size145);
            uint32_t _i149;
            for (_i149 = 0; _i149 < _size145; ++_i149)
            {
              std::string _elem150;
              xfer += iprot->readString(_elem150);
              this->a_set2500.insert(_elem150);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.a_set2500 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3000:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->vertwo3000.read(iprot);
          this->__isset.vertwo3000 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4000:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->big_numbers.clear();
            uint32_t _size151;
            ::apache::thrift::protocol::TType _etype154;
            xfer += iprot->readListBegin(_etype154, _size151);
            this->big_numbers.resize(_size151);
            uint32_t _i155;
            for (_i155 = 0; _i155 < _size151; ++_i155)
            {
              xfer += iprot->readI32(this->big_numbers[_i155]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.big_numbers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t LargeDeltas::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LargeDeltas");

  xfer += oprot->writeFieldBegin("b1", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->b1.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("b10", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->b10.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("b100", ::apache::thrift::protocol::T_STRUCT, 100);
  xfer += this->b100.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("check_true", ::apache::thrift::protocol::T_BOOL, 500);
  xfer += oprot->writeBool(this->check_true);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("b1000", ::apache::thrift::protocol::T_STRUCT, 1000);
  xfer += this->b1000.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("check_false", ::apache::thrift::protocol::T_BOOL, 1500);
  xfer += oprot->writeBool(this->check_false);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vertwo2000", ::apache::thrift::protocol::T_STRUCT, 2000);
  xfer += this->vertwo2000.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("a_set2500", ::apache::thrift::protocol::T_SET, 2500);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->a_set2500.size()));
    std::set<std::string> ::const_iterator _iter156;
    for (_iter156 = this->a_set2500.begin(); _iter156 != this->a_set2500.end(); ++_iter156)
    {
      xfer += oprot->writeString((*_iter156));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vertwo3000", ::apache::thrift::protocol::T_STRUCT, 3000);
  xfer += this->vertwo3000.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("big_numbers", ::apache::thrift::protocol::T_LIST, 4000);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->big_numbers.size()));
    std::vector<int32_t> ::const_iterator _iter157;
    for (_iter157 = this->big_numbers.begin(); _iter157 != this->big_numbers.end(); ++_iter157)
    {
      xfer += oprot->writeI32((*_iter157));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t NestedListsI32x2::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->integerlist.clear();
            uint32_t _size160;
            ::apache::thrift::protocol::TType _etype163;
            xfer += iprot->readListBegin(_etype163, _size160);
            this->integerlist.resize(_size160);
            uint32_t _i164;
            for (_i164 = 0; _i164 < _size160; ++_i164)
            {
              {
                this->integerlist[_i164].clear();
                uint32_t _size165;
                ::apache::thrift::protocol::TType _etype168;
                xfer += iprot->readListBegin(_etype168, _size165);
                this->integerlist[_i164].resize(_size165);
                uint32_t _i169;
                for (_i169 = 0; _i169 < _size165; ++_i169)
                {
                  xfer += iprot->readI32(this->integerlist[_i164][_i169]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.integerlist = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t NestedListsI32x2::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NestedListsI32x2");

  xfer += oprot->writeFieldBegin("integerlist", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->integerlist.size()));
    std::vector<std::vector<int32_t> > ::const_iterator _iter170;
    for (_iter170 = this->integerlist.begin(); _iter170 != this->integerlist.end(); ++_iter170)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*_iter170).size()));
        std::vector<int32_t> ::const_iterator _iter171;
        for (_iter171 = (*_iter170).begin(); _iter171 != (*_iter170).end(); ++_iter171)
        {
          xfer += oprot->writeI32((*_iter171));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t NestedListsI32x3::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->integerlist.clear();
            uint32_t _size174;
            ::apache::thrift::protocol::TType _etype177;
            xfer += iprot->readListBegin(_etype177, _size174);
            this->integerlist.resize(_size174);
            uint32_t _i178;
            for (_i178 = 0; _i178 < _size174; ++_i178)
            {
              {
                this->integerlist[_i178].clear();
                uint32_t _size179;
                ::apache::thrift::protocol::TType _etype182;
                xfer += iprot->readListBegin(_etype182, _size179);
                this->integerlist[_i178].resize(_size179);
                uint32_t _i183;
                for (_i183 = 0; _i183 < _size179; ++_i183)
                {
                  {
                    this->integerlist[_i178][_i183].clear();
                    uint32_t _size184;
                    ::apache::thrift::protocol::TType _etype187;
                    xfer += iprot->readListBegin(_etype187, _size184);
                    this->integerlist[_i178][_i183].resize(_size184);
                    uint32_t _i188;
                    for (_i188 = 0; _i188 < _size184; ++_i188)
                    {
                      xfer += iprot->readI32(this->integerlist[_i178][_i183][_i188]);
                    }
                    xfer += iprot->readListEnd();
                  }
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.integerlist = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t NestedListsI32x3::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NestedListsI32x3");

  xfer += oprot->writeFieldBegin("integerlist", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->integerlist.size()));
    std::vector<std::vector<std::vector<int32_t> > > ::const_iterator _iter189;
    for (_iter189 = this->integerlist.begin(); _iter189 != this->integerlist.end(); ++_iter189)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>((*_iter189).size()));
        std::vector<std::vector<int32_t> > ::const_iterator _iter190;
        for (_iter190 = (*_iter189).begin(); _iter190 != (*_iter189).end(); ++_iter190)
        {
          {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*_iter190).size()));
            std::vector<int32_t> ::const_iterator _iter191;
            for (_iter191 = (*_iter190).begin(); _iter191 != (*_iter190).end(); ++_iter191)
            {
              xfer += oprot->writeI32((*_iter191));
            }
            xfer += oprot->writeListEnd();
          }
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t NestedMixedx2::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->int_set_list.clear();
            uint32_t _size194;
            ::apache::thrift::protocol::TType _etype197;
            xfer += iprot->readListBegin(_etype197, _size194);
            this->int_set_list.resize(_size194);
            uint32_t _i198;
            for (_i198 = 0; _i198 < _size194; ++_i198)
            {
              {
                this->int_set_list[_i198].clear();
                uint32_t _size199;
                ::apache::thrift::protocol::TType _etype202;
                xfer += iprot->readSetBegin(_etype202, _size199);
                uint32_t _i203;
                for (_i203 = 0; _i203 < _size199; ++_i203)
                {
                  int32_t _elem204;
                  xfer += iprot->readI32(_elem204);
                  this->int_set_list[_i198].insert(_elem204);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.int_set_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->map_int_strset.clear();
            uint32_t _size205;
            ::apache::thrift::protocol::TType _ktype206;
            ::apache::thrift::protocol::TType _vtype207;
            xfer += iprot->readMapBegin(_ktype206, _vtype207, _size205);
            uint32_t _i209;
            for (_i209 = 0; _i209 < _size205; ++_i209)
            {
              int32_t _key210;
              xfer += iprot->readI32(_key210);
              std::set<std::string> & _val211 = this->map_int_strset[_key210];
              {
                _val211.clear();
                uint32_t _size212;
                ::apache::thrift::protocol::TType _etype215;
                xfer += iprot->readSetBegin(_etype215, _size212);
                uint32_t _i216;
                for (_i216 = 0; _i216 < _size212; ++_i216)
                {
                  std::string _elem217;
                  xfer += iprot->readString(_elem217);
                  _val211.insert(_elem217);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.map_int_strset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->map_int_strset_list.clear();
            uint32_t _size218;
            ::apache::thrift::protocol::TType _etype221;
            xfer += iprot->readListBegin(_etype221, _size218);
            this->map_int_strset_list.resize(_size218);
            uint32_t _i222;
            for (_i222 = 0; _i222 < _size218; ++_i222)
            {
              {
                this->map_int_strset_list[_i222].clear();
                uint32_t _size223;
                ::apache::thrift::protocol::TType _ktype224;
                ::apache::thrift::protocol::TType _vtype225;
                xfer += iprot->readMapBegin(_ktype224, _vtype225, _size223);
                uint32_t _i227;
                for (_i227 = 0; _i227 < _size223; ++_i227)
                {
                  int32_t _key228;
                  xfer += iprot->readI32(_key228);
                  std::set<std::string> & _val229 = this->map_int_strset_list[_i222][_key228];
                  {
                    _val229.clear();
                    uint32_t _size230;
                    ::apache::thrift::protocol::TType _etype233;
                    xfer += iprot->readSetBegin(_etype233, _size230);
                    uint32_t _i234;
                    for (_i234 = 0; _i234 < _size230; ++_i234)
                    {
                      std::string _elem235;
                      xfer += iprot->readString(_elem235);
                      _val229.insert(_elem235);
                    }
                    xfer += iprot->readSetEnd();
                  }
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.map_int_strset_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t NestedMixedx2::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NestedMixedx2");

  xfer += oprot->writeFieldBegin("int_set_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_SET, static_cast<uint32_t>(this->int_set_list.size()));
    std::vector<std::set<int32_t> > ::const_iterator _iter236;
    for (_iter236 = this->int_set_list.begin(); _iter236 != this->int_set_list.end(); ++_iter236)
    {
      {
        xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*_iter236).size()));
        std::set<int32_t> ::const_iterator _iter237;
        for (_iter237 = (*_iter236).begin(); _iter237 != (*_iter236).end(); ++_iter237)
        {
          xfer += oprot->writeI32((*_iter237));
        }
        xfer += oprot->writeSetEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("map_int_strset", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(this->map_int_strset.size()));
    std::map<int32_t, std::set<std::string> > ::const_iterator _iter238;
    for (_iter238 = this->map_int_strset.begin(); _iter238 != this->map_int_strset.end(); ++_iter238)
    {
      xfer += oprot->writeI32(_iter238->first);
      {
        xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter238->second.size()));
        std::set<std::string> ::const_iterator _iter239;
        for (_iter239 = _iter238->second.begin(); _iter239 != _iter238->second.end(); ++_iter239)
        {
          xfer += oprot->writeString((*_iter239));
        }
        xfer += oprot->writeSetEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("map_int_strset_list", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->map_int_strset_list.size()));
    std::vector<std::map<int32_t, std::set<std::string> > > ::const_iterator _iter240;
    for (_iter240 = this->map_int_strset_list.begin(); _iter240 != this->map_int_strset_list.end(); ++_iter240)
    {
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>((*_iter240).size()));
        std::map<int32_t, std::set<std::string> > ::const_iterator _iter241;
        for (_iter241 = (*_iter240).begin(); _iter241 != (*_iter240).end(); ++_iter241)
        {
          xfer += oprot->writeI32(_iter241->first);
          {
            xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter241->second.size()));
            std::set<std::string> ::const_iterator _iter242;
            for (_iter242 = _iter241->second.begin(); _iter242 != _iter241->second.end(); ++_iter242)
            {
              xfer += oprot->writeString((*_iter242));
            }
            xfer += oprot->writeSetEnd();
          }
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ListBonks::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->bonk.clear();
            uint32_t _size245;
            ::apache::thrift::protocol::TType _etype248;
            xfer += iprot->readListBegin(_etype248, _size245);
            this->bonk.resize(_size245);
            uint32_t _i249;
            for (_i249 = 0; _i249 < _size245; ++_i249)
            {
              xfer += this->bonk[_i249].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.bonk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ListBonks::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ListBonks");

  xfer += oprot->writeFieldBegin("bonk", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->bonk.size()));
    std::vector<Bonk> ::const_iterator _iter250;
    for (_iter250 = this->bonk.begin(); _iter250 != this->bonk.end(); ++_iter250)
    {
      xfer += (*_iter250).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t NestedListsBonk::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->bonk.clear();
            uint32_t _size253;
            ::apache::thrift::protocol::TType _etype256;
            xfer += iprot->readListBegin(_etype256, _size253);
            this->bonk.resize(_size253);
            uint32_t _i257;
            for (_i257 = 0; _i257 < _size253; ++_i257)
            {
              {
                this->bonk[_i257].clear();
                uint32_t _size258;
                ::apache::thrift::protocol::TType _etype261;
                xfer += iprot->readListBegin(_etype261, _size258);
                this->bonk[_i257].resize(_size258);
                uint32_t _i262;
                for (_i262 = 0; _i262 < _size258; ++_i262)
                {
                  {
                    this->bonk[_i257][_i262].clear();
                    uint32_t _size263;
                    ::apache::thrift::protocol::TType _etype266;
                    xfer += iprot->readListBegin(_etype266, _size263);
                    this->bonk[_i257][_i262].resize(_size263);
                    uint32_t _i267;
                    for (_i267 = 0; _i267 < _size263; ++_i267)
                    {
                      xfer += this->bonk[_i257][_i262][_i267].read(iprot);
                    }
                    xfer += iprot->readListEnd();
                  }
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.bonk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t NestedListsBonk::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NestedListsBonk");

  xfer += oprot->writeFieldBegin("bonk", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->bonk.size()));
    std::vector<std::vector<std::vector<Bonk> > > ::const_iterator _iter268;
    for (_iter268 = this->bonk.begin(); _iter268 != this->bonk.end(); ++_iter268)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>((*_iter268).size()));
        std::vector<std::vector<Bonk> > ::const_iterator _iter269;
        for (_iter269 = (*_iter268).begin(); _iter269 != (*_iter268).end(); ++_iter269)
        {
          {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter269).size()));
            std::vector<Bonk> ::const_iterator _iter270;
            for (_iter270 = (*_iter269).begin(); _iter270 != (*_iter269).end(); ++_iter270)
            {
              xfer += (*_iter270).write(oprot);
            }
            xfer += oprot->writeListEnd();
          }
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t BoolTest::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->b);
          this->__isset.b = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->s);
          this->__isset.s = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t BoolTest::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BoolTest");

  if (this->__isset.b) {
    xfer += oprot->writeFieldBegin("b", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->b);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.s) {
    xfer += oprot->writeFieldBegin("s", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->s);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t StructA::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_s = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->s);
          isset_s = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_s)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t StructA::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StructA");

  xfer += oprot->writeFieldBegin("s", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->s);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t StructB::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ab = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->aa.read(iprot);
          this->__isset.aa = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ab.read(iprot);
          isset_ab = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ab)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t StructB::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StructB");

  if (this->__isset.aa) {
    xfer += oprot->writeFieldBegin("aa", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->aa.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("ab", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->ab.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

}} // namespace

#endif
