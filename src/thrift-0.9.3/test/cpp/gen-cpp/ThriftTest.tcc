/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "ThriftTest.h"
#ifndef ThriftTest_TCC
#define ThriftTest_TCC

#include "thrift/async/TAsyncChannel.h"

namespace thrift { namespace test {


template <class Protocol_>
uint32_t ThriftTest_testVoid_args::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testVoid_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testVoid_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testVoid_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testVoid_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testVoid_result::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testVoid_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testVoid_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testVoid_presult::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testVoid_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testVoid_presult");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testString_args::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->thing);
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testString_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testString_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testString_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testString_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->thing)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testString_result::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testString_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testString_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testString_presult::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testString_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testString_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
  xfer += oprot->writeString((*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testBool_args::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->thing);
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testBool_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testBool_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testBool_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testBool_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool((*(this->thing)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testBool_result::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testBool_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testBool_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testBool_presult::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testBool_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testBool_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
  xfer += oprot->writeBool((*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testByte_args::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->thing);
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testByte_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testByte_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testByte_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testByte_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte((*(this->thing)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testByte_result::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testByte_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testByte_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BYTE, 0);
    xfer += oprot->writeByte(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testByte_presult::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testByte_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testByte_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BYTE, 0);
  xfer += oprot->writeByte((*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testI32_args::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->thing);
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testI32_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testI32_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testI32_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testI32_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->thing)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testI32_result::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testI32_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testI32_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testI32_presult::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testI32_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testI32_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
  xfer += oprot->writeI32((*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testI64_args::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thing);
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testI64_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testI64_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testI64_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testI64_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thing)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testI64_result::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testI64_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testI64_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testI64_presult::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testI64_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testI64_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
  xfer += oprot->writeI64((*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testDouble_args::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->thing);
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testDouble_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testDouble_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testDouble_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testDouble_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble((*(this->thing)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testDouble_result::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testDouble_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testDouble_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
    xfer += oprot->writeDouble(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testDouble_presult::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testDouble_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testDouble_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
  xfer += oprot->writeDouble((*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testBinary_args::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->thing);
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testBinary_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testBinary_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testBinary_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testBinary_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->thing)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testBinary_result::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testBinary_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testBinary_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeBinary(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testBinary_presult::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testBinary_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testBinary_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
  xfer += oprot->writeBinary((*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testStruct_args::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thing.read(iprot);
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testStruct_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testStruct_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thing.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testStruct_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testStruct_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thing)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testStruct_result::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testStruct_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testStruct_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testStruct_presult::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testStruct_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testStruct_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testNest_args::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thing.read(iprot);
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testNest_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testNest_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thing.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testNest_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testNest_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thing)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testNest_result::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testNest_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testNest_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testNest_presult::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testNest_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testNest_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMap_args::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->thing.clear();
            uint32_t _size279;
            ::apache::thrift::protocol::TType _ktype280;
            ::apache::thrift::protocol::TType _vtype281;
            xfer += iprot->readMapBegin(_ktype280, _vtype281, _size279);
            uint32_t _i283;
            for (_i283 = 0; _i283 < _size279; ++_i283)
            {
              int32_t _key284;
              xfer += iprot->readI32(_key284);
              int32_t& _val285 = this->thing[_key284];
              xfer += iprot->readI32(_val285);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMap_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testMap_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thing.size()));
    std::map<int32_t, int32_t> ::const_iterator _iter286;
    for (_iter286 = this->thing.begin(); _iter286 != this->thing.end(); ++_iter286)
    {
      xfer += oprot->writeI32(_iter286->first);
      xfer += oprot->writeI32(_iter286->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMap_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testMap_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thing)).size()));
    std::map<int32_t, int32_t> ::const_iterator _iter287;
    for (_iter287 = (*(this->thing)).begin(); _iter287 != (*(this->thing)).end(); ++_iter287)
    {
      xfer += oprot->writeI32(_iter287->first);
      xfer += oprot->writeI32(_iter287->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMap_result::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size288;
            ::apache::thrift::protocol::TType _ktype289;
            ::apache::thrift::protocol::TType _vtype290;
            xfer += iprot->readMapBegin(_ktype289, _vtype290, _size288);
            uint32_t _i292;
            for (_i292 = 0; _i292 < _size288; ++_i292)
            {
              int32_t _key293;
              xfer += iprot->readI32(_key293);
              int32_t& _val294 = this->success[_key293];
              xfer += iprot->readI32(_val294);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMap_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testMap_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->success.size()));
      std::map<int32_t, int32_t> ::const_iterator _iter295;
      for (_iter295 = this->success.begin(); _iter295 != this->success.end(); ++_iter295)
      {
        xfer += oprot->writeI32(_iter295->first);
        xfer += oprot->writeI32(_iter295->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMap_presult::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size296;
            ::apache::thrift::protocol::TType _ktype297;
            ::apache::thrift::protocol::TType _vtype298;
            xfer += iprot->readMapBegin(_ktype297, _vtype298, _size296);
            uint32_t _i300;
            for (_i300 = 0; _i300 < _size296; ++_i300)
            {
              int32_t _key301;
              xfer += iprot->readI32(_key301);
              int32_t& _val302 = (*(this->success))[_key301];
              xfer += iprot->readI32(_val302);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMap_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testMap_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->success)).size()));
    std::map<int32_t, int32_t> ::const_iterator _iter303;
    for (_iter303 = (*(this->success)).begin(); _iter303 != (*(this->success)).end(); ++_iter303)
    {
      xfer += oprot->writeI32(_iter303->first);
      xfer += oprot->writeI32(_iter303->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testStringMap_args::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->thing.clear();
            uint32_t _size304;
            ::apache::thrift::protocol::TType _ktype305;
            ::apache::thrift::protocol::TType _vtype306;
            xfer += iprot->readMapBegin(_ktype305, _vtype306, _size304);
            uint32_t _i308;
            for (_i308 = 0; _i308 < _size304; ++_i308)
            {
              std::string _key309;
              xfer += iprot->readString(_key309);
              std::string& _val310 = this->thing[_key309];
              xfer += iprot->readString(_val310);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testStringMap_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testStringMap_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->thing.size()));
    std::map<std::string, std::string> ::const_iterator _iter311;
    for (_iter311 = this->thing.begin(); _iter311 != this->thing.end(); ++_iter311)
    {
      xfer += oprot->writeString(_iter311->first);
      xfer += oprot->writeString(_iter311->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testStringMap_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testStringMap_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->thing)).size()));
    std::map<std::string, std::string> ::const_iterator _iter312;
    for (_iter312 = (*(this->thing)).begin(); _iter312 != (*(this->thing)).end(); ++_iter312)
    {
      xfer += oprot->writeString(_iter312->first);
      xfer += oprot->writeString(_iter312->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testStringMap_result::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size313;
            ::apache::thrift::protocol::TType _ktype314;
            ::apache::thrift::protocol::TType _vtype315;
            xfer += iprot->readMapBegin(_ktype314, _vtype315, _size313);
            uint32_t _i317;
            for (_i317 = 0; _i317 < _size313; ++_i317)
            {
              std::string _key318;
              xfer += iprot->readString(_key318);
              std::string& _val319 = this->success[_key318];
              xfer += iprot->readString(_val319);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testStringMap_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testStringMap_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::map<std::string, std::string> ::const_iterator _iter320;
      for (_iter320 = this->success.begin(); _iter320 != this->success.end(); ++_iter320)
      {
        xfer += oprot->writeString(_iter320->first);
        xfer += oprot->writeString(_iter320->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testStringMap_presult::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size321;
            ::apache::thrift::protocol::TType _ktype322;
            ::apache::thrift::protocol::TType _vtype323;
            xfer += iprot->readMapBegin(_ktype322, _vtype323, _size321);
            uint32_t _i325;
            for (_i325 = 0; _i325 < _size321; ++_i325)
            {
              std::string _key326;
              xfer += iprot->readString(_key326);
              std::string& _val327 = (*(this->success))[_key326];
              xfer += iprot->readString(_val327);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testStringMap_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testStringMap_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->success)).size()));
    std::map<std::string, std::string> ::const_iterator _iter328;
    for (_iter328 = (*(this->success)).begin(); _iter328 != (*(this->success)).end(); ++_iter328)
    {
      xfer += oprot->writeString(_iter328->first);
      xfer += oprot->writeString(_iter328->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testSet_args::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->thing.clear();
            uint32_t _size329;
            ::apache::thrift::protocol::TType _etype332;
            xfer += iprot->readSetBegin(_etype332, _size329);
            uint32_t _i333;
            for (_i333 = 0; _i333 < _size329; ++_i333)
            {
              int32_t _elem334;
              xfer += iprot->readI32(_elem334);
              this->thing.insert(_elem334);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testSet_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testSet_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_SET, 1);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thing.size()));
    std::set<int32_t> ::const_iterator _iter335;
    for (_iter335 = this->thing.begin(); _iter335 != this->thing.end(); ++_iter335)
    {
      xfer += oprot->writeI32((*_iter335));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testSet_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testSet_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_SET, 1);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thing)).size()));
    std::set<int32_t> ::const_iterator _iter336;
    for (_iter336 = (*(this->thing)).begin(); _iter336 != (*(this->thing)).end(); ++_iter336)
    {
      xfer += oprot->writeI32((*_iter336));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testSet_result::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->success.clear();
            uint32_t _size337;
            ::apache::thrift::protocol::TType _etype340;
            xfer += iprot->readSetBegin(_etype340, _size337);
            uint32_t _i341;
            for (_i341 = 0; _i341 < _size337; ++_i341)
            {
              int32_t _elem342;
              xfer += iprot->readI32(_elem342);
              this->success.insert(_elem342);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testSet_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testSet_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_SET, 0);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->success.size()));
      std::set<int32_t> ::const_iterator _iter343;
      for (_iter343 = this->success.begin(); _iter343 != this->success.end(); ++_iter343)
      {
        xfer += oprot->writeI32((*_iter343));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testSet_presult::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            (*(this->success)).clear();
            uint32_t _size344;
            ::apache::thrift::protocol::TType _etype347;
            xfer += iprot->readSetBegin(_etype347, _size344);
            uint32_t _i348;
            for (_i348 = 0; _i348 < _size344; ++_i348)
            {
              int32_t _elem349;
              xfer += iprot->readI32(_elem349);
              (*(this->success)).insert(_elem349);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testSet_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testSet_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_SET, 0);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->success)).size()));
    std::set<int32_t> ::const_iterator _iter350;
    for (_iter350 = (*(this->success)).begin(); _iter350 != (*(this->success)).end(); ++_iter350)
    {
      xfer += oprot->writeI32((*_iter350));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testList_args::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thing.clear();
            uint32_t _size351;
            ::apache::thrift::protocol::TType _etype354;
            xfer += iprot->readListBegin(_etype354, _size351);
            this->thing.resize(_size351);
            uint32_t _i355;
            for (_i355 = 0; _i355 < _size351; ++_i355)
            {
              xfer += iprot->readI32(this->thing[_i355]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testList_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testList_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thing.size()));
    std::vector<int32_t> ::const_iterator _iter356;
    for (_iter356 = this->thing.begin(); _iter356 != this->thing.end(); ++_iter356)
    {
      xfer += oprot->writeI32((*_iter356));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testList_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testList_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thing)).size()));
    std::vector<int32_t> ::const_iterator _iter357;
    for (_iter357 = (*(this->thing)).begin(); _iter357 != (*(this->thing)).end(); ++_iter357)
    {
      xfer += oprot->writeI32((*_iter357));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testList_result::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size358;
            ::apache::thrift::protocol::TType _etype361;
            xfer += iprot->readListBegin(_etype361, _size358);
            this->success.resize(_size358);
            uint32_t _i362;
            for (_i362 = 0; _i362 < _size358; ++_i362)
            {
              xfer += iprot->readI32(this->success[_i362]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testList_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testList_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->success.size()));
      std::vector<int32_t> ::const_iterator _iter363;
      for (_iter363 = this->success.begin(); _iter363 != this->success.end(); ++_iter363)
      {
        xfer += oprot->writeI32((*_iter363));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testList_presult::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size364;
            ::apache::thrift::protocol::TType _etype367;
            xfer += iprot->readListBegin(_etype367, _size364);
            (*(this->success)).resize(_size364);
            uint32_t _i368;
            for (_i368 = 0; _i368 < _size364; ++_i368)
            {
              xfer += iprot->readI32((*(this->success))[_i368]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testList_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testList_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->success)).size()));
    std::vector<int32_t> ::const_iterator _iter369;
    for (_iter369 = (*(this->success)).begin(); _iter369 != (*(this->success)).end(); ++_iter369)
    {
      xfer += oprot->writeI32((*_iter369));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testEnum_args::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast370;
          xfer += iprot->readI32(ecast370);
          this->thing = (Numberz::type)ecast370;
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testEnum_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testEnum_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testEnum_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testEnum_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)(*(this->thing)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testEnum_result::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast371;
          xfer += iprot->readI32(ecast371);
          this->success = (Numberz::type)ecast371;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testEnum_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testEnum_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testEnum_presult::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast372;
          xfer += iprot->readI32(ecast372);
          (*(this->success)) = (Numberz::type)ecast372;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testEnum_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testEnum_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
  xfer += oprot->writeI32((int32_t)(*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testTypedef_args::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thing);
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testTypedef_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testTypedef_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testTypedef_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testTypedef_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thing)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testTypedef_result::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testTypedef_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testTypedef_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testTypedef_presult::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testTypedef_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testTypedef_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
  xfer += oprot->writeI64((*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMapMap_args::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->hello);
          this->__isset.hello = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMapMap_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testMapMap_args");

  xfer += oprot->writeFieldBegin("hello", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->hello);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMapMap_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testMapMap_pargs");

  xfer += oprot->writeFieldBegin("hello", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->hello)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMapMap_result::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size373;
            ::apache::thrift::protocol::TType _ktype374;
            ::apache::thrift::protocol::TType _vtype375;
            xfer += iprot->readMapBegin(_ktype374, _vtype375, _size373);
            uint32_t _i377;
            for (_i377 = 0; _i377 < _size373; ++_i377)
            {
              int32_t _key378;
              xfer += iprot->readI32(_key378);
              std::map<int32_t, int32_t> & _val379 = this->success[_key378];
              {
                _val379.clear();
                uint32_t _size380;
                ::apache::thrift::protocol::TType _ktype381;
                ::apache::thrift::protocol::TType _vtype382;
                xfer += iprot->readMapBegin(_ktype381, _vtype382, _size380);
                uint32_t _i384;
                for (_i384 = 0; _i384 < _size380; ++_i384)
                {
                  int32_t _key385;
                  xfer += iprot->readI32(_key385);
                  int32_t& _val386 = _val379[_key385];
                  xfer += iprot->readI32(_val386);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMapMap_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testMapMap_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->success.size()));
      std::map<int32_t, std::map<int32_t, int32_t> > ::const_iterator _iter387;
      for (_iter387 = this->success.begin(); _iter387 != this->success.end(); ++_iter387)
      {
        xfer += oprot->writeI32(_iter387->first);
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(_iter387->second.size()));
          std::map<int32_t, int32_t> ::const_iterator _iter388;
          for (_iter388 = _iter387->second.begin(); _iter388 != _iter387->second.end(); ++_iter388)
          {
            xfer += oprot->writeI32(_iter388->first);
            xfer += oprot->writeI32(_iter388->second);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMapMap_presult::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size389;
            ::apache::thrift::protocol::TType _ktype390;
            ::apache::thrift::protocol::TType _vtype391;
            xfer += iprot->readMapBegin(_ktype390, _vtype391, _size389);
            uint32_t _i393;
            for (_i393 = 0; _i393 < _size389; ++_i393)
            {
              int32_t _key394;
              xfer += iprot->readI32(_key394);
              std::map<int32_t, int32_t> & _val395 = (*(this->success))[_key394];
              {
                _val395.clear();
                uint32_t _size396;
                ::apache::thrift::protocol::TType _ktype397;
                ::apache::thrift::protocol::TType _vtype398;
                xfer += iprot->readMapBegin(_ktype397, _vtype398, _size396);
                uint32_t _i400;
                for (_i400 = 0; _i400 < _size396; ++_i400)
                {
                  int32_t _key401;
                  xfer += iprot->readI32(_key401);
                  int32_t& _val402 = _val395[_key401];
                  xfer += iprot->readI32(_val402);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMapMap_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testMapMap_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>((*(this->success)).size()));
    std::map<int32_t, std::map<int32_t, int32_t> > ::const_iterator _iter403;
    for (_iter403 = (*(this->success)).begin(); _iter403 != (*(this->success)).end(); ++_iter403)
    {
      xfer += oprot->writeI32(_iter403->first);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(_iter403->second.size()));
        std::map<int32_t, int32_t> ::const_iterator _iter404;
        for (_iter404 = _iter403->second.begin(); _iter404 != _iter403->second.end(); ++_iter404)
        {
          xfer += oprot->writeI32(_iter404->first);
          xfer += oprot->writeI32(_iter404->second);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testInsanity_args::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->argument.read(iprot);
          this->__isset.argument = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testInsanity_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testInsanity_args");

  xfer += oprot->writeFieldBegin("argument", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->argument.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testInsanity_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testInsanity_pargs");

  xfer += oprot->writeFieldBegin("argument", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->argument)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testInsanity_result::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size405;
            ::apache::thrift::protocol::TType _ktype406;
            ::apache::thrift::protocol::TType _vtype407;
            xfer += iprot->readMapBegin(_ktype406, _vtype407, _size405);
            uint32_t _i409;
            for (_i409 = 0; _i409 < _size405; ++_i409)
            {
              UserId _key410;
              xfer += iprot->readI64(_key410);
              std::map<Numberz::type, Insanity> & _val411 = this->success[_key410];
              {
                _val411.clear();
                uint32_t _size412;
                ::apache::thrift::protocol::TType _ktype413;
                ::apache::thrift::protocol::TType _vtype414;
                xfer += iprot->readMapBegin(_ktype413, _vtype414, _size412);
                uint32_t _i416;
                for (_i416 = 0; _i416 < _size412; ++_i416)
                {
                  Numberz::type _key417;
                  int32_t ecast419;
                  xfer += iprot->readI32(ecast419);
                  _key417 = (Numberz::type)ecast419;
                  Insanity& _val418 = _val411[_key417];
                  xfer += _val418.read(iprot);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testInsanity_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testInsanity_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->success.size()));
      std::map<UserId, std::map<Numberz::type, Insanity> > ::const_iterator _iter420;
      for (_iter420 = this->success.begin(); _iter420 != this->success.end(); ++_iter420)
      {
        xfer += oprot->writeI64(_iter420->first);
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter420->second.size()));
          std::map<Numberz::type, Insanity> ::const_iterator _iter421;
          for (_iter421 = _iter420->second.begin(); _iter421 != _iter420->second.end(); ++_iter421)
          {
            xfer += oprot->writeI32((int32_t)_iter421->first);
            xfer += _iter421->second.write(oprot);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testInsanity_presult::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size422;
            ::apache::thrift::protocol::TType _ktype423;
            ::apache::thrift::protocol::TType _vtype424;
            xfer += iprot->readMapBegin(_ktype423, _vtype424, _size422);
            uint32_t _i426;
            for (_i426 = 0; _i426 < _size422; ++_i426)
            {
              UserId _key427;
              xfer += iprot->readI64(_key427);
              std::map<Numberz::type, Insanity> & _val428 = (*(this->success))[_key427];
              {
                _val428.clear();
                uint32_t _size429;
                ::apache::thrift::protocol::TType _ktype430;
                ::apache::thrift::protocol::TType _vtype431;
                xfer += iprot->readMapBegin(_ktype430, _vtype431, _size429);
                uint32_t _i433;
                for (_i433 = 0; _i433 < _size429; ++_i433)
                {
                  Numberz::type _key434;
                  int32_t ecast436;
                  xfer += iprot->readI32(ecast436);
                  _key434 = (Numberz::type)ecast436;
                  Insanity& _val435 = _val428[_key434];
                  xfer += _val435.read(iprot);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testInsanity_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testInsanity_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>((*(this->success)).size()));
    std::map<UserId, std::map<Numberz::type, Insanity> > ::const_iterator _iter437;
    for (_iter437 = (*(this->success)).begin(); _iter437 != (*(this->success)).end(); ++_iter437)
    {
      xfer += oprot->writeI64(_iter437->first);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter437->second.size()));
        std::map<Numberz::type, Insanity> ::const_iterator _iter438;
        for (_iter438 = _iter437->second.begin(); _iter438 != _iter437->second.end(); ++_iter438)
        {
          xfer += oprot->writeI32((int32_t)_iter438->first);
          xfer += _iter438->second.write(oprot);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMulti_args::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->arg0);
          this->__isset.arg0 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->arg1);
          this->__isset.arg1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->arg2);
          this->__isset.arg2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->arg3.clear();
            uint32_t _size439;
            ::apache::thrift::protocol::TType _ktype440;
            ::apache::thrift::protocol::TType _vtype441;
            xfer += iprot->readMapBegin(_ktype440, _vtype441, _size439);
            uint32_t _i443;
            for (_i443 = 0; _i443 < _size439; ++_i443)
            {
              int16_t _key444;
              xfer += iprot->readI16(_key444);
              std::string& _val445 = this->arg3[_key444];
              xfer += iprot->readString(_val445);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.arg3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast446;
          xfer += iprot->readI32(ecast446);
          this->arg4 = (Numberz::type)ecast446;
          this->__isset.arg4 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->arg5);
          this->__isset.arg5 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMulti_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testMulti_args");

  xfer += oprot->writeFieldBegin("arg0", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->arg0);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg1", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->arg1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg2", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->arg2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg3", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I16, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->arg3.size()));
    std::map<int16_t, std::string> ::const_iterator _iter447;
    for (_iter447 = this->arg3.begin(); _iter447 != this->arg3.end(); ++_iter447)
    {
      xfer += oprot->writeI16(_iter447->first);
      xfer += oprot->writeString(_iter447->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg4", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->arg4);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg5", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->arg5);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMulti_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testMulti_pargs");

  xfer += oprot->writeFieldBegin("arg0", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte((*(this->arg0)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg1", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->arg1)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg2", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->arg2)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg3", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I16, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->arg3)).size()));
    std::map<int16_t, std::string> ::const_iterator _iter448;
    for (_iter448 = (*(this->arg3)).begin(); _iter448 != (*(this->arg3)).end(); ++_iter448)
    {
      xfer += oprot->writeI16(_iter448->first);
      xfer += oprot->writeString(_iter448->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg4", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)(*(this->arg4)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg5", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64((*(this->arg5)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMulti_result::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMulti_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testMulti_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMulti_presult::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMulti_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testMulti_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testException_args::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->arg);
          this->__isset.arg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testException_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testException_args");

  xfer += oprot->writeFieldBegin("arg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->arg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testException_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testException_pargs");

  xfer += oprot->writeFieldBegin("arg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->arg)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testException_result::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err1.read(iprot);
          this->__isset.err1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testException_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testException_result");

  if (this->__isset.err1) {
    xfer += oprot->writeFieldBegin("err1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err1.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testException_presult::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err1.read(iprot);
          this->__isset.err1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testException_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testException_presult");

  if (this->__isset.err1) {
    xfer += oprot->writeFieldBegin("err1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err1.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMultiException_args::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->arg0);
          this->__isset.arg0 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->arg1);
          this->__isset.arg1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMultiException_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testMultiException_args");

  xfer += oprot->writeFieldBegin("arg0", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->arg0);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg1", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->arg1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMultiException_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testMultiException_pargs");

  xfer += oprot->writeFieldBegin("arg0", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->arg0)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg1", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->arg1)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMultiException_result::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err1.read(iprot);
          this->__isset.err1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err2.read(iprot);
          this->__isset.err2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMultiException_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testMultiException_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.err1) {
    xfer += oprot->writeFieldBegin("err1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.err2) {
    xfer += oprot->writeFieldBegin("err2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->err2.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMultiException_presult::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err1.read(iprot);
          this->__isset.err1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err2.read(iprot);
          this->__isset.err2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMultiException_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testMultiException_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.err1) {
    xfer += oprot->writeFieldBegin("err1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err1.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.err2) {
    xfer += oprot->writeFieldBegin("err2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->err2.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testOneway_args::read(Protocol_* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->secondsToSleep);
          this->__isset.secondsToSleep = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testOneway_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testOneway_args");

  xfer += oprot->writeFieldBegin("secondsToSleep", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->secondsToSleep);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testOneway_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testOneway_pargs");

  xfer += oprot->writeFieldBegin("secondsToSleep", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->secondsToSleep)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testVoid()
{
  send_testVoid();
  recv_testVoid();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testVoid()
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testVoid", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testVoid_pargs args;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testVoid()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testVoid") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testVoid_presult result;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  return;
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testString(std::string& _return, const std::string& thing)
{
  send_testString(thing);
  recv_testString(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testString(const std::string& thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testString", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testString_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testString(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testString") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testString_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testString failed: unknown result");
}

template <class Protocol_>
bool ThriftTestClientT<Protocol_>::testBool(const bool thing)
{
  send_testBool(thing);
  return recv_testBool();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testBool(const bool thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testBool", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testBool_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
bool ThriftTestClientT<Protocol_>::recv_testBool()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testBool") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  bool _return;
  ThriftTest_testBool_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testBool failed: unknown result");
}

template <class Protocol_>
int8_t ThriftTestClientT<Protocol_>::testByte(const int8_t thing)
{
  send_testByte(thing);
  return recv_testByte();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testByte(const int8_t thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testByte", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testByte_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
int8_t ThriftTestClientT<Protocol_>::recv_testByte()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testByte") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  int8_t _return;
  ThriftTest_testByte_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testByte failed: unknown result");
}

template <class Protocol_>
int32_t ThriftTestClientT<Protocol_>::testI32(const int32_t thing)
{
  send_testI32(thing);
  return recv_testI32();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testI32(const int32_t thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testI32", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testI32_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
int32_t ThriftTestClientT<Protocol_>::recv_testI32()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testI32") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  ThriftTest_testI32_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testI32 failed: unknown result");
}

template <class Protocol_>
int64_t ThriftTestClientT<Protocol_>::testI64(const int64_t thing)
{
  send_testI64(thing);
  return recv_testI64();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testI64(const int64_t thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testI64", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testI64_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
int64_t ThriftTestClientT<Protocol_>::recv_testI64()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testI64") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  int64_t _return;
  ThriftTest_testI64_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testI64 failed: unknown result");
}

template <class Protocol_>
double ThriftTestClientT<Protocol_>::testDouble(const double thing)
{
  send_testDouble(thing);
  return recv_testDouble();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testDouble(const double thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testDouble", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testDouble_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
double ThriftTestClientT<Protocol_>::recv_testDouble()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testDouble") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  double _return;
  ThriftTest_testDouble_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testDouble failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testBinary(std::string& _return, const std::string& thing)
{
  send_testBinary(thing);
  recv_testBinary(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testBinary(const std::string& thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testBinary", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testBinary_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testBinary(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testBinary") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testBinary_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testBinary failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testStruct(Xtruct& _return, const Xtruct& thing)
{
  send_testStruct(thing);
  recv_testStruct(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testStruct(const Xtruct& thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testStruct", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testStruct_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testStruct(Xtruct& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testStruct") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testStruct_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testStruct failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testNest(Xtruct2& _return, const Xtruct2& thing)
{
  send_testNest(thing);
  recv_testNest(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testNest(const Xtruct2& thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testNest", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testNest_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testNest(Xtruct2& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testNest") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testNest_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testNest failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testMap(std::map<int32_t, int32_t> & _return, const std::map<int32_t, int32_t> & thing)
{
  send_testMap(thing);
  recv_testMap(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testMap(const std::map<int32_t, int32_t> & thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testMap", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMap_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testMap(std::map<int32_t, int32_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testMap") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testMap_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMap failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testStringMap(std::map<std::string, std::string> & _return, const std::map<std::string, std::string> & thing)
{
  send_testStringMap(thing);
  recv_testStringMap(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testStringMap(const std::map<std::string, std::string> & thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testStringMap", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testStringMap_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testStringMap(std::map<std::string, std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testStringMap") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testStringMap_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testStringMap failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testSet(std::set<int32_t> & _return, const std::set<int32_t> & thing)
{
  send_testSet(thing);
  recv_testSet(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testSet(const std::set<int32_t> & thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testSet", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testSet_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testSet(std::set<int32_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testSet") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testSet_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testSet failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testList(std::vector<int32_t> & _return, const std::vector<int32_t> & thing)
{
  send_testList(thing);
  recv_testList(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testList(const std::vector<int32_t> & thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testList", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testList_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testList(std::vector<int32_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testList") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testList_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testList failed: unknown result");
}

template <class Protocol_>
Numberz::type ThriftTestClientT<Protocol_>::testEnum(const Numberz::type thing)
{
  send_testEnum(thing);
  return recv_testEnum();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testEnum(const Numberz::type thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testEnum", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testEnum_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
Numberz::type ThriftTestClientT<Protocol_>::recv_testEnum()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testEnum") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  Numberz::type _return;
  ThriftTest_testEnum_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testEnum failed: unknown result");
}

template <class Protocol_>
UserId ThriftTestClientT<Protocol_>::testTypedef(const UserId thing)
{
  send_testTypedef(thing);
  return recv_testTypedef();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testTypedef(const UserId thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testTypedef", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testTypedef_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
UserId ThriftTestClientT<Protocol_>::recv_testTypedef()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testTypedef") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  UserId _return;
  ThriftTest_testTypedef_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testTypedef failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testMapMap(std::map<int32_t, std::map<int32_t, int32_t> > & _return, const int32_t hello)
{
  send_testMapMap(hello);
  recv_testMapMap(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testMapMap(const int32_t hello)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testMapMap", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMapMap_pargs args;
  args.hello = &hello;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testMapMap(std::map<int32_t, std::map<int32_t, int32_t> > & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testMapMap") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testMapMap_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMapMap failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testInsanity(std::map<UserId, std::map<Numberz::type, Insanity> > & _return, const Insanity& argument)
{
  send_testInsanity(argument);
  recv_testInsanity(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testInsanity(const Insanity& argument)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testInsanity", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testInsanity_pargs args;
  args.argument = &argument;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testInsanity(std::map<UserId, std::map<Numberz::type, Insanity> > & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testInsanity") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testInsanity_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testInsanity failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testMulti(Xtruct& _return, const int8_t arg0, const int32_t arg1, const int64_t arg2, const std::map<int16_t, std::string> & arg3, const Numberz::type arg4, const UserId arg5)
{
  send_testMulti(arg0, arg1, arg2, arg3, arg4, arg5);
  recv_testMulti(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testMulti(const int8_t arg0, const int32_t arg1, const int64_t arg2, const std::map<int16_t, std::string> & arg3, const Numberz::type arg4, const UserId arg5)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testMulti", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMulti_pargs args;
  args.arg0 = &arg0;
  args.arg1 = &arg1;
  args.arg2 = &arg2;
  args.arg3 = &arg3;
  args.arg4 = &arg4;
  args.arg5 = &arg5;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testMulti(Xtruct& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testMulti") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testMulti_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMulti failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testException(const std::string& arg)
{
  send_testException(arg);
  recv_testException();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testException(const std::string& arg)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testException", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testException_pargs args;
  args.arg = &arg;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testException()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testException") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testException_presult result;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.err1) {
    throw result.err1;
  }
  return;
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testMultiException(Xtruct& _return, const std::string& arg0, const std::string& arg1)
{
  send_testMultiException(arg0, arg1);
  recv_testMultiException(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testMultiException(const std::string& arg0, const std::string& arg1)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMultiException_pargs args;
  args.arg0 = &arg0;
  args.arg1 = &arg1;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testMultiException(Xtruct& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testMultiException") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testMultiException_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.err1) {
    throw result.err1;
  }
  if (result.__isset.err2) {
    throw result.err2;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMultiException failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testOneway(const int32_t secondsToSleep)
{
  send_testOneway(secondsToSleep);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testOneway(const int32_t secondsToSleep)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testOneway", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ThriftTest_testOneway_pargs args;
  args.secondsToSleep = &secondsToSleep;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
bool ThriftTestProcessorT<Protocol_>::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  typename ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  (this->*(pfn->second.generic))(seqid, iprot, oprot, callContext);
  return true;
}

template <class Protocol_>
bool ThriftTestProcessorT<Protocol_>::dispatchCallTemplated(Protocol_* iprot, Protocol_* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  typename ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  (this->*(pfn->second.specialized))(seqid, iprot, oprot, callContext);
  return true;
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testVoid(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testVoid", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testVoid");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testVoid");
  }

  ThriftTest_testVoid_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testVoid", bytes);
  }

  ThriftTest_testVoid_result result;
  try {
    iface_->testVoid();
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testVoid");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testVoid", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testVoid");
  }

  oprot->writeMessageBegin("testVoid", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testVoid", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testVoid(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testVoid", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testVoid");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testVoid");
  }

  ThriftTest_testVoid_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testVoid", bytes);
  }

  ThriftTest_testVoid_result result;
  try {
    iface_->testVoid();
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testVoid");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testVoid", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testVoid");
  }

  oprot->writeMessageBegin("testVoid", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testVoid", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testString(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testString", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testString");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testString");
  }

  ThriftTest_testString_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testString", bytes);
  }

  ThriftTest_testString_result result;
  try {
    iface_->testString(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testString");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testString", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testString");
  }

  oprot->writeMessageBegin("testString", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testString", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testString(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testString", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testString");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testString");
  }

  ThriftTest_testString_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testString", bytes);
  }

  ThriftTest_testString_result result;
  try {
    iface_->testString(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testString");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testString", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testString");
  }

  oprot->writeMessageBegin("testString", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testString", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testBool(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testBool", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testBool");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testBool");
  }

  ThriftTest_testBool_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testBool", bytes);
  }

  ThriftTest_testBool_result result;
  try {
    result.success = iface_->testBool(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testBool");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testBool", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testBool");
  }

  oprot->writeMessageBegin("testBool", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testBool", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testBool(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testBool", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testBool");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testBool");
  }

  ThriftTest_testBool_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testBool", bytes);
  }

  ThriftTest_testBool_result result;
  try {
    result.success = iface_->testBool(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testBool");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testBool", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testBool");
  }

  oprot->writeMessageBegin("testBool", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testBool", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testByte(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testByte", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testByte");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testByte");
  }

  ThriftTest_testByte_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testByte", bytes);
  }

  ThriftTest_testByte_result result;
  try {
    result.success = iface_->testByte(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testByte");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testByte", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testByte");
  }

  oprot->writeMessageBegin("testByte", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testByte", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testByte(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testByte", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testByte");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testByte");
  }

  ThriftTest_testByte_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testByte", bytes);
  }

  ThriftTest_testByte_result result;
  try {
    result.success = iface_->testByte(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testByte");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testByte", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testByte");
  }

  oprot->writeMessageBegin("testByte", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testByte", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testI32(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI32", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI32");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testI32");
  }

  ThriftTest_testI32_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testI32", bytes);
  }

  ThriftTest_testI32_result result;
  try {
    result.success = iface_->testI32(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testI32");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testI32", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testI32");
  }

  oprot->writeMessageBegin("testI32", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testI32", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testI32(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI32", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI32");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testI32");
  }

  ThriftTest_testI32_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testI32", bytes);
  }

  ThriftTest_testI32_result result;
  try {
    result.success = iface_->testI32(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testI32");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testI32", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testI32");
  }

  oprot->writeMessageBegin("testI32", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testI32", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testI64(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI64", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI64");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testI64");
  }

  ThriftTest_testI64_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testI64", bytes);
  }

  ThriftTest_testI64_result result;
  try {
    result.success = iface_->testI64(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testI64");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testI64", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testI64");
  }

  oprot->writeMessageBegin("testI64", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testI64", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testI64(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI64", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI64");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testI64");
  }

  ThriftTest_testI64_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testI64", bytes);
  }

  ThriftTest_testI64_result result;
  try {
    result.success = iface_->testI64(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testI64");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testI64", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testI64");
  }

  oprot->writeMessageBegin("testI64", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testI64", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testDouble(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testDouble", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testDouble");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testDouble");
  }

  ThriftTest_testDouble_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testDouble", bytes);
  }

  ThriftTest_testDouble_result result;
  try {
    result.success = iface_->testDouble(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testDouble");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testDouble", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testDouble");
  }

  oprot->writeMessageBegin("testDouble", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testDouble", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testDouble(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testDouble", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testDouble");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testDouble");
  }

  ThriftTest_testDouble_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testDouble", bytes);
  }

  ThriftTest_testDouble_result result;
  try {
    result.success = iface_->testDouble(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testDouble");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testDouble", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testDouble");
  }

  oprot->writeMessageBegin("testDouble", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testDouble", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testBinary(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testBinary", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testBinary");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testBinary");
  }

  ThriftTest_testBinary_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testBinary", bytes);
  }

  ThriftTest_testBinary_result result;
  try {
    iface_->testBinary(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testBinary");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testBinary", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testBinary");
  }

  oprot->writeMessageBegin("testBinary", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testBinary", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testBinary(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testBinary", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testBinary");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testBinary");
  }

  ThriftTest_testBinary_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testBinary", bytes);
  }

  ThriftTest_testBinary_result result;
  try {
    iface_->testBinary(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testBinary");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testBinary", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testBinary");
  }

  oprot->writeMessageBegin("testBinary", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testBinary", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testStruct(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStruct", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStruct");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testStruct");
  }

  ThriftTest_testStruct_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testStruct", bytes);
  }

  ThriftTest_testStruct_result result;
  try {
    iface_->testStruct(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testStruct");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testStruct", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testStruct");
  }

  oprot->writeMessageBegin("testStruct", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testStruct", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testStruct(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStruct", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStruct");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testStruct");
  }

  ThriftTest_testStruct_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testStruct", bytes);
  }

  ThriftTest_testStruct_result result;
  try {
    iface_->testStruct(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testStruct");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testStruct", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testStruct");
  }

  oprot->writeMessageBegin("testStruct", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testStruct", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testNest(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testNest", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testNest");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testNest");
  }

  ThriftTest_testNest_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testNest", bytes);
  }

  ThriftTest_testNest_result result;
  try {
    iface_->testNest(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testNest");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testNest", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testNest");
  }

  oprot->writeMessageBegin("testNest", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testNest", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testNest(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testNest", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testNest");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testNest");
  }

  ThriftTest_testNest_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testNest", bytes);
  }

  ThriftTest_testNest_result result;
  try {
    iface_->testNest(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testNest");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testNest", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testNest");
  }

  oprot->writeMessageBegin("testNest", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testNest", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testMap(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testMap");
  }

  ThriftTest_testMap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testMap", bytes);
  }

  ThriftTest_testMap_result result;
  try {
    iface_->testMap(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testMap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMap");
  }

  oprot->writeMessageBegin("testMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMap", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testMap(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testMap");
  }

  ThriftTest_testMap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testMap", bytes);
  }

  ThriftTest_testMap_result result;
  try {
    iface_->testMap(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testMap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMap");
  }

  oprot->writeMessageBegin("testMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMap", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testStringMap(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStringMap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStringMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testStringMap");
  }

  ThriftTest_testStringMap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testStringMap", bytes);
  }

  ThriftTest_testStringMap_result result;
  try {
    iface_->testStringMap(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testStringMap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testStringMap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testStringMap");
  }

  oprot->writeMessageBegin("testStringMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testStringMap", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testStringMap(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStringMap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStringMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testStringMap");
  }

  ThriftTest_testStringMap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testStringMap", bytes);
  }

  ThriftTest_testStringMap_result result;
  try {
    iface_->testStringMap(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testStringMap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testStringMap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testStringMap");
  }

  oprot->writeMessageBegin("testStringMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testStringMap", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testSet(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testSet", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testSet");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testSet");
  }

  ThriftTest_testSet_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testSet", bytes);
  }

  ThriftTest_testSet_result result;
  try {
    iface_->testSet(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testSet");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testSet", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testSet");
  }

  oprot->writeMessageBegin("testSet", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testSet", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testSet(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testSet", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testSet");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testSet");
  }

  ThriftTest_testSet_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testSet", bytes);
  }

  ThriftTest_testSet_result result;
  try {
    iface_->testSet(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testSet");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testSet", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testSet");
  }

  oprot->writeMessageBegin("testSet", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testSet", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testList(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testList", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testList");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testList");
  }

  ThriftTest_testList_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testList", bytes);
  }

  ThriftTest_testList_result result;
  try {
    iface_->testList(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testList");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testList", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testList");
  }

  oprot->writeMessageBegin("testList", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testList", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testList(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testList", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testList");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testList");
  }

  ThriftTest_testList_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testList", bytes);
  }

  ThriftTest_testList_result result;
  try {
    iface_->testList(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testList");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testList", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testList");
  }

  oprot->writeMessageBegin("testList", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testList", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testEnum(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testEnum", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testEnum");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testEnum");
  }

  ThriftTest_testEnum_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testEnum", bytes);
  }

  ThriftTest_testEnum_result result;
  try {
    result.success = iface_->testEnum(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testEnum");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testEnum", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testEnum");
  }

  oprot->writeMessageBegin("testEnum", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testEnum", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testEnum(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testEnum", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testEnum");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testEnum");
  }

  ThriftTest_testEnum_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testEnum", bytes);
  }

  ThriftTest_testEnum_result result;
  try {
    result.success = iface_->testEnum(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testEnum");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testEnum", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testEnum");
  }

  oprot->writeMessageBegin("testEnum", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testEnum", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testTypedef(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testTypedef", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testTypedef");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testTypedef");
  }

  ThriftTest_testTypedef_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testTypedef", bytes);
  }

  ThriftTest_testTypedef_result result;
  try {
    result.success = iface_->testTypedef(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testTypedef");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testTypedef", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testTypedef");
  }

  oprot->writeMessageBegin("testTypedef", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testTypedef", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testTypedef(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testTypedef", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testTypedef");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testTypedef");
  }

  ThriftTest_testTypedef_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testTypedef", bytes);
  }

  ThriftTest_testTypedef_result result;
  try {
    result.success = iface_->testTypedef(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testTypedef");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testTypedef", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testTypedef");
  }

  oprot->writeMessageBegin("testTypedef", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testTypedef", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testMapMap(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMapMap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMapMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testMapMap");
  }

  ThriftTest_testMapMap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testMapMap", bytes);
  }

  ThriftTest_testMapMap_result result;
  try {
    iface_->testMapMap(result.success, args.hello);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMapMap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testMapMap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMapMap");
  }

  oprot->writeMessageBegin("testMapMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMapMap", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testMapMap(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMapMap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMapMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testMapMap");
  }

  ThriftTest_testMapMap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testMapMap", bytes);
  }

  ThriftTest_testMapMap_result result;
  try {
    iface_->testMapMap(result.success, args.hello);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMapMap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testMapMap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMapMap");
  }

  oprot->writeMessageBegin("testMapMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMapMap", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testInsanity(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testInsanity", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testInsanity");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testInsanity");
  }

  ThriftTest_testInsanity_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testInsanity", bytes);
  }

  ThriftTest_testInsanity_result result;
  try {
    iface_->testInsanity(result.success, args.argument);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testInsanity");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testInsanity", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testInsanity");
  }

  oprot->writeMessageBegin("testInsanity", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testInsanity", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testInsanity(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testInsanity", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testInsanity");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testInsanity");
  }

  ThriftTest_testInsanity_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testInsanity", bytes);
  }

  ThriftTest_testInsanity_result result;
  try {
    iface_->testInsanity(result.success, args.argument);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testInsanity");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testInsanity", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testInsanity");
  }

  oprot->writeMessageBegin("testInsanity", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testInsanity", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testMulti(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMulti", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMulti");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testMulti");
  }

  ThriftTest_testMulti_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testMulti", bytes);
  }

  ThriftTest_testMulti_result result;
  try {
    iface_->testMulti(result.success, args.arg0, args.arg1, args.arg2, args.arg3, args.arg4, args.arg5);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMulti");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testMulti", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMulti");
  }

  oprot->writeMessageBegin("testMulti", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMulti", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testMulti(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMulti", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMulti");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testMulti");
  }

  ThriftTest_testMulti_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testMulti", bytes);
  }

  ThriftTest_testMulti_result result;
  try {
    iface_->testMulti(result.success, args.arg0, args.arg1, args.arg2, args.arg3, args.arg4, args.arg5);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMulti");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testMulti", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMulti");
  }

  oprot->writeMessageBegin("testMulti", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMulti", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testException(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testException", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testException");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testException");
  }

  ThriftTest_testException_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testException", bytes);
  }

  ThriftTest_testException_result result;
  try {
    iface_->testException(args.arg);
  } catch (Xception &err1) {
    result.err1 = err1;
    result.__isset.err1 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testException");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testException", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testException");
  }

  oprot->writeMessageBegin("testException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testException", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testException(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testException", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testException");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testException");
  }

  ThriftTest_testException_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testException", bytes);
  }

  ThriftTest_testException_result result;
  try {
    iface_->testException(args.arg);
  } catch (Xception &err1) {
    result.err1 = err1;
    result.__isset.err1 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testException");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testException", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testException");
  }

  oprot->writeMessageBegin("testException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testException", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testMultiException(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMultiException", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMultiException");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testMultiException");
  }

  ThriftTest_testMultiException_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testMultiException", bytes);
  }

  ThriftTest_testMultiException_result result;
  try {
    iface_->testMultiException(result.success, args.arg0, args.arg1);
    result.__isset.success = true;
  } catch (Xception &err1) {
    result.err1 = err1;
    result.__isset.err1 = true;
  } catch (Xception2 &err2) {
    result.err2 = err2;
    result.__isset.err2 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMultiException");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMultiException");
  }

  oprot->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMultiException", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testMultiException(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMultiException", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMultiException");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testMultiException");
  }

  ThriftTest_testMultiException_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testMultiException", bytes);
  }

  ThriftTest_testMultiException_result result;
  try {
    iface_->testMultiException(result.success, args.arg0, args.arg1);
    result.__isset.success = true;
  } catch (Xception &err1) {
    result.err1 = err1;
    result.__isset.err1 = true;
  } catch (Xception2 &err2) {
    result.err2 = err2;
    result.__isset.err2 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMultiException");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMultiException");
  }

  oprot->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMultiException", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testOneway(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  (void) seqid;
  (void) oprot;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testOneway", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testOneway");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testOneway");
  }

  ThriftTest_testOneway_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testOneway", bytes);
  }

  try {
    iface_->testOneway(args.secondsToSleep);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testOneway");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "ThriftTest.testOneway");
  }

  return;
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testOneway(int32_t, Protocol_* iprot, Protocol_*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testOneway", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testOneway");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testOneway");
  }

  ThriftTest_testOneway_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testOneway", bytes);
  }

  try {
    iface_->testOneway(args.secondsToSleep);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testOneway");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "ThriftTest.testOneway");
  }

  return;
}

template <class Protocol_>
::boost::shared_ptr< ::apache::thrift::TProcessor > ThriftTestProcessorFactoryT<Protocol_>::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< ThriftTestIfFactory > cleanup(handlerFactory_);
  ::boost::shared_ptr< ThriftTestIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::boost::shared_ptr< ::apache::thrift::TProcessor > processor(new ThriftTestProcessorT<Protocol_>(handler));
  return processor;
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::testVoid()
{
  int32_t seqid = send_testVoid();
  recv_testVoid(seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testVoid()
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testVoid", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testVoid_pargs args;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::recv_testVoid(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testVoid") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ThriftTest_testVoid_presult result;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::testString(std::string& _return, const std::string& thing)
{
  int32_t seqid = send_testString(thing);
  recv_testString(_return, seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testString(const std::string& thing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testString", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testString_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::recv_testString(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testString") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ThriftTest_testString_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testString failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
bool ThriftTestConcurrentClientT<Protocol_>::testBool(const bool thing)
{
  int32_t seqid = send_testBool(thing);
  return recv_testBool(seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testBool(const bool thing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testBool", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testBool_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
bool ThriftTestConcurrentClientT<Protocol_>::recv_testBool(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testBool") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      ThriftTest_testBool_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testBool failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
int8_t ThriftTestConcurrentClientT<Protocol_>::testByte(const int8_t thing)
{
  int32_t seqid = send_testByte(thing);
  return recv_testByte(seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testByte(const int8_t thing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testByte", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testByte_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
int8_t ThriftTestConcurrentClientT<Protocol_>::recv_testByte(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testByte") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int8_t _return;
      ThriftTest_testByte_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testByte failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::testI32(const int32_t thing)
{
  int32_t seqid = send_testI32(thing);
  return recv_testI32(seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testI32(const int32_t thing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testI32", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testI32_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::recv_testI32(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testI32") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      ThriftTest_testI32_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testI32 failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
int64_t ThriftTestConcurrentClientT<Protocol_>::testI64(const int64_t thing)
{
  int32_t seqid = send_testI64(thing);
  return recv_testI64(seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testI64(const int64_t thing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testI64", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testI64_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
int64_t ThriftTestConcurrentClientT<Protocol_>::recv_testI64(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testI64") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int64_t _return;
      ThriftTest_testI64_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testI64 failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
double ThriftTestConcurrentClientT<Protocol_>::testDouble(const double thing)
{
  int32_t seqid = send_testDouble(thing);
  return recv_testDouble(seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testDouble(const double thing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testDouble", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testDouble_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
double ThriftTestConcurrentClientT<Protocol_>::recv_testDouble(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testDouble") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      double _return;
      ThriftTest_testDouble_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testDouble failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::testBinary(std::string& _return, const std::string& thing)
{
  int32_t seqid = send_testBinary(thing);
  recv_testBinary(_return, seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testBinary(const std::string& thing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testBinary", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testBinary_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::recv_testBinary(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testBinary") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ThriftTest_testBinary_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testBinary failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::testStruct(Xtruct& _return, const Xtruct& thing)
{
  int32_t seqid = send_testStruct(thing);
  recv_testStruct(_return, seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testStruct(const Xtruct& thing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testStruct", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testStruct_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::recv_testStruct(Xtruct& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testStruct") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ThriftTest_testStruct_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testStruct failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::testNest(Xtruct2& _return, const Xtruct2& thing)
{
  int32_t seqid = send_testNest(thing);
  recv_testNest(_return, seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testNest(const Xtruct2& thing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testNest", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testNest_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::recv_testNest(Xtruct2& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testNest") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ThriftTest_testNest_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testNest failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::testMap(std::map<int32_t, int32_t> & _return, const std::map<int32_t, int32_t> & thing)
{
  int32_t seqid = send_testMap(thing);
  recv_testMap(_return, seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testMap(const std::map<int32_t, int32_t> & thing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testMap", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMap_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::recv_testMap(std::map<int32_t, int32_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testMap") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ThriftTest_testMap_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMap failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::testStringMap(std::map<std::string, std::string> & _return, const std::map<std::string, std::string> & thing)
{
  int32_t seqid = send_testStringMap(thing);
  recv_testStringMap(_return, seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testStringMap(const std::map<std::string, std::string> & thing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testStringMap", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testStringMap_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::recv_testStringMap(std::map<std::string, std::string> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testStringMap") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ThriftTest_testStringMap_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testStringMap failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::testSet(std::set<int32_t> & _return, const std::set<int32_t> & thing)
{
  int32_t seqid = send_testSet(thing);
  recv_testSet(_return, seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testSet(const std::set<int32_t> & thing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testSet", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testSet_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::recv_testSet(std::set<int32_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testSet") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ThriftTest_testSet_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testSet failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::testList(std::vector<int32_t> & _return, const std::vector<int32_t> & thing)
{
  int32_t seqid = send_testList(thing);
  recv_testList(_return, seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testList(const std::vector<int32_t> & thing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testList", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testList_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::recv_testList(std::vector<int32_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testList") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ThriftTest_testList_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testList failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
Numberz::type ThriftTestConcurrentClientT<Protocol_>::testEnum(const Numberz::type thing)
{
  int32_t seqid = send_testEnum(thing);
  return recv_testEnum(seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testEnum(const Numberz::type thing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testEnum", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testEnum_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
Numberz::type ThriftTestConcurrentClientT<Protocol_>::recv_testEnum(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testEnum") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Numberz::type _return;
      ThriftTest_testEnum_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testEnum failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
UserId ThriftTestConcurrentClientT<Protocol_>::testTypedef(const UserId thing)
{
  int32_t seqid = send_testTypedef(thing);
  return recv_testTypedef(seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testTypedef(const UserId thing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testTypedef", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testTypedef_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
UserId ThriftTestConcurrentClientT<Protocol_>::recv_testTypedef(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testTypedef") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      UserId _return;
      ThriftTest_testTypedef_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testTypedef failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::testMapMap(std::map<int32_t, std::map<int32_t, int32_t> > & _return, const int32_t hello)
{
  int32_t seqid = send_testMapMap(hello);
  recv_testMapMap(_return, seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testMapMap(const int32_t hello)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testMapMap", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMapMap_pargs args;
  args.hello = &hello;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::recv_testMapMap(std::map<int32_t, std::map<int32_t, int32_t> > & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testMapMap") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ThriftTest_testMapMap_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMapMap failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::testInsanity(std::map<UserId, std::map<Numberz::type, Insanity> > & _return, const Insanity& argument)
{
  int32_t seqid = send_testInsanity(argument);
  recv_testInsanity(_return, seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testInsanity(const Insanity& argument)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testInsanity", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testInsanity_pargs args;
  args.argument = &argument;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::recv_testInsanity(std::map<UserId, std::map<Numberz::type, Insanity> > & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testInsanity") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ThriftTest_testInsanity_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testInsanity failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::testMulti(Xtruct& _return, const int8_t arg0, const int32_t arg1, const int64_t arg2, const std::map<int16_t, std::string> & arg3, const Numberz::type arg4, const UserId arg5)
{
  int32_t seqid = send_testMulti(arg0, arg1, arg2, arg3, arg4, arg5);
  recv_testMulti(_return, seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testMulti(const int8_t arg0, const int32_t arg1, const int64_t arg2, const std::map<int16_t, std::string> & arg3, const Numberz::type arg4, const UserId arg5)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testMulti", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMulti_pargs args;
  args.arg0 = &arg0;
  args.arg1 = &arg1;
  args.arg2 = &arg2;
  args.arg3 = &arg3;
  args.arg4 = &arg4;
  args.arg5 = &arg5;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::recv_testMulti(Xtruct& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testMulti") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ThriftTest_testMulti_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMulti failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::testException(const std::string& arg)
{
  int32_t seqid = send_testException(arg);
  recv_testException(seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testException(const std::string& arg)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testException", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testException_pargs args;
  args.arg = &arg;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::recv_testException(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testException") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ThriftTest_testException_presult result;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.err1) {
        sentry.commit();
        throw result.err1;
      }
      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::testMultiException(Xtruct& _return, const std::string& arg0, const std::string& arg1)
{
  int32_t seqid = send_testMultiException(arg0, arg1);
  recv_testMultiException(_return, seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testMultiException(const std::string& arg0, const std::string& arg1)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMultiException_pargs args;
  args.arg0 = &arg0;
  args.arg1 = &arg1;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::recv_testMultiException(Xtruct& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testMultiException") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ThriftTest_testMultiException_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.err1) {
        sentry.commit();
        throw result.err1;
      }
      if (result.__isset.err2) {
        sentry.commit();
        throw result.err2;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMultiException failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::testOneway(const int32_t secondsToSleep)
{
  send_testOneway(secondsToSleep);
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::send_testOneway(const int32_t secondsToSleep)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testOneway", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ThriftTest_testOneway_pargs args;
  args.secondsToSleep = &secondsToSleep;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testVoid(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob)
{
  send_testVoid();
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testVoid()
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testVoid", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testVoid_pargs args;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testVoid()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testVoid") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testVoid_presult result;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    completed = true;
    completed__(true);
    return;
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testString(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const std::string& thing)
{
  send_testString(thing);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testString(const std::string& thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testString", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testString_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testString(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testString") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testString_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testString failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testBool(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const bool thing)
{
  send_testBool(thing);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testBool(const bool thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testBool", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testBool_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
bool ThriftTestCobClientT<Protocol_>::recv_testBool()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testBool") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    bool _return;
    ThriftTest_testBool_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testBool failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testByte(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const int8_t thing)
{
  send_testByte(thing);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testByte(const int8_t thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testByte", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testByte_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
int8_t ThriftTestCobClientT<Protocol_>::recv_testByte()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testByte") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    int8_t _return;
    ThriftTest_testByte_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testByte failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testI32(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const int32_t thing)
{
  send_testI32(thing);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testI32(const int32_t thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testI32", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testI32_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
int32_t ThriftTestCobClientT<Protocol_>::recv_testI32()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testI32") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    int32_t _return;
    ThriftTest_testI32_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testI32 failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testI64(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const int64_t thing)
{
  send_testI64(thing);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testI64(const int64_t thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testI64", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testI64_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
int64_t ThriftTestCobClientT<Protocol_>::recv_testI64()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testI64") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    int64_t _return;
    ThriftTest_testI64_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testI64 failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testDouble(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const double thing)
{
  send_testDouble(thing);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testDouble(const double thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testDouble", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testDouble_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
double ThriftTestCobClientT<Protocol_>::recv_testDouble()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testDouble") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    double _return;
    ThriftTest_testDouble_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testDouble failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testBinary(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const std::string& thing)
{
  send_testBinary(thing);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testBinary(const std::string& thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testBinary", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testBinary_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testBinary(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testBinary") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testBinary_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testBinary failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testStruct(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const Xtruct& thing)
{
  send_testStruct(thing);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testStruct(const Xtruct& thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testStruct", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testStruct_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testStruct(Xtruct& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testStruct") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testStruct_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testStruct failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testNest(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const Xtruct2& thing)
{
  send_testNest(thing);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testNest(const Xtruct2& thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testNest", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testNest_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testNest(Xtruct2& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testNest") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testNest_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testNest failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testMap(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const std::map<int32_t, int32_t> & thing)
{
  send_testMap(thing);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testMap(const std::map<int32_t, int32_t> & thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testMap", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMap_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testMap(std::map<int32_t, int32_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testMap") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testMap_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMap failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testStringMap(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const std::map<std::string, std::string> & thing)
{
  send_testStringMap(thing);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testStringMap(const std::map<std::string, std::string> & thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testStringMap", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testStringMap_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testStringMap(std::map<std::string, std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testStringMap") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testStringMap_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testStringMap failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testSet(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const std::set<int32_t> & thing)
{
  send_testSet(thing);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testSet(const std::set<int32_t> & thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testSet", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testSet_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testSet(std::set<int32_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testSet") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testSet_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testSet failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testList(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const std::vector<int32_t> & thing)
{
  send_testList(thing);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testList(const std::vector<int32_t> & thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testList", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testList_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testList(std::vector<int32_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testList") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testList_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testList failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testEnum(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const Numberz::type thing)
{
  send_testEnum(thing);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testEnum(const Numberz::type thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testEnum", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testEnum_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
Numberz::type ThriftTestCobClientT<Protocol_>::recv_testEnum()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testEnum") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    Numberz::type _return;
    ThriftTest_testEnum_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testEnum failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testTypedef(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const UserId thing)
{
  send_testTypedef(thing);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testTypedef(const UserId thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testTypedef", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testTypedef_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
UserId ThriftTestCobClientT<Protocol_>::recv_testTypedef()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testTypedef") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    UserId _return;
    ThriftTest_testTypedef_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testTypedef failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testMapMap(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const int32_t hello)
{
  send_testMapMap(hello);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testMapMap(const int32_t hello)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testMapMap", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMapMap_pargs args;
  args.hello = &hello;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testMapMap(std::map<int32_t, std::map<int32_t, int32_t> > & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testMapMap") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testMapMap_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMapMap failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testInsanity(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const Insanity& argument)
{
  send_testInsanity(argument);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testInsanity(const Insanity& argument)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testInsanity", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testInsanity_pargs args;
  args.argument = &argument;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testInsanity(std::map<UserId, std::map<Numberz::type, Insanity> > & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testInsanity") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testInsanity_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testInsanity failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testMulti(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const int8_t arg0, const int32_t arg1, const int64_t arg2, const std::map<int16_t, std::string> & arg3, const Numberz::type arg4, const UserId arg5)
{
  send_testMulti(arg0, arg1, arg2, arg3, arg4, arg5);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testMulti(const int8_t arg0, const int32_t arg1, const int64_t arg2, const std::map<int16_t, std::string> & arg3, const Numberz::type arg4, const UserId arg5)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testMulti", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMulti_pargs args;
  args.arg0 = &arg0;
  args.arg1 = &arg1;
  args.arg2 = &arg2;
  args.arg3 = &arg3;
  args.arg4 = &arg4;
  args.arg5 = &arg5;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testMulti(Xtruct& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testMulti") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testMulti_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMulti failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testException(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const std::string& arg)
{
  send_testException(arg);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testException(const std::string& arg)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testException", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testException_pargs args;
  args.arg = &arg;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testException()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testException") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testException_presult result;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.err1) {
      completed = true;
      completed__(true);
      throw result.err1;
    }
    completed = true;
    completed__(true);
    return;
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testMultiException(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const std::string& arg0, const std::string& arg1)
{
  send_testMultiException(arg0, arg1);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testMultiException(const std::string& arg0, const std::string& arg1)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMultiException_pargs args;
  args.arg0 = &arg0;
  args.arg1 = &arg1;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testMultiException(Xtruct& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testMultiException") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testMultiException_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.err1) {
      completed = true;
      completed__(true);
      throw result.err1;
    }
    if (result.__isset.err2) {
      completed = true;
      completed__(true);
      throw result.err2;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMultiException failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testOneway(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const int32_t secondsToSleep)
{
  send_testOneway(secondsToSleep);
  this->channel_->sendMessage(tcxx::bind(cob, this), this->otrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testOneway(const int32_t secondsToSleep)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testOneway", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ThriftTest_testOneway_pargs args;
  args.secondsToSleep = &secondsToSleep;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::dispatchCall(tcxx::function<void(bool ok)> cob, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid) {
  typename ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  (this->*(pfn->second.generic))(cob, seqid, iprot, oprot);
  return;
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::dispatchCallTemplated(tcxx::function<void(bool ok)> cob, Protocol_* iprot, Protocol_* oprot, const std::string& fname, int32_t seqid) {
  typename ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  (this->*(pfn->second.specialized))(cob, seqid, iprot, oprot);
  return;
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testVoid(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testVoid(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testVoid_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testVoid", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testVoid");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testVoid");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testVoid", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testVoid");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testVoid;
  iface_->testVoid(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx));
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testVoid(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testVoid(cob, seqid, _oprot, ctx);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testVoid_presult result;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testVoid", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testVoid");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testVoid");
  }

  oprot->writeMessageBegin("testVoid", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testVoid", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testVoid(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testVoid_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testVoid", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testVoid");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testVoid");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testVoid", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testVoid");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testVoid;
  iface_->testVoid(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx));
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testVoid(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx)
{
  ThriftTest_testVoid_presult result;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testVoid", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testVoid");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testVoid");
  }

  oprot->writeMessageBegin("testVoid", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testVoid", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testString(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testString(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testString_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testString", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testString");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testString");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testString", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testString");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::string& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testString;
  iface_->testString(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testString(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::string& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testString(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testString_presult result;
  result.success = const_cast<std::string*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testString", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testString");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testString");
  }

  oprot->writeMessageBegin("testString", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testString", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testString(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testString_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testString", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testString");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testString");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testString", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testString");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::string& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testString;
  iface_->testString(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testString(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::string& _return)
{
  ThriftTest_testString_presult result;
  result.success = const_cast<std::string*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testString", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testString");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testString");
  }

  oprot->writeMessageBegin("testString", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testString", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testBool(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testBool(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testBool_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testBool", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testBool");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testBool");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testBool", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testBool");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testBool;
  iface_->testBool(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testBool(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testBool(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testBool_presult result;
  result.success = const_cast<bool*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testBool", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testBool");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testBool");
  }

  oprot->writeMessageBegin("testBool", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testBool", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testBool(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testBool_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testBool", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testBool");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testBool");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testBool", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testBool");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const bool& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testBool;
  iface_->testBool(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testBool(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const bool& _return)
{
  ThriftTest_testBool_presult result;
  result.success = const_cast<bool*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testBool", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testBool");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testBool");
  }

  oprot->writeMessageBegin("testBool", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testBool", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testByte(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testByte(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testByte_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testByte", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testByte");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testByte");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testByte", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testByte");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const int8_t& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testByte;
  iface_->testByte(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testByte(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const int8_t& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testByte(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testByte_presult result;
  result.success = const_cast<int8_t*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testByte", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testByte");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testByte");
  }

  oprot->writeMessageBegin("testByte", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testByte", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testByte(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testByte_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testByte", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testByte");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testByte");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testByte", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testByte");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const int8_t& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testByte;
  iface_->testByte(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testByte(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const int8_t& _return)
{
  ThriftTest_testByte_presult result;
  result.success = const_cast<int8_t*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testByte", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testByte");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testByte");
  }

  oprot->writeMessageBegin("testByte", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testByte", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testI32(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testI32(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testI32_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI32", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI32");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testI32");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testI32", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testI32");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const int32_t& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testI32;
  iface_->testI32(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testI32(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const int32_t& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testI32(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testI32_presult result;
  result.success = const_cast<int32_t*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI32", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI32");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testI32");
  }

  oprot->writeMessageBegin("testI32", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testI32", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testI32(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testI32_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI32", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI32");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testI32");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testI32", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testI32");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const int32_t& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testI32;
  iface_->testI32(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testI32(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const int32_t& _return)
{
  ThriftTest_testI32_presult result;
  result.success = const_cast<int32_t*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI32", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI32");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testI32");
  }

  oprot->writeMessageBegin("testI32", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testI32", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testI64(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testI64(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testI64_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI64", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI64");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testI64");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testI64", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testI64");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const int64_t& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testI64;
  iface_->testI64(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testI64(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const int64_t& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testI64(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testI64_presult result;
  result.success = const_cast<int64_t*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI64", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI64");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testI64");
  }

  oprot->writeMessageBegin("testI64", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testI64", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testI64(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testI64_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI64", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI64");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testI64");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testI64", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testI64");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const int64_t& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testI64;
  iface_->testI64(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testI64(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const int64_t& _return)
{
  ThriftTest_testI64_presult result;
  result.success = const_cast<int64_t*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI64", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI64");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testI64");
  }

  oprot->writeMessageBegin("testI64", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testI64", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testDouble(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testDouble(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testDouble_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testDouble", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testDouble");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testDouble");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testDouble", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testDouble");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const double& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testDouble;
  iface_->testDouble(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testDouble(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const double& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testDouble(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testDouble_presult result;
  result.success = const_cast<double*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testDouble", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testDouble");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testDouble");
  }

  oprot->writeMessageBegin("testDouble", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testDouble", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testDouble(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testDouble_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testDouble", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testDouble");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testDouble");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testDouble", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testDouble");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const double& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testDouble;
  iface_->testDouble(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testDouble(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const double& _return)
{
  ThriftTest_testDouble_presult result;
  result.success = const_cast<double*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testDouble", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testDouble");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testDouble");
  }

  oprot->writeMessageBegin("testDouble", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testDouble", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testBinary(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testBinary(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testBinary_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testBinary", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testBinary");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testBinary");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testBinary", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testBinary");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::string& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testBinary;
  iface_->testBinary(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testBinary(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::string& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testBinary(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testBinary_presult result;
  result.success = const_cast<std::string*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testBinary", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testBinary");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testBinary");
  }

  oprot->writeMessageBegin("testBinary", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testBinary", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testBinary(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testBinary_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testBinary", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testBinary");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testBinary");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testBinary", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testBinary");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::string& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testBinary;
  iface_->testBinary(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testBinary(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::string& _return)
{
  ThriftTest_testBinary_presult result;
  result.success = const_cast<std::string*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testBinary", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testBinary");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testBinary");
  }

  oprot->writeMessageBegin("testBinary", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testBinary", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testStruct(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testStruct(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testStruct_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStruct", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStruct");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testStruct");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testStruct", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testStruct");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const Xtruct& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testStruct;
  iface_->testStruct(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testStruct(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const Xtruct& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testStruct(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testStruct_presult result;
  result.success = const_cast<Xtruct*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStruct", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStruct");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testStruct");
  }

  oprot->writeMessageBegin("testStruct", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testStruct", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testStruct(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testStruct_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStruct", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStruct");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testStruct");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testStruct", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testStruct");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const Xtruct& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testStruct;
  iface_->testStruct(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testStruct(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const Xtruct& _return)
{
  ThriftTest_testStruct_presult result;
  result.success = const_cast<Xtruct*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStruct", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStruct");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testStruct");
  }

  oprot->writeMessageBegin("testStruct", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testStruct", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testNest(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testNest(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testNest_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testNest", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testNest");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testNest");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testNest", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testNest");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const Xtruct2& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testNest;
  iface_->testNest(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testNest(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const Xtruct2& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testNest(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testNest_presult result;
  result.success = const_cast<Xtruct2*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testNest", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testNest");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testNest");
  }

  oprot->writeMessageBegin("testNest", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testNest", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testNest(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testNest_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testNest", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testNest");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testNest");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testNest", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testNest");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const Xtruct2& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testNest;
  iface_->testNest(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testNest(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const Xtruct2& _return)
{
  ThriftTest_testNest_presult result;
  result.success = const_cast<Xtruct2*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testNest", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testNest");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testNest");
  }

  oprot->writeMessageBegin("testNest", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testNest", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testMap(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testMap(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testMap_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMap");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testMap");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testMap", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMap");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<int32_t, int32_t> & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testMap;
  iface_->testMap(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testMap(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<int32_t, int32_t> & _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testMap(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testMap_presult result;
  result.success = const_cast<std::map<int32_t, int32_t> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMap");
  }

  oprot->writeMessageBegin("testMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMap", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testMap(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testMap_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMap");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testMap");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testMap", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMap");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::map<int32_t, int32_t> & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testMap;
  iface_->testMap(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testMap(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::map<int32_t, int32_t> & _return)
{
  ThriftTest_testMap_presult result;
  result.success = const_cast<std::map<int32_t, int32_t> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMap");
  }

  oprot->writeMessageBegin("testMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMap", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testStringMap(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testStringMap(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testStringMap_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStringMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStringMap");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testStringMap");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testStringMap", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testStringMap");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<std::string, std::string> & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testStringMap;
  iface_->testStringMap(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testStringMap(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<std::string, std::string> & _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testStringMap(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testStringMap_presult result;
  result.success = const_cast<std::map<std::string, std::string> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStringMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStringMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testStringMap");
  }

  oprot->writeMessageBegin("testStringMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testStringMap", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testStringMap(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testStringMap_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStringMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStringMap");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testStringMap");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testStringMap", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testStringMap");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::map<std::string, std::string> & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testStringMap;
  iface_->testStringMap(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testStringMap(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::map<std::string, std::string> & _return)
{
  ThriftTest_testStringMap_presult result;
  result.success = const_cast<std::map<std::string, std::string> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStringMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStringMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testStringMap");
  }

  oprot->writeMessageBegin("testStringMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testStringMap", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testSet(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testSet(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testSet_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testSet", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testSet");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testSet");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testSet", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testSet");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::set<int32_t> & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testSet;
  iface_->testSet(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testSet(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::set<int32_t> & _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testSet(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testSet_presult result;
  result.success = const_cast<std::set<int32_t> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testSet", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testSet");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testSet");
  }

  oprot->writeMessageBegin("testSet", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testSet", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testSet(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testSet_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testSet", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testSet");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testSet");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testSet", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testSet");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::set<int32_t> & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testSet;
  iface_->testSet(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testSet(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::set<int32_t> & _return)
{
  ThriftTest_testSet_presult result;
  result.success = const_cast<std::set<int32_t> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testSet", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testSet");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testSet");
  }

  oprot->writeMessageBegin("testSet", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testSet", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testList(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testList(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testList_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testList", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testList");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testList");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testList", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testList");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::vector<int32_t> & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testList;
  iface_->testList(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testList(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::vector<int32_t> & _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testList(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testList_presult result;
  result.success = const_cast<std::vector<int32_t> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testList", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testList");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testList");
  }

  oprot->writeMessageBegin("testList", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testList", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testList(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testList_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testList", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testList");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testList");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testList", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testList");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::vector<int32_t> & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testList;
  iface_->testList(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testList(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::vector<int32_t> & _return)
{
  ThriftTest_testList_presult result;
  result.success = const_cast<std::vector<int32_t> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testList", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testList");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testList");
  }

  oprot->writeMessageBegin("testList", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testList", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testEnum(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testEnum(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testEnum_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testEnum", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testEnum");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testEnum");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testEnum", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testEnum");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const Numberz::type& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testEnum;
  iface_->testEnum(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testEnum(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const Numberz::type& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testEnum(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testEnum_presult result;
  result.success = const_cast<Numberz::type*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testEnum", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testEnum");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testEnum");
  }

  oprot->writeMessageBegin("testEnum", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testEnum", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testEnum(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testEnum_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testEnum", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testEnum");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testEnum");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testEnum", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testEnum");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const Numberz::type& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testEnum;
  iface_->testEnum(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testEnum(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const Numberz::type& _return)
{
  ThriftTest_testEnum_presult result;
  result.success = const_cast<Numberz::type*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testEnum", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testEnum");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testEnum");
  }

  oprot->writeMessageBegin("testEnum", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testEnum", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testTypedef(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testTypedef(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testTypedef_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testTypedef", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testTypedef");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testTypedef");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testTypedef", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testTypedef");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const UserId& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testTypedef;
  iface_->testTypedef(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testTypedef(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const UserId& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testTypedef(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testTypedef_presult result;
  result.success = const_cast<UserId*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testTypedef", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testTypedef");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testTypedef");
  }

  oprot->writeMessageBegin("testTypedef", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testTypedef", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testTypedef(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testTypedef_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testTypedef", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testTypedef");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testTypedef");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testTypedef", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testTypedef");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const UserId& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testTypedef;
  iface_->testTypedef(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testTypedef(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const UserId& _return)
{
  ThriftTest_testTypedef_presult result;
  result.success = const_cast<UserId*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testTypedef", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testTypedef");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testTypedef");
  }

  oprot->writeMessageBegin("testTypedef", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testTypedef", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testMapMap(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testMapMap(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testMapMap_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMapMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMapMap");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testMapMap");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testMapMap", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMapMap");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<int32_t, std::map<int32_t, int32_t> > & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testMapMap;
  iface_->testMapMap(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.hello);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testMapMap(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<int32_t, std::map<int32_t, int32_t> > & _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testMapMap(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testMapMap_presult result;
  result.success = const_cast<std::map<int32_t, std::map<int32_t, int32_t> > *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMapMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMapMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMapMap");
  }

  oprot->writeMessageBegin("testMapMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMapMap", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testMapMap(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testMapMap_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMapMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMapMap");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testMapMap");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testMapMap", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMapMap");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::map<int32_t, std::map<int32_t, int32_t> > & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testMapMap;
  iface_->testMapMap(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.hello);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testMapMap(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::map<int32_t, std::map<int32_t, int32_t> > & _return)
{
  ThriftTest_testMapMap_presult result;
  result.success = const_cast<std::map<int32_t, std::map<int32_t, int32_t> > *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMapMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMapMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMapMap");
  }

  oprot->writeMessageBegin("testMapMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMapMap", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testInsanity(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testInsanity(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testInsanity_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testInsanity", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testInsanity");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testInsanity");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testInsanity", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testInsanity");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<UserId, std::map<Numberz::type, Insanity> > & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testInsanity;
  iface_->testInsanity(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.argument);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testInsanity(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<UserId, std::map<Numberz::type, Insanity> > & _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testInsanity(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testInsanity_presult result;
  result.success = const_cast<std::map<UserId, std::map<Numberz::type, Insanity> > *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testInsanity", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testInsanity");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testInsanity");
  }

  oprot->writeMessageBegin("testInsanity", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testInsanity", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testInsanity(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testInsanity_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testInsanity", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testInsanity");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testInsanity");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testInsanity", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testInsanity");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::map<UserId, std::map<Numberz::type, Insanity> > & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testInsanity;
  iface_->testInsanity(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.argument);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testInsanity(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::map<UserId, std::map<Numberz::type, Insanity> > & _return)
{
  ThriftTest_testInsanity_presult result;
  result.success = const_cast<std::map<UserId, std::map<Numberz::type, Insanity> > *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testInsanity", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testInsanity");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testInsanity");
  }

  oprot->writeMessageBegin("testInsanity", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testInsanity", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testMulti(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testMulti(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testMulti_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMulti", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMulti");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testMulti");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testMulti", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMulti");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const Xtruct& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testMulti;
  iface_->testMulti(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.arg0,
      args.arg1,
      args.arg2,
      args.arg3,
      args.arg4,
      args.arg5);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testMulti(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const Xtruct& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testMulti(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testMulti_presult result;
  result.success = const_cast<Xtruct*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMulti", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMulti");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMulti");
  }

  oprot->writeMessageBegin("testMulti", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMulti", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testMulti(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testMulti_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMulti", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMulti");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testMulti");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testMulti", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMulti");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const Xtruct& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testMulti;
  iface_->testMulti(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.arg0,
      args.arg1,
      args.arg2,
      args.arg3,
      args.arg4,
      args.arg5);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testMulti(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const Xtruct& _return)
{
  ThriftTest_testMulti_presult result;
  result.success = const_cast<Xtruct*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMulti", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMulti");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMulti");
  }

  oprot->writeMessageBegin("testMulti", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMulti", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testException(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testException(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testException_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testException");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testException");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testException", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testException");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testException;
  void (ThriftTestAsyncProcessorT<Protocol_>::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &ThriftTestAsyncProcessorT<Protocol_>::throw_testException;
  iface_->testException(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.arg);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testException(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testException(cob, seqid, _oprot, ctx);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testException_presult result;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testException");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testException");
  }

  oprot->writeMessageBegin("testException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testException", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::throw_testException(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return throw_testException(cob, seqid, _oprot, ctx, _throw);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);


  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testException");

  ThriftTest_testException_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (Xception &err1) {
    result.err1 = err1;
    result.__isset.err1 = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testException");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testException", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testException");
  }

  oprot->writeMessageBegin("testException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testException", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testException(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testException_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testException");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testException");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testException", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testException");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testException;
  void (ThriftTestAsyncProcessorT<Protocol_>::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &ThriftTestAsyncProcessorT<Protocol_>::throw_testException;
  iface_->testException(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.arg);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testException(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx)
{
  ThriftTest_testException_presult result;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testException");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testException");
  }

  oprot->writeMessageBegin("testException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testException", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::throw_testException(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testException");

  ThriftTest_testException_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (Xception &err1) {
    result.err1 = err1;
    result.__isset.err1 = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testException");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testException", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testException");
  }

  oprot->writeMessageBegin("testException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testException", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testMultiException(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testMultiException(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testMultiException_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMultiException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMultiException");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testMultiException");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testMultiException", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMultiException");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const Xtruct& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testMultiException;
  void (ThriftTestAsyncProcessorT<Protocol_>::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &ThriftTestAsyncProcessorT<Protocol_>::throw_testMultiException;
  iface_->testMultiException(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.arg0,
      args.arg1);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testMultiException(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const Xtruct& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testMultiException(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testMultiException_presult result;
  result.success = const_cast<Xtruct*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMultiException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMultiException");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMultiException");
  }

  oprot->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMultiException", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::throw_testMultiException(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return throw_testMultiException(cob, seqid, _oprot, ctx, _throw);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);


  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMultiException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMultiException");

  ThriftTest_testMultiException_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (Xception &err1) {
    result.err1 = err1;
    result.__isset.err1 = true;
  }
  catch (Xception2 &err2) {
    result.err2 = err2;
    result.__isset.err2 = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMultiException");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMultiException");
  }

  oprot->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMultiException", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testMultiException(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testMultiException_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMultiException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMultiException");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testMultiException");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testMultiException", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMultiException");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const Xtruct& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testMultiException;
  void (ThriftTestAsyncProcessorT<Protocol_>::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &ThriftTestAsyncProcessorT<Protocol_>::throw_testMultiException;
  iface_->testMultiException(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.arg0,
      args.arg1);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testMultiException(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const Xtruct& _return)
{
  ThriftTest_testMultiException_presult result;
  result.success = const_cast<Xtruct*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMultiException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMultiException");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMultiException");
  }

  oprot->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMultiException", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::throw_testMultiException(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMultiException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMultiException");

  ThriftTest_testMultiException_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (Xception &err1) {
    result.err1 = err1;
    result.__isset.err1 = true;
  }
  catch (Xception2 &err2) {
    result.err2 = err2;
    result.__isset.err2 = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMultiException");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMultiException");
  }

  oprot->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMultiException", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testOneway(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testOneway(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  (void) seqid;
  (void) oprot;
  ThriftTest_testOneway_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testOneway", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testOneway");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testOneway");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testOneway", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testOneway");
    }
    return cob(false);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "ThriftTest.testOneway");
  }
  freer.unregister();
  iface_->testOneway(tcxx::bind(cob, true)
,
      args.secondsToSleep);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testOneway(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  (void) seqid;
  (void) oprot;
  ThriftTest_testOneway_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testOneway", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testOneway");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testOneway");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testOneway", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testOneway");
    }
    return cob(false);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "ThriftTest.testOneway");
  }
  freer.unregister();
  iface_->testOneway(tcxx::bind(cob, true)
,
      args.secondsToSleep);
}

template <class Protocol_>
::boost::shared_ptr< ::apache::thrift::async::TAsyncProcessor > ThriftTestAsyncProcessorFactoryT<Protocol_>::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< ThriftTestCobSvIfFactory > cleanup(handlerFactory_);
  ::boost::shared_ptr< ThriftTestCobSvIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::boost::shared_ptr< ::apache::thrift::async::TAsyncProcessor > processor(new ThriftTestAsyncProcessorT<Protocol_>(handler));
  return processor;
}

}} // namespace

#endif
