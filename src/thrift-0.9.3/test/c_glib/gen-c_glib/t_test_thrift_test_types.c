/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "t_test_thrift_test_types.h"
#include <thrift/c_glib/thrift.h>

/* return the name of the constant */
const char *
toString_Numberz(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case T_TEST_NUMBERZ_ONE:return "T_TEST_NUMBERZ_ONE";
  case T_TEST_NUMBERZ_TWO:return "T_TEST_NUMBERZ_TWO";
  case T_TEST_NUMBERZ_THREE:return "T_TEST_NUMBERZ_THREE";
  case T_TEST_NUMBERZ_FIVE:return "T_TEST_NUMBERZ_FIVE";
  case T_TEST_NUMBERZ_SIX:return "T_TEST_NUMBERZ_SIX";
  case T_TEST_NUMBERZ_EIGHT:return "T_TEST_NUMBERZ_EIGHT";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

enum _TTestBonkProperties
{
  PROP_T_TEST_BONK_0,
  PROP_T_TEST_BONK_MESSAGE,
  PROP_T_TEST_BONK_TYPE
};

/* reads a bonk object */
static gint32
t_test_bonk_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestBonk * this_object = T_TEST_BONK(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->message != NULL)
          {
            g_free(this_object->message);
            this_object->message = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->message, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_message = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->type, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_bonk_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestBonk * this_object = T_TEST_BONK(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Bonk", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->message, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->type, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_bonk_set_property (GObject *object,
                          guint property_id,
                          const GValue *value,
                          GParamSpec *pspec)
{
  TTestBonk *self = T_TEST_BONK (object);

  switch (property_id)
  {
    case PROP_T_TEST_BONK_MESSAGE:
      if (self->message != NULL)
        g_free (self->message);
      self->message = g_value_dup_string (value);
      self->__isset_message = TRUE;
      break;

    case PROP_T_TEST_BONK_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_bonk_get_property (GObject *object,
                          guint property_id,
                          GValue *value,
                          GParamSpec *pspec)
{
  TTestBonk *self = T_TEST_BONK (object);

  switch (property_id)
  {
    case PROP_T_TEST_BONK_MESSAGE:
      g_value_set_string (value, self->message);
      break;

    case PROP_T_TEST_BONK_TYPE:
      g_value_set_int (value, self->type);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_bonk_instance_init (TTestBonk * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->message = NULL;
  object->__isset_message = FALSE;
  object->type = 0;
  object->__isset_type = FALSE;
}

static void 
t_test_bonk_finalize (GObject *object)
{
  TTestBonk *tobject = T_TEST_BONK (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->message != NULL)
  {
    g_free(tobject->message);
    tobject->message = NULL;
  }
}

static void
t_test_bonk_class_init (TTestBonkClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_bonk_read;
  struct_class->write = t_test_bonk_write;

  gobject_class->finalize = t_test_bonk_finalize;
  gobject_class->get_property = t_test_bonk_get_property;
  gobject_class->set_property = t_test_bonk_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_BONK_MESSAGE,
     g_param_spec_string ("message",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_BONK_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
t_test_bonk_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestBonkClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_bonk_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestBonk),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_bonk_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestBonkType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestBoolsProperties
{
  PROP_T_TEST_BOOLS_0,
  PROP_T_TEST_BOOLS_IM_TRUE,
  PROP_T_TEST_BOOLS_IM_FALSE
};

/* reads a bools object */
static gint32
t_test_bools_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestBools * this_object = T_TEST_BOOLS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->im_true, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_im_true = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->im_false, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_im_false = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_bools_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestBools * this_object = T_TEST_BOOLS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Bools", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "im_true", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->im_true, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "im_false", T_BOOL, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->im_false, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_bools_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  TTestBools *self = T_TEST_BOOLS (object);

  switch (property_id)
  {
    case PROP_T_TEST_BOOLS_IM_TRUE:
      self->im_true = g_value_get_boolean (value);
      self->__isset_im_true = TRUE;
      break;

    case PROP_T_TEST_BOOLS_IM_FALSE:
      self->im_false = g_value_get_boolean (value);
      self->__isset_im_false = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_bools_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  TTestBools *self = T_TEST_BOOLS (object);

  switch (property_id)
  {
    case PROP_T_TEST_BOOLS_IM_TRUE:
      g_value_set_boolean (value, self->im_true);
      break;

    case PROP_T_TEST_BOOLS_IM_FALSE:
      g_value_set_boolean (value, self->im_false);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_bools_instance_init (TTestBools * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->im_true = 0;
  object->__isset_im_true = FALSE;
  object->im_false = 0;
  object->__isset_im_false = FALSE;
}

static void 
t_test_bools_finalize (GObject *object)
{
  TTestBools *tobject = T_TEST_BOOLS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_bools_class_init (TTestBoolsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_bools_read;
  struct_class->write = t_test_bools_write;

  gobject_class->finalize = t_test_bools_finalize;
  gobject_class->get_property = t_test_bools_get_property;
  gobject_class->set_property = t_test_bools_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_BOOLS_IM_TRUE,
     g_param_spec_boolean ("im_true",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_BOOLS_IM_FALSE,
     g_param_spec_boolean ("im_false",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
t_test_bools_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestBoolsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_bools_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestBools),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_bools_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestBoolsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestXtructProperties
{
  PROP_T_TEST_XTRUCT_0,
  PROP_T_TEST_XTRUCT_STRING_THING,
  PROP_T_TEST_XTRUCT_BYTE_THING,
  PROP_T_TEST_XTRUCT_I32_THING,
  PROP_T_TEST_XTRUCT_I64_THING
};

/* reads a xtruct object */
static gint32
t_test_xtruct_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestXtruct * this_object = T_TEST_XTRUCT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->string_thing != NULL)
          {
            g_free(this_object->string_thing);
            this_object->string_thing = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->string_thing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_string_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->byte_thing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_byte_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->i32_thing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_i32_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->i64_thing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_i64_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_xtruct_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestXtruct * this_object = T_TEST_XTRUCT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Xtruct", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "string_thing", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->string_thing, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_thing", T_BYTE, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->byte_thing, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i32_thing", T_I32, 9, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->i32_thing, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i64_thing", T_I64, 11, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->i64_thing, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_xtruct_set_property (GObject *object,
                            guint property_id,
                            const GValue *value,
                            GParamSpec *pspec)
{
  TTestXtruct *self = T_TEST_XTRUCT (object);

  switch (property_id)
  {
    case PROP_T_TEST_XTRUCT_STRING_THING:
      if (self->string_thing != NULL)
        g_free (self->string_thing);
      self->string_thing = g_value_dup_string (value);
      self->__isset_string_thing = TRUE;
      break;

    case PROP_T_TEST_XTRUCT_BYTE_THING:
      self->byte_thing = g_value_get_int (value);
      self->__isset_byte_thing = TRUE;
      break;

    case PROP_T_TEST_XTRUCT_I32_THING:
      self->i32_thing = g_value_get_int (value);
      self->__isset_i32_thing = TRUE;
      break;

    case PROP_T_TEST_XTRUCT_I64_THING:
      self->i64_thing = g_value_get_int64 (value);
      self->__isset_i64_thing = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_xtruct_get_property (GObject *object,
                            guint property_id,
                            GValue *value,
                            GParamSpec *pspec)
{
  TTestXtruct *self = T_TEST_XTRUCT (object);

  switch (property_id)
  {
    case PROP_T_TEST_XTRUCT_STRING_THING:
      g_value_set_string (value, self->string_thing);
      break;

    case PROP_T_TEST_XTRUCT_BYTE_THING:
      g_value_set_int (value, self->byte_thing);
      break;

    case PROP_T_TEST_XTRUCT_I32_THING:
      g_value_set_int (value, self->i32_thing);
      break;

    case PROP_T_TEST_XTRUCT_I64_THING:
      g_value_set_int64 (value, self->i64_thing);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_xtruct_instance_init (TTestXtruct * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->string_thing = NULL;
  object->__isset_string_thing = FALSE;
  object->byte_thing = 0;
  object->__isset_byte_thing = FALSE;
  object->i32_thing = 0;
  object->__isset_i32_thing = FALSE;
  object->i64_thing = 0;
  object->__isset_i64_thing = FALSE;
}

static void 
t_test_xtruct_finalize (GObject *object)
{
  TTestXtruct *tobject = T_TEST_XTRUCT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->string_thing != NULL)
  {
    g_free(tobject->string_thing);
    tobject->string_thing = NULL;
  }
}

static void
t_test_xtruct_class_init (TTestXtructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_xtruct_read;
  struct_class->write = t_test_xtruct_write;

  gobject_class->finalize = t_test_xtruct_finalize;
  gobject_class->get_property = t_test_xtruct_get_property;
  gobject_class->set_property = t_test_xtruct_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_XTRUCT_STRING_THING,
     g_param_spec_string ("string_thing",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_XTRUCT_BYTE_THING,
     g_param_spec_int ("byte_thing",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_XTRUCT_I32_THING,
     g_param_spec_int ("i32_thing",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_XTRUCT_I64_THING,
     g_param_spec_int64 ("i64_thing",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
t_test_xtruct_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestXtructClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_xtruct_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestXtruct),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_xtruct_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestXtructType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestXtruct2Properties
{
  PROP_T_TEST_XTRUCT2_0,
  PROP_T_TEST_XTRUCT2_BYTE_THING,
  PROP_T_TEST_XTRUCT2_STRUCT_THING,
  PROP_T_TEST_XTRUCT2_I32_THING
};

/* reads a xtruct2 object */
static gint32
t_test_xtruct2_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestXtruct2 * this_object = T_TEST_XTRUCT2(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->byte_thing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_byte_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->struct_thing), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_struct_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->i32_thing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_i32_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_xtruct2_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestXtruct2 * this_object = T_TEST_XTRUCT2(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Xtruct2", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "byte_thing", T_BYTE, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->byte_thing, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "struct_thing", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->struct_thing), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i32_thing", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->i32_thing, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_xtruct2_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  TTestXtruct2 *self = T_TEST_XTRUCT2 (object);

  switch (property_id)
  {
    case PROP_T_TEST_XTRUCT2_BYTE_THING:
      self->byte_thing = g_value_get_int (value);
      self->__isset_byte_thing = TRUE;
      break;

    case PROP_T_TEST_XTRUCT2_STRUCT_THING:
      if (self->struct_thing != NULL)
        g_object_unref (self->struct_thing);
      self->struct_thing = g_value_dup_object (value);
      self->__isset_struct_thing = TRUE;
      break;

    case PROP_T_TEST_XTRUCT2_I32_THING:
      self->i32_thing = g_value_get_int (value);
      self->__isset_i32_thing = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_xtruct2_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  TTestXtruct2 *self = T_TEST_XTRUCT2 (object);

  switch (property_id)
  {
    case PROP_T_TEST_XTRUCT2_BYTE_THING:
      g_value_set_int (value, self->byte_thing);
      break;

    case PROP_T_TEST_XTRUCT2_STRUCT_THING:
      g_value_set_object (value, self->struct_thing);
      break;

    case PROP_T_TEST_XTRUCT2_I32_THING:
      g_value_set_int (value, self->i32_thing);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_xtruct2_instance_init (TTestXtruct2 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->byte_thing = 0;
  object->__isset_byte_thing = FALSE;
  object->struct_thing = g_object_new (T_TEST_TYPE_XTRUCT, NULL);
  object->__isset_struct_thing = FALSE;
  object->i32_thing = 0;
  object->__isset_i32_thing = FALSE;
}

static void 
t_test_xtruct2_finalize (GObject *object)
{
  TTestXtruct2 *tobject = T_TEST_XTRUCT2 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->struct_thing != NULL)
  {
    g_object_unref(tobject->struct_thing);
    tobject->struct_thing = NULL;
  }
}

static void
t_test_xtruct2_class_init (TTestXtruct2Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_xtruct2_read;
  struct_class->write = t_test_xtruct2_write;

  gobject_class->finalize = t_test_xtruct2_finalize;
  gobject_class->get_property = t_test_xtruct2_get_property;
  gobject_class->set_property = t_test_xtruct2_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_XTRUCT2_BYTE_THING,
     g_param_spec_int ("byte_thing",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_XTRUCT2_STRUCT_THING,
     g_param_spec_object ("struct_thing",
                         NULL,
                         NULL,
                         T_TEST_TYPE_XTRUCT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_XTRUCT2_I32_THING,
     g_param_spec_int ("i32_thing",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
t_test_xtruct2_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestXtruct2Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_xtruct2_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestXtruct2),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_xtruct2_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestXtruct2Type",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestXtruct3Properties
{
  PROP_T_TEST_XTRUCT3_0,
  PROP_T_TEST_XTRUCT3_STRING_THING,
  PROP_T_TEST_XTRUCT3_CHANGED,
  PROP_T_TEST_XTRUCT3_I32_THING,
  PROP_T_TEST_XTRUCT3_I64_THING
};

/* reads a xtruct3 object */
static gint32
t_test_xtruct3_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestXtruct3 * this_object = T_TEST_XTRUCT3(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->string_thing != NULL)
          {
            g_free(this_object->string_thing);
            this_object->string_thing = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->string_thing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_string_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->changed, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_changed = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->i32_thing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_i32_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->i64_thing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_i64_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_xtruct3_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestXtruct3 * this_object = T_TEST_XTRUCT3(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Xtruct3", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "string_thing", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->string_thing, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "changed", T_I32, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->changed, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i32_thing", T_I32, 9, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->i32_thing, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "i64_thing", T_I64, 11, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->i64_thing, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_xtruct3_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  TTestXtruct3 *self = T_TEST_XTRUCT3 (object);

  switch (property_id)
  {
    case PROP_T_TEST_XTRUCT3_STRING_THING:
      if (self->string_thing != NULL)
        g_free (self->string_thing);
      self->string_thing = g_value_dup_string (value);
      self->__isset_string_thing = TRUE;
      break;

    case PROP_T_TEST_XTRUCT3_CHANGED:
      self->changed = g_value_get_int (value);
      self->__isset_changed = TRUE;
      break;

    case PROP_T_TEST_XTRUCT3_I32_THING:
      self->i32_thing = g_value_get_int (value);
      self->__isset_i32_thing = TRUE;
      break;

    case PROP_T_TEST_XTRUCT3_I64_THING:
      self->i64_thing = g_value_get_int64 (value);
      self->__isset_i64_thing = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_xtruct3_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  TTestXtruct3 *self = T_TEST_XTRUCT3 (object);

  switch (property_id)
  {
    case PROP_T_TEST_XTRUCT3_STRING_THING:
      g_value_set_string (value, self->string_thing);
      break;

    case PROP_T_TEST_XTRUCT3_CHANGED:
      g_value_set_int (value, self->changed);
      break;

    case PROP_T_TEST_XTRUCT3_I32_THING:
      g_value_set_int (value, self->i32_thing);
      break;

    case PROP_T_TEST_XTRUCT3_I64_THING:
      g_value_set_int64 (value, self->i64_thing);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_xtruct3_instance_init (TTestXtruct3 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->string_thing = NULL;
  object->__isset_string_thing = FALSE;
  object->changed = 0;
  object->__isset_changed = FALSE;
  object->i32_thing = 0;
  object->__isset_i32_thing = FALSE;
  object->i64_thing = 0;
  object->__isset_i64_thing = FALSE;
}

static void 
t_test_xtruct3_finalize (GObject *object)
{
  TTestXtruct3 *tobject = T_TEST_XTRUCT3 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->string_thing != NULL)
  {
    g_free(tobject->string_thing);
    tobject->string_thing = NULL;
  }
}

static void
t_test_xtruct3_class_init (TTestXtruct3Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_xtruct3_read;
  struct_class->write = t_test_xtruct3_write;

  gobject_class->finalize = t_test_xtruct3_finalize;
  gobject_class->get_property = t_test_xtruct3_get_property;
  gobject_class->set_property = t_test_xtruct3_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_XTRUCT3_STRING_THING,
     g_param_spec_string ("string_thing",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_XTRUCT3_CHANGED,
     g_param_spec_int ("changed",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_XTRUCT3_I32_THING,
     g_param_spec_int ("i32_thing",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_XTRUCT3_I64_THING,
     g_param_spec_int64 ("i64_thing",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
t_test_xtruct3_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestXtruct3Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_xtruct3_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestXtruct3),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_xtruct3_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestXtruct3Type",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestInsanityProperties
{
  PROP_T_TEST_INSANITY_0,
  PROP_T_TEST_INSANITY_USER_MAP,
  PROP_T_TEST_INSANITY_XTRUCTS
};

/* reads a insanity object */
static gint32
t_test_insanity_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestInsanity * this_object = T_TEST_INSANITY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              TTestNumberz key0;
              TTestUserId* val1 = g_new (TTestUserId, 1);
              gint32 ecast2;
              if ((ret = thrift_protocol_read_i32 (protocol, &ecast2, error)) < 0)
                return -1;
              xfer += ret;
              key0 = (TTestNumberz)ecast2;
              if ((ret = thrift_protocol_read_i64 (protocol, &*val1, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->userMap, (gpointer) key0, (gpointer) val1);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_userMap = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TTestXtruct * _elem3 = NULL;
              if ( _elem3 != NULL)
              {
                g_object_unref (_elem3);
              }
              _elem3 = g_object_new (T_TEST_TYPE_XTRUCT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem3), protocol, error)) < 0)
              {
                g_object_unref (_elem3);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->xtructs, _elem3);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_xtructs = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_insanity_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestInsanity * this_object = T_TEST_INSANITY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Insanity", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "userMap", T_MAP, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    TTestNumberz key4;
    TTestUserId* val5 = g_new (TTestUserId, 1);
    GList *key_list = NULL, *iter = NULL;
    TTestNumberz* keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_I64, (gint32) g_hash_table_size ((GHashTable *) this_object->userMap), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->userMap, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (TTestNumberz, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (TTestNumberz) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key4 = keys[i];
      val5 = (TTestUserId*) g_hash_table_lookup (((GHashTable *) this_object->userMap), (gpointer) key4);

      if ((ret = thrift_protocol_write_i32 (protocol, (gint32)  key4, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_i64 (protocol, * val5, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "xtructs", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i6;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->xtructs->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i6 = 0; i6 < this_object->xtructs->len; i6++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->xtructs, i6))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_insanity_set_property (GObject *object,
                              guint property_id,
                              const GValue *value,
                              GParamSpec *pspec)
{
  TTestInsanity *self = T_TEST_INSANITY (object);

  switch (property_id)
  {
    case PROP_T_TEST_INSANITY_USER_MAP:
      if (self->userMap != NULL)
        g_hash_table_unref (self->userMap);
      self->userMap = g_value_dup_boxed (value);
      self->__isset_userMap = TRUE;
      break;

    case PROP_T_TEST_INSANITY_XTRUCTS:
      if (self->xtructs != NULL)
        g_ptr_array_unref (self->xtructs);
      self->xtructs = g_value_dup_boxed (value);
      self->__isset_xtructs = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_insanity_get_property (GObject *object,
                              guint property_id,
                              GValue *value,
                              GParamSpec *pspec)
{
  TTestInsanity *self = T_TEST_INSANITY (object);

  switch (property_id)
  {
    case PROP_T_TEST_INSANITY_USER_MAP:
      g_value_set_boxed (value, self->userMap);
      break;

    case PROP_T_TEST_INSANITY_XTRUCTS:
      g_value_set_boxed (value, self->xtructs);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_insanity_instance_init (TTestInsanity * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->userMap = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_free);
  object->__isset_userMap = FALSE;
  object->xtructs = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_xtructs = FALSE;
}

static void 
t_test_insanity_finalize (GObject *object)
{
  TTestInsanity *tobject = T_TEST_INSANITY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->userMap != NULL)
  {
    g_hash_table_destroy (tobject->userMap);
    tobject->userMap = NULL;
  }
  if (tobject->xtructs != NULL)
  {
    g_ptr_array_unref (tobject->xtructs);
    tobject->xtructs = NULL;
  }
}

static void
t_test_insanity_class_init (TTestInsanityClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_insanity_read;
  struct_class->write = t_test_insanity_write;

  gobject_class->finalize = t_test_insanity_finalize;
  gobject_class->get_property = t_test_insanity_get_property;
  gobject_class->set_property = t_test_insanity_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_INSANITY_USER_MAP,
     g_param_spec_boxed ("userMap",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_INSANITY_XTRUCTS,
     g_param_spec_boxed ("xtructs",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_test_insanity_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestInsanityClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_insanity_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestInsanity),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_insanity_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestInsanityType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestCrazyNestingProperties
{
  PROP_T_TEST_CRAZY_NESTING_0,
  PROP_T_TEST_CRAZY_NESTING_STRING_FIELD,
  PROP_T_TEST_CRAZY_NESTING_SET_FIELD,
  PROP_T_TEST_CRAZY_NESTING_LIST_FIELD,
  PROP_T_TEST_CRAZY_NESTING_BINARY_FIELD
};

/* reads a crazy_nesting object */
static gint32
t_test_crazy_nesting_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestCrazyNesting * this_object = T_TEST_CRAZY_NESTING(object);
  gboolean isset_list_field = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->string_field != NULL)
          {
            g_free(this_object->string_field);
            this_object->string_field = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->string_field, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_string_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            for (i = 0; i < size; ++i)
            {
              TTestInsanity * _elem7 = NULL;
              if ( _elem7 != NULL)
              {
                g_object_unref (_elem7);
              }
              _elem7 = g_object_new (T_TEST_TYPE_INSANITY, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem7), protocol, error)) < 0)
              {
                g_object_unref (_elem7);
                return -1;
              }
              xfer += ret;
              g_hash_table_insert ((GHashTable *) this_object->set_field, (gpointer) _elem7, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_set_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GHashTable * _elem8 = g_hash_table_new_full (g_direct_hash, g_direct_equal, (GDestroyNotify) g_hash_table_destroy, (GDestroyNotify) g_hash_table_destroy);
              {
                guint32 size;
                guint32 i;
                ThriftType key_type;
                ThriftType value_type;

                /* read the map begin marker */
                if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through each of the map's fields */
                for (i = 0; i < size; i++)
                {
                  GHashTable * key9 = NULL;
                  GHashTable * val10 = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, (GDestroyNotify) g_hash_table_destroy);
                  {
                    guint32 size;
                    guint32 i;
                    ThriftType element_type;

                    if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
                      return -1;
                    xfer += ret;

                    /* iterate through the set elements */
                    for (i = 0; i < size; ++i)
                    {
                      gint32* _elem11 = g_new (gint32, 1);
                      if ((ret = thrift_protocol_read_i32 (protocol, &*_elem11, error)) < 0)
                        return -1;
                      xfer += ret;
                      g_hash_table_insert ((GHashTable *) key9, (gpointer) _elem11, (gpointer) 1);
                    }
                    if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
                      return -1;
                    xfer += ret;

                  }
                  {
                    guint32 size;
                    guint32 i;
                    ThriftType key_type;
                    ThriftType value_type;

                    /* read the map begin marker */
                    if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                      return -1;
                    xfer += ret;

                    /* iterate through each of the map's fields */
                    for (i = 0; i < size; i++)
                    {
                      gint32* key12 = g_new (gint32, 1);
                      GHashTable * val13 = NULL;
                      if ((ret = thrift_protocol_read_i32 (protocol, &*key12, error)) < 0)
                        return -1;
                      xfer += ret;
                      {
                        guint32 size;
                        guint32 i;
                        ThriftType element_type;

                        if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
                          return -1;
                        xfer += ret;

                        /* iterate through the set elements */
                        for (i = 0; i < size; ++i)
                        {
                          GPtrArray * _elem14 = g_ptr_array_new_with_free_func ((GDestroyNotify) g_hash_table_destroy);
                          {
                            guint32 size;
                            guint32 i;
                            ThriftType element_type;

                            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                              return -1;
                            xfer += ret;

                            /* iterate through list elements */
                            for (i = 0; i < size; i++)
                            {
                              GHashTable * _elem15 = g_hash_table_new_full (g_direct_hash, g_direct_equal, g_object_unref, g_free);
                              {
                                guint32 size;
                                guint32 i;
                                ThriftType key_type;
                                ThriftType value_type;

                                /* read the map begin marker */
                                if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                                  return -1;
                                xfer += ret;

                                /* iterate through each of the map's fields */
                                for (i = 0; i < size; i++)
                                {
                                  TTestInsanity * key16 = NULL;
                                  gchar * val17 = NULL;
                                  if ( key16 != NULL)
                                  {
                                    g_object_unref (key16);
                                  }
                                  key16 = g_object_new (T_TEST_TYPE_INSANITY, NULL);
                                  if ((ret = thrift_struct_read (THRIFT_STRUCT (key16), protocol, error)) < 0)
                                  {
                                    g_object_unref (key16);
                                    return -1;
                                  }
                                  xfer += ret;
                                  if (val17 != NULL)
                                  {
                                    g_free(val17);
                                    val17 = NULL;
                                  }

                                  if ((ret = thrift_protocol_read_string (protocol, &val17, error)) < 0)
                                    return -1;
                                  xfer += ret;
                                  g_hash_table_insert ((GHashTable *)_elem15, (gpointer) key16, (gpointer) val17);
                                }

                                /* read the map end marker */
                                if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                                  return -1;
                                xfer += ret;
                              }
                              g_ptr_array_add (_elem14, _elem15);
                            }
                            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                              return -1;
                            xfer += ret;
                          }
                          g_hash_table_insert ((GHashTable *) val13, (gpointer) _elem14, (gpointer) 1);
                        }
                        if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
                          return -1;
                        xfer += ret;

                      }
                      g_hash_table_insert ((GHashTable *)val10, (gpointer) key12, (gpointer) val13);
                    }

                    /* read the map end marker */
                    if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                      return -1;
                    xfer += ret;
                  }
                  g_hash_table_insert ((GHashTable *)_elem8, (gpointer) key9, (gpointer) val10);
                }

                /* read the map end marker */
                if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              g_ptr_array_add (this_object->list_field, _elem8);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_list_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->binary_field != NULL)
          {
            g_free(this_object->binary_field);
            this_object->binary_field = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->binary_field = g_byte_array_new();
          g_byte_array_append (this_object->binary_field, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_binary_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_list_field)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_test_crazy_nesting_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestCrazyNesting * this_object = T_TEST_CRAZY_NESTING(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CrazyNesting", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "string_field", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->string_field, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_set_field == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "set_field", T_SET, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      GList *key_list = NULL, *iter = NULL;
      TTestInsanity ** keys;
      int i = 0, key_count;
      TTestInsanity * elem;
      gpointer value;
      THRIFT_UNUSED_VAR (value);

      if ((ret = thrift_protocol_write_set_begin (protocol, T_STRUCT, (gint32) g_hash_table_size ((GHashTable *) this_object->set_field), error)) < 0)
        return -1;
      xfer += ret;
      g_hash_table_foreach ((GHashTable *) this_object->set_field, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (TTestInsanity *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (TTestInsanity *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        elem = keys[i];
        value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->set_field), (gpointer) elem);

        if ((ret = thrift_struct_write (THRIFT_STRUCT (elem), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "list_field", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i18;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_MAP, (gint32) this_object->list_field->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i18 = 0; i18 < this_object->list_field->len; i18++)
    {
      {
        GHashTable * key19 = NULL;
        GHashTable * val20 = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, (GDestroyNotify) g_hash_table_destroy);
        GList *key_list = NULL, *iter = NULL;
        GHashTable ** keys;
        int i = 0, key_count;

        if ((ret = thrift_protocol_write_map_begin (protocol, T_SET, T_MAP, (gint32) g_hash_table_size ((GHashTable *) ((GHashTable*)g_ptr_array_index ((GPtrArray *) this_object->list_field, i18))), error)) < 0)
          return -1;
        xfer += ret;
        g_hash_table_foreach ((GHashTable *) ((GHashTable*)g_ptr_array_index ((GPtrArray *) this_object->list_field, i18)), thrift_hash_table_get_keys, &key_list);
        key_count = g_list_length (key_list);
        keys = g_newa (GHashTable *, key_count);
        for (iter = g_list_first (key_list); iter; iter = iter->next)
          keys[i++] = (GHashTable *) iter->data;
        g_list_free (key_list);

        for (i = 0; i < key_count; ++i)
        {
          key19 = keys[i];
          val20 = (GHashTable *) g_hash_table_lookup (((GHashTable *) ((GHashTable*)g_ptr_array_index ((GPtrArray *) this_object->list_field, i18))), (gpointer) key19);

          {
            GList *key_list = NULL, *iter = NULL;
            gint32** keys;
            int i = 0, key_count;
            gint32* elem;
            gpointer value;
            THRIFT_UNUSED_VAR (value);

            if ((ret = thrift_protocol_write_set_begin (protocol, T_I32, (gint32) g_hash_table_size ((GHashTable *)  key19), error)) < 0)
              return -1;
            xfer += ret;
            g_hash_table_foreach ((GHashTable *)  key19, thrift_hash_table_get_keys, &key_list);
            key_count = g_list_length (key_list);
            keys = g_newa (gint32*, key_count);
            for (iter = g_list_first (key_list); iter; iter = iter->next)
              keys[i++] = (gint32*) iter->data;
            g_list_free (key_list);

            for (i = 0; i < key_count; ++i)
            {
              elem = keys[i];
              value = (gpointer) g_hash_table_lookup (((GHashTable *)  key19), (gpointer) elem);

              if ((ret = thrift_protocol_write_i32 (protocol, *elem, error)) < 0)
                return -1;
            }
            if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          {
            gint32* key21 = g_new (gint32, 1);
            GHashTable * val22 = NULL;
            GList *key_list = NULL, *iter = NULL;
            gint32** keys;
            int i = 0, key_count;

            if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_SET, (gint32) g_hash_table_size ((GHashTable *)  val20), error)) < 0)
              return -1;
            xfer += ret;
            g_hash_table_foreach ((GHashTable *)  val20, thrift_hash_table_get_keys, &key_list);
            key_count = g_list_length (key_list);
            keys = g_newa (gint32*, key_count);
            for (iter = g_list_first (key_list); iter; iter = iter->next)
              keys[i++] = (gint32*) iter->data;
            g_list_free (key_list);

            for (i = 0; i < key_count; ++i)
            {
              key21 = keys[i];
              val22 = (GHashTable *) g_hash_table_lookup (((GHashTable *)  val20), (gpointer) key21);

              if ((ret = thrift_protocol_write_i32 (protocol, * key21, error)) < 0)
                return -1;
              {
                GList *key_list = NULL, *iter = NULL;
                GPtrArray ** keys;
                int i = 0, key_count;
                GPtrArray * elem;
                gpointer value;
                THRIFT_UNUSED_VAR (value);

                if ((ret = thrift_protocol_write_set_begin (protocol, T_LIST, (gint32) g_hash_table_size ((GHashTable *)  val22), error)) < 0)
                  return -1;
                xfer += ret;
                g_hash_table_foreach ((GHashTable *)  val22, thrift_hash_table_get_keys, &key_list);
                key_count = g_list_length (key_list);
                keys = g_newa (GPtrArray *, key_count);
                for (iter = g_list_first (key_list); iter; iter = iter->next)
                  keys[i++] = (GPtrArray *) iter->data;
                g_list_free (key_list);

                for (i = 0; i < key_count; ++i)
                {
                  elem = keys[i];
                  value = (gpointer) g_hash_table_lookup (((GHashTable *)  val22), (gpointer) elem);

                  {
                    guint i23;

                    if ((ret = thrift_protocol_write_list_begin (protocol, T_MAP, (gint32) elem->len, error)) < 0)
                      return -1;
                    xfer += ret;
                    for (i23 = 0; i23 < elem->len; i23++)
                    {
                      {
                        TTestInsanity * key24 = NULL;
                        gchar * val25 = NULL;
                        GList *key_list = NULL, *iter = NULL;
                        TTestInsanity ** keys;
                        int i = 0, key_count;

                        if ((ret = thrift_protocol_write_map_begin (protocol, T_STRUCT, T_STRING, (gint32) g_hash_table_size ((GHashTable *) ((GHashTable*)g_ptr_array_index ((GPtrArray *) elem, i23))), error)) < 0)
                          return -1;
                        xfer += ret;
                        g_hash_table_foreach ((GHashTable *) ((GHashTable*)g_ptr_array_index ((GPtrArray *) elem, i23)), thrift_hash_table_get_keys, &key_list);
                        key_count = g_list_length (key_list);
                        keys = g_newa (TTestInsanity *, key_count);
                        for (iter = g_list_first (key_list); iter; iter = iter->next)
                          keys[i++] = (TTestInsanity *) iter->data;
                        g_list_free (key_list);

                        for (i = 0; i < key_count; ++i)
                        {
                          key24 = keys[i];
                          val25 = (gchar *) g_hash_table_lookup (((GHashTable *) ((GHashTable*)g_ptr_array_index ((GPtrArray *) elem, i23))), (gpointer) key24);

                          if ((ret = thrift_struct_write (THRIFT_STRUCT ( key24), protocol, error)) < 0)
                            return -1;
                          xfer += ret;

                          if ((ret = thrift_protocol_write_string (protocol,  val25, error)) < 0)
                            return -1;
                        }
                        if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
                          return -1;
                        xfer += ret;
                      }
                    }
                    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
                      return -1;
                    xfer += ret;
                  }
                }
                if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
            }
            if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
        }
        if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "binary_field", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->binary_field)->data, ((GByteArray *) this_object->binary_field)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_crazy_nesting_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  TTestCrazyNesting *self = T_TEST_CRAZY_NESTING (object);

  switch (property_id)
  {
    case PROP_T_TEST_CRAZY_NESTING_STRING_FIELD:
      if (self->string_field != NULL)
        g_free (self->string_field);
      self->string_field = g_value_dup_string (value);
      self->__isset_string_field = TRUE;
      break;

    case PROP_T_TEST_CRAZY_NESTING_SET_FIELD:
      if (self->set_field != NULL)
        g_hash_table_unref (self->set_field);
      self->set_field = g_value_dup_boxed (value);
      self->__isset_set_field = TRUE;
      break;

    case PROP_T_TEST_CRAZY_NESTING_LIST_FIELD:
      if (self->list_field != NULL)
        g_ptr_array_unref (self->list_field);
      self->list_field = g_value_dup_boxed (value);
      break;

    case PROP_T_TEST_CRAZY_NESTING_BINARY_FIELD:
      if (self->binary_field != NULL)
        g_byte_array_unref (self->binary_field);
      self->binary_field = g_value_dup_boxed (value);
      self->__isset_binary_field = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_crazy_nesting_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  TTestCrazyNesting *self = T_TEST_CRAZY_NESTING (object);

  switch (property_id)
  {
    case PROP_T_TEST_CRAZY_NESTING_STRING_FIELD:
      g_value_set_string (value, self->string_field);
      break;

    case PROP_T_TEST_CRAZY_NESTING_SET_FIELD:
      g_value_set_boxed (value, self->set_field);
      break;

    case PROP_T_TEST_CRAZY_NESTING_LIST_FIELD:
      g_value_set_boxed (value, self->list_field);
      break;

    case PROP_T_TEST_CRAZY_NESTING_BINARY_FIELD:
      g_value_set_boxed (value, self->binary_field);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_crazy_nesting_instance_init (TTestCrazyNesting * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->string_field = NULL;
  object->__isset_string_field = FALSE;
  object->set_field = g_hash_table_new_full (g_direct_hash, g_direct_equal, g_object_unref, NULL);
  object->__isset_set_field = FALSE;
  object->list_field = g_ptr_array_new_with_free_func ((GDestroyNotify) g_hash_table_destroy);
  object->binary_field = NULL;
  object->__isset_binary_field = FALSE;
}

static void 
t_test_crazy_nesting_finalize (GObject *object)
{
  TTestCrazyNesting *tobject = T_TEST_CRAZY_NESTING (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->string_field != NULL)
  {
    g_free(tobject->string_field);
    tobject->string_field = NULL;
  }
  if (tobject->set_field != NULL)
  {
    g_hash_table_destroy (tobject->set_field);
    tobject->set_field = NULL;
  }
  if (tobject->list_field != NULL)
  {
    g_ptr_array_unref (tobject->list_field);
    tobject->list_field = NULL;
  }
  if (tobject->binary_field != NULL)
  {
    thrift_string_free(tobject->binary_field);
    tobject->binary_field = NULL;
  }
}

static void
t_test_crazy_nesting_class_init (TTestCrazyNestingClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_crazy_nesting_read;
  struct_class->write = t_test_crazy_nesting_write;

  gobject_class->finalize = t_test_crazy_nesting_finalize;
  gobject_class->get_property = t_test_crazy_nesting_get_property;
  gobject_class->set_property = t_test_crazy_nesting_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_CRAZY_NESTING_STRING_FIELD,
     g_param_spec_string ("string_field",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_CRAZY_NESTING_SET_FIELD,
     g_param_spec_boxed ("set_field",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_CRAZY_NESTING_LIST_FIELD,
     g_param_spec_boxed ("list_field",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_CRAZY_NESTING_BINARY_FIELD,
     g_param_spec_boxed ("binary_field",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_test_crazy_nesting_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestCrazyNestingClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_crazy_nesting_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestCrazyNesting),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_crazy_nesting_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestCrazyNestingType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestXceptionProperties
{
  PROP_T_TEST_XCEPTION_0,
  PROP_T_TEST_XCEPTION_ERROR_CODE,
  PROP_T_TEST_XCEPTION_MESSAGE
};

/* reads a xception object */
static gint32
t_test_xception_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestXception * this_object = T_TEST_XCEPTION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->errorCode, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_errorCode = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->message != NULL)
          {
            g_free(this_object->message);
            this_object->message = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->message, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_message = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_xception_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestXception * this_object = T_TEST_XCEPTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Xception", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "errorCode", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->errorCode, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->message, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_xception_set_property (GObject *object,
                              guint property_id,
                              const GValue *value,
                              GParamSpec *pspec)
{
  TTestXception *self = T_TEST_XCEPTION (object);

  switch (property_id)
  {
    case PROP_T_TEST_XCEPTION_ERROR_CODE:
      self->errorCode = g_value_get_int (value);
      self->__isset_errorCode = TRUE;
      break;

    case PROP_T_TEST_XCEPTION_MESSAGE:
      if (self->message != NULL)
        g_free (self->message);
      self->message = g_value_dup_string (value);
      self->__isset_message = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_xception_get_property (GObject *object,
                              guint property_id,
                              GValue *value,
                              GParamSpec *pspec)
{
  TTestXception *self = T_TEST_XCEPTION (object);

  switch (property_id)
  {
    case PROP_T_TEST_XCEPTION_ERROR_CODE:
      g_value_set_int (value, self->errorCode);
      break;

    case PROP_T_TEST_XCEPTION_MESSAGE:
      g_value_set_string (value, self->message);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_xception_instance_init (TTestXception * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->errorCode = 0;
  object->__isset_errorCode = FALSE;
  object->message = NULL;
  object->__isset_message = FALSE;
}

static void 
t_test_xception_finalize (GObject *object)
{
  TTestXception *tobject = T_TEST_XCEPTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->message != NULL)
  {
    g_free(tobject->message);
    tobject->message = NULL;
  }
}

static void
t_test_xception_class_init (TTestXceptionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_xception_read;
  struct_class->write = t_test_xception_write;

  gobject_class->finalize = t_test_xception_finalize;
  gobject_class->get_property = t_test_xception_get_property;
  gobject_class->set_property = t_test_xception_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_XCEPTION_ERROR_CODE,
     g_param_spec_int ("errorCode",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_XCEPTION_MESSAGE,
     g_param_spec_string ("message",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
t_test_xception_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestXceptionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_xception_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestXception),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_xception_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestXceptionType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define T_TEST_XCEPTION_ERROR_DOMAIN "t_test_xception_error_quark"
GQuark
t_test_xception_error_quark (void)
{
  return g_quark_from_static_string (T_TEST_XCEPTION_ERROR_DOMAIN);
}

enum _TTestXception2Properties
{
  PROP_T_TEST_XCEPTION2_0,
  PROP_T_TEST_XCEPTION2_ERROR_CODE,
  PROP_T_TEST_XCEPTION2_STRUCT_THING
};

/* reads a xception2 object */
static gint32
t_test_xception2_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestXception2 * this_object = T_TEST_XCEPTION2(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->errorCode, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_errorCode = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->struct_thing), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_struct_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_xception2_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestXception2 * this_object = T_TEST_XCEPTION2(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Xception2", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "errorCode", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->errorCode, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "struct_thing", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->struct_thing), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_xception2_set_property (GObject *object,
                               guint property_id,
                               const GValue *value,
                               GParamSpec *pspec)
{
  TTestXception2 *self = T_TEST_XCEPTION2 (object);

  switch (property_id)
  {
    case PROP_T_TEST_XCEPTION2_ERROR_CODE:
      self->errorCode = g_value_get_int (value);
      self->__isset_errorCode = TRUE;
      break;

    case PROP_T_TEST_XCEPTION2_STRUCT_THING:
      if (self->struct_thing != NULL)
        g_object_unref (self->struct_thing);
      self->struct_thing = g_value_dup_object (value);
      self->__isset_struct_thing = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_xception2_get_property (GObject *object,
                               guint property_id,
                               GValue *value,
                               GParamSpec *pspec)
{
  TTestXception2 *self = T_TEST_XCEPTION2 (object);

  switch (property_id)
  {
    case PROP_T_TEST_XCEPTION2_ERROR_CODE:
      g_value_set_int (value, self->errorCode);
      break;

    case PROP_T_TEST_XCEPTION2_STRUCT_THING:
      g_value_set_object (value, self->struct_thing);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_xception2_instance_init (TTestXception2 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->errorCode = 0;
  object->__isset_errorCode = FALSE;
  object->struct_thing = g_object_new (T_TEST_TYPE_XTRUCT, NULL);
  object->__isset_struct_thing = FALSE;
}

static void 
t_test_xception2_finalize (GObject *object)
{
  TTestXception2 *tobject = T_TEST_XCEPTION2 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->struct_thing != NULL)
  {
    g_object_unref(tobject->struct_thing);
    tobject->struct_thing = NULL;
  }
}

static void
t_test_xception2_class_init (TTestXception2Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_xception2_read;
  struct_class->write = t_test_xception2_write;

  gobject_class->finalize = t_test_xception2_finalize;
  gobject_class->get_property = t_test_xception2_get_property;
  gobject_class->set_property = t_test_xception2_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_XCEPTION2_ERROR_CODE,
     g_param_spec_int ("errorCode",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_XCEPTION2_STRUCT_THING,
     g_param_spec_object ("struct_thing",
                         NULL,
                         NULL,
                         T_TEST_TYPE_XTRUCT,
                         G_PARAM_READWRITE));
}

GType
t_test_xception2_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestXception2Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_xception2_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestXception2),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_xception2_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestXception2Type",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define T_TEST_XCEPTION2_ERROR_DOMAIN "t_test_xception2_error_quark"
GQuark
t_test_xception2_error_quark (void)
{
  return g_quark_from_static_string (T_TEST_XCEPTION2_ERROR_DOMAIN);
}

/* reads a empty_struct object */
static gint32
t_test_empty_struct_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestEmptyStruct * this_object = T_TEST_EMPTY_STRUCT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_empty_struct_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestEmptyStruct * this_object = T_TEST_EMPTY_STRUCT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "EmptyStruct", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_empty_struct_instance_init (TTestEmptyStruct * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
t_test_empty_struct_finalize (GObject *object)
{
  TTestEmptyStruct *tobject = T_TEST_EMPTY_STRUCT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_empty_struct_class_init (TTestEmptyStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_empty_struct_read;
  struct_class->write = t_test_empty_struct_write;

  gobject_class->finalize = t_test_empty_struct_finalize;
}

GType
t_test_empty_struct_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestEmptyStructClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_empty_struct_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestEmptyStruct),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_empty_struct_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestEmptyStructType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestOneFieldProperties
{
  PROP_T_TEST_ONE_FIELD_0,
  PROP_T_TEST_ONE_FIELD_FIELD
};

/* reads a one_field object */
static gint32
t_test_one_field_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestOneField * this_object = T_TEST_ONE_FIELD(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->field), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_one_field_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestOneField * this_object = T_TEST_ONE_FIELD(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "OneField", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "field", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->field), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_one_field_set_property (GObject *object,
                               guint property_id,
                               const GValue *value,
                               GParamSpec *pspec)
{
  TTestOneField *self = T_TEST_ONE_FIELD (object);

  switch (property_id)
  {
    case PROP_T_TEST_ONE_FIELD_FIELD:
      if (self->field != NULL)
        g_object_unref (self->field);
      self->field = g_value_dup_object (value);
      self->__isset_field = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_one_field_get_property (GObject *object,
                               guint property_id,
                               GValue *value,
                               GParamSpec *pspec)
{
  TTestOneField *self = T_TEST_ONE_FIELD (object);

  switch (property_id)
  {
    case PROP_T_TEST_ONE_FIELD_FIELD:
      g_value_set_object (value, self->field);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_one_field_instance_init (TTestOneField * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->field = g_object_new (T_TEST_TYPE_EMPTY_STRUCT, NULL);
  object->__isset_field = FALSE;
}

static void 
t_test_one_field_finalize (GObject *object)
{
  TTestOneField *tobject = T_TEST_ONE_FIELD (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->field != NULL)
  {
    g_object_unref(tobject->field);
    tobject->field = NULL;
  }
}

static void
t_test_one_field_class_init (TTestOneFieldClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_one_field_read;
  struct_class->write = t_test_one_field_write;

  gobject_class->finalize = t_test_one_field_finalize;
  gobject_class->get_property = t_test_one_field_get_property;
  gobject_class->set_property = t_test_one_field_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_ONE_FIELD_FIELD,
     g_param_spec_object ("field",
                         NULL,
                         NULL,
                         T_TEST_TYPE_EMPTY_STRUCT,
                         G_PARAM_READWRITE));
}

GType
t_test_one_field_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestOneFieldClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_one_field_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestOneField),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_one_field_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestOneFieldType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestVersioningTestV1Properties
{
  PROP_T_TEST_VERSIONING_TEST_V1_0,
  PROP_T_TEST_VERSIONING_TEST_V1_BEGIN_IN_BOTH,
  PROP_T_TEST_VERSIONING_TEST_V1_OLD_STRING,
  PROP_T_TEST_VERSIONING_TEST_V1_END_IN_BOTH
};

/* reads a versioning_test_v1 object */
static gint32
t_test_versioning_test_v1_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestVersioningTestV1 * this_object = T_TEST_VERSIONING_TEST_V1(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->begin_in_both, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_begin_in_both = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->old_string != NULL)
          {
            g_free(this_object->old_string);
            this_object->old_string = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->old_string, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_old_string = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->end_in_both, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_end_in_both = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_versioning_test_v1_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestVersioningTestV1 * this_object = T_TEST_VERSIONING_TEST_V1(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "VersioningTestV1", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "begin_in_both", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->begin_in_both, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "old_string", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->old_string, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "end_in_both", T_I32, 12, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->end_in_both, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_versioning_test_v1_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  TTestVersioningTestV1 *self = T_TEST_VERSIONING_TEST_V1 (object);

  switch (property_id)
  {
    case PROP_T_TEST_VERSIONING_TEST_V1_BEGIN_IN_BOTH:
      self->begin_in_both = g_value_get_int (value);
      self->__isset_begin_in_both = TRUE;
      break;

    case PROP_T_TEST_VERSIONING_TEST_V1_OLD_STRING:
      if (self->old_string != NULL)
        g_free (self->old_string);
      self->old_string = g_value_dup_string (value);
      self->__isset_old_string = TRUE;
      break;

    case PROP_T_TEST_VERSIONING_TEST_V1_END_IN_BOTH:
      self->end_in_both = g_value_get_int (value);
      self->__isset_end_in_both = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_versioning_test_v1_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  TTestVersioningTestV1 *self = T_TEST_VERSIONING_TEST_V1 (object);

  switch (property_id)
  {
    case PROP_T_TEST_VERSIONING_TEST_V1_BEGIN_IN_BOTH:
      g_value_set_int (value, self->begin_in_both);
      break;

    case PROP_T_TEST_VERSIONING_TEST_V1_OLD_STRING:
      g_value_set_string (value, self->old_string);
      break;

    case PROP_T_TEST_VERSIONING_TEST_V1_END_IN_BOTH:
      g_value_set_int (value, self->end_in_both);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_versioning_test_v1_instance_init (TTestVersioningTestV1 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->begin_in_both = 0;
  object->__isset_begin_in_both = FALSE;
  object->old_string = NULL;
  object->__isset_old_string = FALSE;
  object->end_in_both = 0;
  object->__isset_end_in_both = FALSE;
}

static void 
t_test_versioning_test_v1_finalize (GObject *object)
{
  TTestVersioningTestV1 *tobject = T_TEST_VERSIONING_TEST_V1 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->old_string != NULL)
  {
    g_free(tobject->old_string);
    tobject->old_string = NULL;
  }
}

static void
t_test_versioning_test_v1_class_init (TTestVersioningTestV1Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_versioning_test_v1_read;
  struct_class->write = t_test_versioning_test_v1_write;

  gobject_class->finalize = t_test_versioning_test_v1_finalize;
  gobject_class->get_property = t_test_versioning_test_v1_get_property;
  gobject_class->set_property = t_test_versioning_test_v1_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_VERSIONING_TEST_V1_BEGIN_IN_BOTH,
     g_param_spec_int ("begin_in_both",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_VERSIONING_TEST_V1_OLD_STRING,
     g_param_spec_string ("old_string",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_VERSIONING_TEST_V1_END_IN_BOTH,
     g_param_spec_int ("end_in_both",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
t_test_versioning_test_v1_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestVersioningTestV1Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_versioning_test_v1_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestVersioningTestV1),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_versioning_test_v1_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestVersioningTestV1Type",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestVersioningTestV2Properties
{
  PROP_T_TEST_VERSIONING_TEST_V2_0,
  PROP_T_TEST_VERSIONING_TEST_V2_BEGIN_IN_BOTH,
  PROP_T_TEST_VERSIONING_TEST_V2_NEWINT,
  PROP_T_TEST_VERSIONING_TEST_V2_NEWBYTE,
  PROP_T_TEST_VERSIONING_TEST_V2_NEWSHORT,
  PROP_T_TEST_VERSIONING_TEST_V2_NEWLONG,
  PROP_T_TEST_VERSIONING_TEST_V2_NEWDOUBLE,
  PROP_T_TEST_VERSIONING_TEST_V2_NEWSTRUCT,
  PROP_T_TEST_VERSIONING_TEST_V2_NEWLIST,
  PROP_T_TEST_VERSIONING_TEST_V2_NEWSET,
  PROP_T_TEST_VERSIONING_TEST_V2_NEWMAP,
  PROP_T_TEST_VERSIONING_TEST_V2_NEWSTRING,
  PROP_T_TEST_VERSIONING_TEST_V2_END_IN_BOTH
};

/* reads a versioning_test_v2 object */
static gint32
t_test_versioning_test_v2_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestVersioningTestV2 * this_object = T_TEST_VERSIONING_TEST_V2(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->begin_in_both, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_begin_in_both = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->newint, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_newint = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->newbyte, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_newbyte = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->newshort, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_newshort = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->newlong, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_newlong = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->newdouble, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_newdouble = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->newstruct), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_newstruct = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem26 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem26, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->newlist, _elem26, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_newlist = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            for (i = 0; i < size; ++i)
            {
              gint32* _elem27 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem27, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *) this_object->newset, (gpointer) _elem27, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_newset = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint32* key28 = g_new (gint32, 1);
              gint32* val29 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*key28, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_i32 (protocol, &*val29, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->newmap, (gpointer) key28, (gpointer) val29);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_newmap = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_STRING)
        {
          if (this_object->newstring != NULL)
          {
            g_free(this_object->newstring);
            this_object->newstring = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->newstring, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_newstring = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->end_in_both, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_end_in_both = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_versioning_test_v2_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestVersioningTestV2 * this_object = T_TEST_VERSIONING_TEST_V2(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "VersioningTestV2", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "begin_in_both", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->begin_in_both, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "newint", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->newint, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "newbyte", T_BYTE, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->newbyte, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "newshort", T_I16, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->newshort, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "newlong", T_I64, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->newlong, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "newdouble", T_DOUBLE, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->newdouble, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "newstruct", T_STRUCT, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->newstruct), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "newlist", T_LIST, 8, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i30;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) this_object->newlist->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i30 = 0; i30 < this_object->newlist->len; i30++)
    {
      if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->newlist, gint32, i30)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "newset", T_SET, 9, error)) < 0)
    return -1;
  xfer += ret;
  {
    GList *key_list = NULL, *iter = NULL;
    gint32** keys;
    int i = 0, key_count;
    gint32* elem;
    gpointer value;
    THRIFT_UNUSED_VAR (value);

    if ((ret = thrift_protocol_write_set_begin (protocol, T_I32, (gint32) g_hash_table_size ((GHashTable *) this_object->newset), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->newset, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint32*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint32*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      elem = keys[i];
      value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->newset), (gpointer) elem);

      if ((ret = thrift_protocol_write_i32 (protocol, *elem, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "newmap", T_MAP, 10, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint32* key31 = g_new (gint32, 1);
    gint32* val32 = g_new (gint32, 1);
    GList *key_list = NULL, *iter = NULL;
    gint32** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_I32, (gint32) g_hash_table_size ((GHashTable *) this_object->newmap), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->newmap, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint32*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint32*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key31 = keys[i];
      val32 = (gint32*) g_hash_table_lookup (((GHashTable *) this_object->newmap), (gpointer) key31);

      if ((ret = thrift_protocol_write_i32 (protocol, * key31, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_i32 (protocol, * val32, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "newstring", T_STRING, 11, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->newstring, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "end_in_both", T_I32, 12, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->end_in_both, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_versioning_test_v2_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  TTestVersioningTestV2 *self = T_TEST_VERSIONING_TEST_V2 (object);

  switch (property_id)
  {
    case PROP_T_TEST_VERSIONING_TEST_V2_BEGIN_IN_BOTH:
      self->begin_in_both = g_value_get_int (value);
      self->__isset_begin_in_both = TRUE;
      break;

    case PROP_T_TEST_VERSIONING_TEST_V2_NEWINT:
      self->newint = g_value_get_int (value);
      self->__isset_newint = TRUE;
      break;

    case PROP_T_TEST_VERSIONING_TEST_V2_NEWBYTE:
      self->newbyte = g_value_get_int (value);
      self->__isset_newbyte = TRUE;
      break;

    case PROP_T_TEST_VERSIONING_TEST_V2_NEWSHORT:
      self->newshort = g_value_get_int (value);
      self->__isset_newshort = TRUE;
      break;

    case PROP_T_TEST_VERSIONING_TEST_V2_NEWLONG:
      self->newlong = g_value_get_int64 (value);
      self->__isset_newlong = TRUE;
      break;

    case PROP_T_TEST_VERSIONING_TEST_V2_NEWDOUBLE:
      self->newdouble = g_value_get_double (value);
      self->__isset_newdouble = TRUE;
      break;

    case PROP_T_TEST_VERSIONING_TEST_V2_NEWSTRUCT:
      if (self->newstruct != NULL)
        g_object_unref (self->newstruct);
      self->newstruct = g_value_dup_object (value);
      self->__isset_newstruct = TRUE;
      break;

    case PROP_T_TEST_VERSIONING_TEST_V2_NEWLIST:
      if (self->newlist != NULL)
        g_array_unref (self->newlist);
      self->newlist = g_value_dup_boxed (value);
      self->__isset_newlist = TRUE;
      break;

    case PROP_T_TEST_VERSIONING_TEST_V2_NEWSET:
      if (self->newset != NULL)
        g_hash_table_unref (self->newset);
      self->newset = g_value_dup_boxed (value);
      self->__isset_newset = TRUE;
      break;

    case PROP_T_TEST_VERSIONING_TEST_V2_NEWMAP:
      if (self->newmap != NULL)
        g_hash_table_unref (self->newmap);
      self->newmap = g_value_dup_boxed (value);
      self->__isset_newmap = TRUE;
      break;

    case PROP_T_TEST_VERSIONING_TEST_V2_NEWSTRING:
      if (self->newstring != NULL)
        g_free (self->newstring);
      self->newstring = g_value_dup_string (value);
      self->__isset_newstring = TRUE;
      break;

    case PROP_T_TEST_VERSIONING_TEST_V2_END_IN_BOTH:
      self->end_in_both = g_value_get_int (value);
      self->__isset_end_in_both = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_versioning_test_v2_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  TTestVersioningTestV2 *self = T_TEST_VERSIONING_TEST_V2 (object);

  switch (property_id)
  {
    case PROP_T_TEST_VERSIONING_TEST_V2_BEGIN_IN_BOTH:
      g_value_set_int (value, self->begin_in_both);
      break;

    case PROP_T_TEST_VERSIONING_TEST_V2_NEWINT:
      g_value_set_int (value, self->newint);
      break;

    case PROP_T_TEST_VERSIONING_TEST_V2_NEWBYTE:
      g_value_set_int (value, self->newbyte);
      break;

    case PROP_T_TEST_VERSIONING_TEST_V2_NEWSHORT:
      g_value_set_int (value, self->newshort);
      break;

    case PROP_T_TEST_VERSIONING_TEST_V2_NEWLONG:
      g_value_set_int64 (value, self->newlong);
      break;

    case PROP_T_TEST_VERSIONING_TEST_V2_NEWDOUBLE:
      g_value_set_double (value, self->newdouble);
      break;

    case PROP_T_TEST_VERSIONING_TEST_V2_NEWSTRUCT:
      g_value_set_object (value, self->newstruct);
      break;

    case PROP_T_TEST_VERSIONING_TEST_V2_NEWLIST:
      g_value_set_boxed (value, self->newlist);
      break;

    case PROP_T_TEST_VERSIONING_TEST_V2_NEWSET:
      g_value_set_boxed (value, self->newset);
      break;

    case PROP_T_TEST_VERSIONING_TEST_V2_NEWMAP:
      g_value_set_boxed (value, self->newmap);
      break;

    case PROP_T_TEST_VERSIONING_TEST_V2_NEWSTRING:
      g_value_set_string (value, self->newstring);
      break;

    case PROP_T_TEST_VERSIONING_TEST_V2_END_IN_BOTH:
      g_value_set_int (value, self->end_in_both);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_versioning_test_v2_instance_init (TTestVersioningTestV2 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->begin_in_both = 0;
  object->__isset_begin_in_both = FALSE;
  object->newint = 0;
  object->__isset_newint = FALSE;
  object->newbyte = 0;
  object->__isset_newbyte = FALSE;
  object->newshort = 0;
  object->__isset_newshort = FALSE;
  object->newlong = 0;
  object->__isset_newlong = FALSE;
  object->newdouble = 0;
  object->__isset_newdouble = FALSE;
  object->newstruct = g_object_new (T_TEST_TYPE_BONK, NULL);
  object->__isset_newstruct = FALSE;
  object->newlist = g_array_new (0, 1, sizeof (gint32));
  object->__isset_newlist = FALSE;
  object->newset = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, NULL);
  object->__isset_newset = FALSE;
  object->newmap = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_free);
  object->__isset_newmap = FALSE;
  object->newstring = NULL;
  object->__isset_newstring = FALSE;
  object->end_in_both = 0;
  object->__isset_end_in_both = FALSE;
}

static void 
t_test_versioning_test_v2_finalize (GObject *object)
{
  TTestVersioningTestV2 *tobject = T_TEST_VERSIONING_TEST_V2 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->newstruct != NULL)
  {
    g_object_unref(tobject->newstruct);
    tobject->newstruct = NULL;
  }
  if (tobject->newlist != NULL)
  {
    g_array_unref (tobject->newlist);
    tobject->newlist = NULL;
  }
  if (tobject->newset != NULL)
  {
    g_hash_table_destroy (tobject->newset);
    tobject->newset = NULL;
  }
  if (tobject->newmap != NULL)
  {
    g_hash_table_destroy (tobject->newmap);
    tobject->newmap = NULL;
  }
  if (tobject->newstring != NULL)
  {
    g_free(tobject->newstring);
    tobject->newstring = NULL;
  }
}

static void
t_test_versioning_test_v2_class_init (TTestVersioningTestV2Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_versioning_test_v2_read;
  struct_class->write = t_test_versioning_test_v2_write;

  gobject_class->finalize = t_test_versioning_test_v2_finalize;
  gobject_class->get_property = t_test_versioning_test_v2_get_property;
  gobject_class->set_property = t_test_versioning_test_v2_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_VERSIONING_TEST_V2_BEGIN_IN_BOTH,
     g_param_spec_int ("begin_in_both",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_VERSIONING_TEST_V2_NEWINT,
     g_param_spec_int ("newint",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_VERSIONING_TEST_V2_NEWBYTE,
     g_param_spec_int ("newbyte",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_VERSIONING_TEST_V2_NEWSHORT,
     g_param_spec_int ("newshort",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_VERSIONING_TEST_V2_NEWLONG,
     g_param_spec_int64 ("newlong",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_VERSIONING_TEST_V2_NEWDOUBLE,
     g_param_spec_double ("newdouble",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_VERSIONING_TEST_V2_NEWSTRUCT,
     g_param_spec_object ("newstruct",
                         NULL,
                         NULL,
                         T_TEST_TYPE_BONK,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_VERSIONING_TEST_V2_NEWLIST,
     g_param_spec_boxed ("newlist",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_VERSIONING_TEST_V2_NEWSET,
     g_param_spec_boxed ("newset",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_VERSIONING_TEST_V2_NEWMAP,
     g_param_spec_boxed ("newmap",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_VERSIONING_TEST_V2_NEWSTRING,
     g_param_spec_string ("newstring",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_VERSIONING_TEST_V2_END_IN_BOTH,
     g_param_spec_int ("end_in_both",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
t_test_versioning_test_v2_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestVersioningTestV2Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_versioning_test_v2_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestVersioningTestV2),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_versioning_test_v2_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestVersioningTestV2Type",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestListTypeVersioningV1Properties
{
  PROP_T_TEST_LIST_TYPE_VERSIONING_V1_0,
  PROP_T_TEST_LIST_TYPE_VERSIONING_V1_MYINTS,
  PROP_T_TEST_LIST_TYPE_VERSIONING_V1_HELLO
};

/* reads a list_type_versioning_v1 object */
static gint32
t_test_list_type_versioning_v1_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestListTypeVersioningV1 * this_object = T_TEST_LIST_TYPE_VERSIONING_V1(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem33 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem33, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->myints, _elem33, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_myints = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->hello != NULL)
          {
            g_free(this_object->hello);
            this_object->hello = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->hello, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_hello = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_list_type_versioning_v1_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestListTypeVersioningV1 * this_object = T_TEST_LIST_TYPE_VERSIONING_V1(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ListTypeVersioningV1", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "myints", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i34;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) this_object->myints->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i34 = 0; i34 < this_object->myints->len; i34++)
    {
      if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->myints, gint32, i34)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "hello", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->hello, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_list_type_versioning_v1_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  TTestListTypeVersioningV1 *self = T_TEST_LIST_TYPE_VERSIONING_V1 (object);

  switch (property_id)
  {
    case PROP_T_TEST_LIST_TYPE_VERSIONING_V1_MYINTS:
      if (self->myints != NULL)
        g_array_unref (self->myints);
      self->myints = g_value_dup_boxed (value);
      self->__isset_myints = TRUE;
      break;

    case PROP_T_TEST_LIST_TYPE_VERSIONING_V1_HELLO:
      if (self->hello != NULL)
        g_free (self->hello);
      self->hello = g_value_dup_string (value);
      self->__isset_hello = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_list_type_versioning_v1_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  TTestListTypeVersioningV1 *self = T_TEST_LIST_TYPE_VERSIONING_V1 (object);

  switch (property_id)
  {
    case PROP_T_TEST_LIST_TYPE_VERSIONING_V1_MYINTS:
      g_value_set_boxed (value, self->myints);
      break;

    case PROP_T_TEST_LIST_TYPE_VERSIONING_V1_HELLO:
      g_value_set_string (value, self->hello);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_list_type_versioning_v1_instance_init (TTestListTypeVersioningV1 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->myints = g_array_new (0, 1, sizeof (gint32));
  object->__isset_myints = FALSE;
  object->hello = NULL;
  object->__isset_hello = FALSE;
}

static void 
t_test_list_type_versioning_v1_finalize (GObject *object)
{
  TTestListTypeVersioningV1 *tobject = T_TEST_LIST_TYPE_VERSIONING_V1 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->myints != NULL)
  {
    g_array_unref (tobject->myints);
    tobject->myints = NULL;
  }
  if (tobject->hello != NULL)
  {
    g_free(tobject->hello);
    tobject->hello = NULL;
  }
}

static void
t_test_list_type_versioning_v1_class_init (TTestListTypeVersioningV1Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_list_type_versioning_v1_read;
  struct_class->write = t_test_list_type_versioning_v1_write;

  gobject_class->finalize = t_test_list_type_versioning_v1_finalize;
  gobject_class->get_property = t_test_list_type_versioning_v1_get_property;
  gobject_class->set_property = t_test_list_type_versioning_v1_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_LIST_TYPE_VERSIONING_V1_MYINTS,
     g_param_spec_boxed ("myints",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_LIST_TYPE_VERSIONING_V1_HELLO,
     g_param_spec_string ("hello",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
t_test_list_type_versioning_v1_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestListTypeVersioningV1Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_list_type_versioning_v1_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestListTypeVersioningV1),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_list_type_versioning_v1_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestListTypeVersioningV1Type",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestListTypeVersioningV2Properties
{
  PROP_T_TEST_LIST_TYPE_VERSIONING_V2_0,
  PROP_T_TEST_LIST_TYPE_VERSIONING_V2_STRINGS,
  PROP_T_TEST_LIST_TYPE_VERSIONING_V2_HELLO
};

/* reads a list_type_versioning_v2 object */
static gint32
t_test_list_type_versioning_v2_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestListTypeVersioningV2 * this_object = T_TEST_LIST_TYPE_VERSIONING_V2(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem35 = NULL;
              if (_elem35 != NULL)
              {
                g_free(_elem35);
                _elem35 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem35, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->strings, _elem35);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_strings = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->hello != NULL)
          {
            g_free(this_object->hello);
            this_object->hello = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->hello, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_hello = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_list_type_versioning_v2_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestListTypeVersioningV2 * this_object = T_TEST_LIST_TYPE_VERSIONING_V2(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ListTypeVersioningV2", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "strings", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i36;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) this_object->strings->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i36 = 0; i36 < this_object->strings->len; i36++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->strings, i36)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "hello", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->hello, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_list_type_versioning_v2_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  TTestListTypeVersioningV2 *self = T_TEST_LIST_TYPE_VERSIONING_V2 (object);

  switch (property_id)
  {
    case PROP_T_TEST_LIST_TYPE_VERSIONING_V2_STRINGS:
      if (self->strings != NULL)
        g_ptr_array_unref (self->strings);
      self->strings = g_value_dup_boxed (value);
      self->__isset_strings = TRUE;
      break;

    case PROP_T_TEST_LIST_TYPE_VERSIONING_V2_HELLO:
      if (self->hello != NULL)
        g_free (self->hello);
      self->hello = g_value_dup_string (value);
      self->__isset_hello = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_list_type_versioning_v2_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  TTestListTypeVersioningV2 *self = T_TEST_LIST_TYPE_VERSIONING_V2 (object);

  switch (property_id)
  {
    case PROP_T_TEST_LIST_TYPE_VERSIONING_V2_STRINGS:
      g_value_set_boxed (value, self->strings);
      break;

    case PROP_T_TEST_LIST_TYPE_VERSIONING_V2_HELLO:
      g_value_set_string (value, self->hello);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_list_type_versioning_v2_instance_init (TTestListTypeVersioningV2 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->strings = g_ptr_array_new_with_free_func (g_free);
  object->__isset_strings = FALSE;
  object->hello = NULL;
  object->__isset_hello = FALSE;
}

static void 
t_test_list_type_versioning_v2_finalize (GObject *object)
{
  TTestListTypeVersioningV2 *tobject = T_TEST_LIST_TYPE_VERSIONING_V2 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->strings != NULL)
  {
    g_ptr_array_unref (tobject->strings);
    tobject->strings = NULL;
  }
  if (tobject->hello != NULL)
  {
    g_free(tobject->hello);
    tobject->hello = NULL;
  }
}

static void
t_test_list_type_versioning_v2_class_init (TTestListTypeVersioningV2Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_list_type_versioning_v2_read;
  struct_class->write = t_test_list_type_versioning_v2_write;

  gobject_class->finalize = t_test_list_type_versioning_v2_finalize;
  gobject_class->get_property = t_test_list_type_versioning_v2_get_property;
  gobject_class->set_property = t_test_list_type_versioning_v2_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_LIST_TYPE_VERSIONING_V2_STRINGS,
     g_param_spec_boxed ("strings",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_LIST_TYPE_VERSIONING_V2_HELLO,
     g_param_spec_string ("hello",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
t_test_list_type_versioning_v2_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestListTypeVersioningV2Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_list_type_versioning_v2_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestListTypeVersioningV2),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_list_type_versioning_v2_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestListTypeVersioningV2Type",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestGuessProtocolStructProperties
{
  PROP_T_TEST_GUESS_PROTOCOL_STRUCT_0,
  PROP_T_TEST_GUESS_PROTOCOL_STRUCT_MAP_FIELD
};

/* reads a guess_protocol_struct object */
static gint32
t_test_guess_protocol_struct_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestGuessProtocolStruct * this_object = T_TEST_GUESS_PROTOCOL_STRUCT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 7:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key37 = NULL;
              gchar * val38 = NULL;
              if (key37 != NULL)
              {
                g_free(key37);
                key37 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key37, error)) < 0)
                return -1;
              xfer += ret;
              if (val38 != NULL)
              {
                g_free(val38);
                val38 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val38, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->map_field, (gpointer) key37, (gpointer) val38);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_map_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_guess_protocol_struct_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestGuessProtocolStruct * this_object = T_TEST_GUESS_PROTOCOL_STRUCT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "GuessProtocolStruct", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "map_field", T_MAP, 7, error)) < 0)
    return -1;
  xfer += ret;
  {
    gchar * key39 = NULL;
    gchar * val40 = NULL;
    GList *key_list = NULL, *iter = NULL;
    gchar ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, (gint32) g_hash_table_size ((GHashTable *) this_object->map_field), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->map_field, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gchar *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gchar *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key39 = keys[i];
      val40 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->map_field), (gpointer) key39);

      if ((ret = thrift_protocol_write_string (protocol,  key39, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_string (protocol,  val40, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_guess_protocol_struct_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  TTestGuessProtocolStruct *self = T_TEST_GUESS_PROTOCOL_STRUCT (object);

  switch (property_id)
  {
    case PROP_T_TEST_GUESS_PROTOCOL_STRUCT_MAP_FIELD:
      if (self->map_field != NULL)
        g_hash_table_unref (self->map_field);
      self->map_field = g_value_dup_boxed (value);
      self->__isset_map_field = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_guess_protocol_struct_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  TTestGuessProtocolStruct *self = T_TEST_GUESS_PROTOCOL_STRUCT (object);

  switch (property_id)
  {
    case PROP_T_TEST_GUESS_PROTOCOL_STRUCT_MAP_FIELD:
      g_value_set_boxed (value, self->map_field);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_guess_protocol_struct_instance_init (TTestGuessProtocolStruct * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->map_field = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_map_field = FALSE;
}

static void 
t_test_guess_protocol_struct_finalize (GObject *object)
{
  TTestGuessProtocolStruct *tobject = T_TEST_GUESS_PROTOCOL_STRUCT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->map_field != NULL)
  {
    g_hash_table_destroy (tobject->map_field);
    tobject->map_field = NULL;
  }
}

static void
t_test_guess_protocol_struct_class_init (TTestGuessProtocolStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_guess_protocol_struct_read;
  struct_class->write = t_test_guess_protocol_struct_write;

  gobject_class->finalize = t_test_guess_protocol_struct_finalize;
  gobject_class->get_property = t_test_guess_protocol_struct_get_property;
  gobject_class->set_property = t_test_guess_protocol_struct_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_GUESS_PROTOCOL_STRUCT_MAP_FIELD,
     g_param_spec_boxed ("map_field",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
t_test_guess_protocol_struct_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestGuessProtocolStructClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_guess_protocol_struct_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestGuessProtocolStruct),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_guess_protocol_struct_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestGuessProtocolStructType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestLargeDeltasProperties
{
  PROP_T_TEST_LARGE_DELTAS_0,
  PROP_T_TEST_LARGE_DELTAS_B1,
  PROP_T_TEST_LARGE_DELTAS_B10,
  PROP_T_TEST_LARGE_DELTAS_B100,
  PROP_T_TEST_LARGE_DELTAS_CHECK_TRUE,
  PROP_T_TEST_LARGE_DELTAS_B1000,
  PROP_T_TEST_LARGE_DELTAS_CHECK_FALSE,
  PROP_T_TEST_LARGE_DELTAS_VERTWO2000,
  PROP_T_TEST_LARGE_DELTAS_A_SET2500,
  PROP_T_TEST_LARGE_DELTAS_VERTWO3000,
  PROP_T_TEST_LARGE_DELTAS_BIG_NUMBERS
};

/* reads a large_deltas object */
static gint32
t_test_large_deltas_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestLargeDeltas * this_object = T_TEST_LARGE_DELTAS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->b1), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_b1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->b10), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_b10 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 100:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->b100), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_b100 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 500:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->check_true, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_check_true = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1000:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->b1000), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_b1000 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1500:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->check_false, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_check_false = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2000:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->vertwo2000), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_vertwo2000 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2500:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            for (i = 0; i < size; ++i)
            {
              gchar * _elem41 = NULL;
              if (_elem41 != NULL)
              {
                g_free(_elem41);
                _elem41 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem41, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *) this_object->a_set2500, (gpointer) _elem41, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_a_set2500 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3000:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->vertwo3000), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_vertwo3000 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4000:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem42 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem42, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->big_numbers, _elem42, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_big_numbers = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_large_deltas_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestLargeDeltas * this_object = T_TEST_LARGE_DELTAS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "LargeDeltas", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "b1", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->b1), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "b10", T_STRUCT, 10, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->b10), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "b100", T_STRUCT, 100, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->b100), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "check_true", T_BOOL, 500, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->check_true, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "b1000", T_STRUCT, 1000, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->b1000), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "check_false", T_BOOL, 1500, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->check_false, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "vertwo2000", T_STRUCT, 2000, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->vertwo2000), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "a_set2500", T_SET, 2500, error)) < 0)
    return -1;
  xfer += ret;
  {
    GList *key_list = NULL, *iter = NULL;
    gchar ** keys;
    int i = 0, key_count;
    gchar * elem;
    gpointer value;
    THRIFT_UNUSED_VAR (value);

    if ((ret = thrift_protocol_write_set_begin (protocol, T_STRING, (gint32) g_hash_table_size ((GHashTable *) this_object->a_set2500), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->a_set2500, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gchar *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gchar *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      elem = keys[i];
      value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->a_set2500), (gpointer) elem);

      if ((ret = thrift_protocol_write_string (protocol, elem, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "vertwo3000", T_STRUCT, 3000, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->vertwo3000), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "big_numbers", T_LIST, 4000, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i43;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) this_object->big_numbers->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i43 = 0; i43 < this_object->big_numbers->len; i43++)
    {
      if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->big_numbers, gint32, i43)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_large_deltas_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  TTestLargeDeltas *self = T_TEST_LARGE_DELTAS (object);

  switch (property_id)
  {
    case PROP_T_TEST_LARGE_DELTAS_B1:
      if (self->b1 != NULL)
        g_object_unref (self->b1);
      self->b1 = g_value_dup_object (value);
      self->__isset_b1 = TRUE;
      break;

    case PROP_T_TEST_LARGE_DELTAS_B10:
      if (self->b10 != NULL)
        g_object_unref (self->b10);
      self->b10 = g_value_dup_object (value);
      self->__isset_b10 = TRUE;
      break;

    case PROP_T_TEST_LARGE_DELTAS_B100:
      if (self->b100 != NULL)
        g_object_unref (self->b100);
      self->b100 = g_value_dup_object (value);
      self->__isset_b100 = TRUE;
      break;

    case PROP_T_TEST_LARGE_DELTAS_CHECK_TRUE:
      self->check_true = g_value_get_boolean (value);
      self->__isset_check_true = TRUE;
      break;

    case PROP_T_TEST_LARGE_DELTAS_B1000:
      if (self->b1000 != NULL)
        g_object_unref (self->b1000);
      self->b1000 = g_value_dup_object (value);
      self->__isset_b1000 = TRUE;
      break;

    case PROP_T_TEST_LARGE_DELTAS_CHECK_FALSE:
      self->check_false = g_value_get_boolean (value);
      self->__isset_check_false = TRUE;
      break;

    case PROP_T_TEST_LARGE_DELTAS_VERTWO2000:
      if (self->vertwo2000 != NULL)
        g_object_unref (self->vertwo2000);
      self->vertwo2000 = g_value_dup_object (value);
      self->__isset_vertwo2000 = TRUE;
      break;

    case PROP_T_TEST_LARGE_DELTAS_A_SET2500:
      if (self->a_set2500 != NULL)
        g_hash_table_unref (self->a_set2500);
      self->a_set2500 = g_value_dup_boxed (value);
      self->__isset_a_set2500 = TRUE;
      break;

    case PROP_T_TEST_LARGE_DELTAS_VERTWO3000:
      if (self->vertwo3000 != NULL)
        g_object_unref (self->vertwo3000);
      self->vertwo3000 = g_value_dup_object (value);
      self->__isset_vertwo3000 = TRUE;
      break;

    case PROP_T_TEST_LARGE_DELTAS_BIG_NUMBERS:
      if (self->big_numbers != NULL)
        g_array_unref (self->big_numbers);
      self->big_numbers = g_value_dup_boxed (value);
      self->__isset_big_numbers = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_large_deltas_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  TTestLargeDeltas *self = T_TEST_LARGE_DELTAS (object);

  switch (property_id)
  {
    case PROP_T_TEST_LARGE_DELTAS_B1:
      g_value_set_object (value, self->b1);
      break;

    case PROP_T_TEST_LARGE_DELTAS_B10:
      g_value_set_object (value, self->b10);
      break;

    case PROP_T_TEST_LARGE_DELTAS_B100:
      g_value_set_object (value, self->b100);
      break;

    case PROP_T_TEST_LARGE_DELTAS_CHECK_TRUE:
      g_value_set_boolean (value, self->check_true);
      break;

    case PROP_T_TEST_LARGE_DELTAS_B1000:
      g_value_set_object (value, self->b1000);
      break;

    case PROP_T_TEST_LARGE_DELTAS_CHECK_FALSE:
      g_value_set_boolean (value, self->check_false);
      break;

    case PROP_T_TEST_LARGE_DELTAS_VERTWO2000:
      g_value_set_object (value, self->vertwo2000);
      break;

    case PROP_T_TEST_LARGE_DELTAS_A_SET2500:
      g_value_set_boxed (value, self->a_set2500);
      break;

    case PROP_T_TEST_LARGE_DELTAS_VERTWO3000:
      g_value_set_object (value, self->vertwo3000);
      break;

    case PROP_T_TEST_LARGE_DELTAS_BIG_NUMBERS:
      g_value_set_boxed (value, self->big_numbers);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_large_deltas_instance_init (TTestLargeDeltas * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->b1 = g_object_new (T_TEST_TYPE_BOOLS, NULL);
  object->__isset_b1 = FALSE;
  object->b10 = g_object_new (T_TEST_TYPE_BOOLS, NULL);
  object->__isset_b10 = FALSE;
  object->b100 = g_object_new (T_TEST_TYPE_BOOLS, NULL);
  object->__isset_b100 = FALSE;
  object->check_true = 0;
  object->__isset_check_true = FALSE;
  object->b1000 = g_object_new (T_TEST_TYPE_BOOLS, NULL);
  object->__isset_b1000 = FALSE;
  object->check_false = 0;
  object->__isset_check_false = FALSE;
  object->vertwo2000 = g_object_new (T_TEST_TYPE_VERSIONING_TEST_V2, NULL);
  object->__isset_vertwo2000 = FALSE;
  object->a_set2500 = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
  object->__isset_a_set2500 = FALSE;
  object->vertwo3000 = g_object_new (T_TEST_TYPE_VERSIONING_TEST_V2, NULL);
  object->__isset_vertwo3000 = FALSE;
  object->big_numbers = g_array_new (0, 1, sizeof (gint32));
  object->__isset_big_numbers = FALSE;
}

static void 
t_test_large_deltas_finalize (GObject *object)
{
  TTestLargeDeltas *tobject = T_TEST_LARGE_DELTAS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->b1 != NULL)
  {
    g_object_unref(tobject->b1);
    tobject->b1 = NULL;
  }
  if (tobject->b10 != NULL)
  {
    g_object_unref(tobject->b10);
    tobject->b10 = NULL;
  }
  if (tobject->b100 != NULL)
  {
    g_object_unref(tobject->b100);
    tobject->b100 = NULL;
  }
  if (tobject->b1000 != NULL)
  {
    g_object_unref(tobject->b1000);
    tobject->b1000 = NULL;
  }
  if (tobject->vertwo2000 != NULL)
  {
    g_object_unref(tobject->vertwo2000);
    tobject->vertwo2000 = NULL;
  }
  if (tobject->a_set2500 != NULL)
  {
    g_hash_table_destroy (tobject->a_set2500);
    tobject->a_set2500 = NULL;
  }
  if (tobject->vertwo3000 != NULL)
  {
    g_object_unref(tobject->vertwo3000);
    tobject->vertwo3000 = NULL;
  }
  if (tobject->big_numbers != NULL)
  {
    g_array_unref (tobject->big_numbers);
    tobject->big_numbers = NULL;
  }
}

static void
t_test_large_deltas_class_init (TTestLargeDeltasClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_large_deltas_read;
  struct_class->write = t_test_large_deltas_write;

  gobject_class->finalize = t_test_large_deltas_finalize;
  gobject_class->get_property = t_test_large_deltas_get_property;
  gobject_class->set_property = t_test_large_deltas_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_LARGE_DELTAS_B1,
     g_param_spec_object ("b1",
                         NULL,
                         NULL,
                         T_TEST_TYPE_BOOLS,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_LARGE_DELTAS_B10,
     g_param_spec_object ("b10",
                         NULL,
                         NULL,
                         T_TEST_TYPE_BOOLS,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_LARGE_DELTAS_B100,
     g_param_spec_object ("b100",
                         NULL,
                         NULL,
                         T_TEST_TYPE_BOOLS,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_LARGE_DELTAS_CHECK_TRUE,
     g_param_spec_boolean ("check_true",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_LARGE_DELTAS_B1000,
     g_param_spec_object ("b1000",
                         NULL,
                         NULL,
                         T_TEST_TYPE_BOOLS,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_LARGE_DELTAS_CHECK_FALSE,
     g_param_spec_boolean ("check_false",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_LARGE_DELTAS_VERTWO2000,
     g_param_spec_object ("vertwo2000",
                         NULL,
                         NULL,
                         T_TEST_TYPE_VERSIONING_TEST_V2,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_LARGE_DELTAS_A_SET2500,
     g_param_spec_boxed ("a_set2500",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_LARGE_DELTAS_VERTWO3000,
     g_param_spec_object ("vertwo3000",
                         NULL,
                         NULL,
                         T_TEST_TYPE_VERSIONING_TEST_V2,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_LARGE_DELTAS_BIG_NUMBERS,
     g_param_spec_boxed ("big_numbers",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_test_large_deltas_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestLargeDeltasClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_large_deltas_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestLargeDeltas),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_large_deltas_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestLargeDeltasType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestNestedListsI32x2Properties
{
  PROP_T_TEST_NESTED_LISTS_I32X2_0,
  PROP_T_TEST_NESTED_LISTS_I32X2_INTEGERLIST
};

/* reads a nested_lists_i32x2 object */
static gint32
t_test_nested_lists_i32x2_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestNestedListsI32x2 * this_object = T_TEST_NESTED_LISTS_I32X2(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GArray * _elem44 = g_array_new (0, 1, sizeof (gint32));
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                for (i = 0; i < size; i++)
                {
                  gint32* _elem45 = g_new (gint32, 1);
                  if ((ret = thrift_protocol_read_i32 (protocol, &*_elem45, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_array_append_vals (_elem44, _elem45, 1);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              g_ptr_array_add (this_object->integerlist, _elem44);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_integerlist = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_nested_lists_i32x2_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestNestedListsI32x2 * this_object = T_TEST_NESTED_LISTS_I32X2(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NestedListsI32x2", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "integerlist", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i46;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_LIST, (gint32) this_object->integerlist->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i46 = 0; i46 < this_object->integerlist->len; i46++)
    {
      {
        guint i47;

        if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) ((GArray*)g_ptr_array_index ((GPtrArray *) this_object->integerlist, i46))->len, error)) < 0)
          return -1;
        xfer += ret;
        for (i47 = 0; i47 < ((GArray*)g_ptr_array_index ((GPtrArray *) this_object->integerlist, i46))->len; i47++)
        {
          if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (((GArray*)g_ptr_array_index ((GPtrArray *) this_object->integerlist, i46)), gint32, i47)), error)) < 0)
            return -1;
        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_nested_lists_i32x2_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  TTestNestedListsI32x2 *self = T_TEST_NESTED_LISTS_I32X2 (object);

  switch (property_id)
  {
    case PROP_T_TEST_NESTED_LISTS_I32X2_INTEGERLIST:
      if (self->integerlist != NULL)
        g_ptr_array_unref (self->integerlist);
      self->integerlist = g_value_dup_boxed (value);
      self->__isset_integerlist = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_nested_lists_i32x2_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  TTestNestedListsI32x2 *self = T_TEST_NESTED_LISTS_I32X2 (object);

  switch (property_id)
  {
    case PROP_T_TEST_NESTED_LISTS_I32X2_INTEGERLIST:
      g_value_set_boxed (value, self->integerlist);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_nested_lists_i32x2_instance_init (TTestNestedListsI32x2 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->integerlist = g_ptr_array_new_with_free_func ((GDestroyNotify) g_array_unref);
  object->__isset_integerlist = FALSE;
}

static void 
t_test_nested_lists_i32x2_finalize (GObject *object)
{
  TTestNestedListsI32x2 *tobject = T_TEST_NESTED_LISTS_I32X2 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->integerlist != NULL)
  {
    g_ptr_array_unref (tobject->integerlist);
    tobject->integerlist = NULL;
  }
}

static void
t_test_nested_lists_i32x2_class_init (TTestNestedListsI32x2Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_nested_lists_i32x2_read;
  struct_class->write = t_test_nested_lists_i32x2_write;

  gobject_class->finalize = t_test_nested_lists_i32x2_finalize;
  gobject_class->get_property = t_test_nested_lists_i32x2_get_property;
  gobject_class->set_property = t_test_nested_lists_i32x2_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_NESTED_LISTS_I32X2_INTEGERLIST,
     g_param_spec_boxed ("integerlist",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_test_nested_lists_i32x2_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestNestedListsI32x2Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_nested_lists_i32x2_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestNestedListsI32x2),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_nested_lists_i32x2_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestNestedListsI32x2Type",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestNestedListsI32x3Properties
{
  PROP_T_TEST_NESTED_LISTS_I32X3_0,
  PROP_T_TEST_NESTED_LISTS_I32X3_INTEGERLIST
};

/* reads a nested_lists_i32x3 object */
static gint32
t_test_nested_lists_i32x3_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestNestedListsI32x3 * this_object = T_TEST_NESTED_LISTS_I32X3(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GPtrArray * _elem48 = g_ptr_array_new_with_free_func ((GDestroyNotify) g_array_unref);
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                for (i = 0; i < size; i++)
                {
                  GArray * _elem49 = g_array_new (0, 1, sizeof (gint32));
                  {
                    guint32 size;
                    guint32 i;
                    ThriftType element_type;

                    if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                      return -1;
                    xfer += ret;

                    /* iterate through list elements */
                    for (i = 0; i < size; i++)
                    {
                      gint32* _elem50 = g_new (gint32, 1);
                      if ((ret = thrift_protocol_read_i32 (protocol, &*_elem50, error)) < 0)
                        return -1;
                      xfer += ret;
                      g_array_append_vals (_elem49, _elem50, 1);
                    }
                    if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                      return -1;
                    xfer += ret;
                  }
                  g_ptr_array_add (_elem48, _elem49);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              g_ptr_array_add (this_object->integerlist, _elem48);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_integerlist = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_nested_lists_i32x3_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestNestedListsI32x3 * this_object = T_TEST_NESTED_LISTS_I32X3(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NestedListsI32x3", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "integerlist", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i51;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_LIST, (gint32) this_object->integerlist->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i51 = 0; i51 < this_object->integerlist->len; i51++)
    {
      {
        guint i52;

        if ((ret = thrift_protocol_write_list_begin (protocol, T_LIST, (gint32) ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->integerlist, i51))->len, error)) < 0)
          return -1;
        xfer += ret;
        for (i52 = 0; i52 < ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->integerlist, i51))->len; i52++)
        {
          {
            guint i53;

            if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) ((GArray*)g_ptr_array_index ((GPtrArray *) ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->integerlist, i51)), i52))->len, error)) < 0)
              return -1;
            xfer += ret;
            for (i53 = 0; i53 < ((GArray*)g_ptr_array_index ((GPtrArray *) ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->integerlist, i51)), i52))->len; i53++)
            {
              if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (((GArray*)g_ptr_array_index ((GPtrArray *) ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->integerlist, i51)), i52)), gint32, i53)), error)) < 0)
                return -1;
            }
            if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_nested_lists_i32x3_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  TTestNestedListsI32x3 *self = T_TEST_NESTED_LISTS_I32X3 (object);

  switch (property_id)
  {
    case PROP_T_TEST_NESTED_LISTS_I32X3_INTEGERLIST:
      if (self->integerlist != NULL)
        g_ptr_array_unref (self->integerlist);
      self->integerlist = g_value_dup_boxed (value);
      self->__isset_integerlist = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_nested_lists_i32x3_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  TTestNestedListsI32x3 *self = T_TEST_NESTED_LISTS_I32X3 (object);

  switch (property_id)
  {
    case PROP_T_TEST_NESTED_LISTS_I32X3_INTEGERLIST:
      g_value_set_boxed (value, self->integerlist);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_nested_lists_i32x3_instance_init (TTestNestedListsI32x3 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->integerlist = g_ptr_array_new_with_free_func ((GDestroyNotify) g_ptr_array_unref);
  object->__isset_integerlist = FALSE;
}

static void 
t_test_nested_lists_i32x3_finalize (GObject *object)
{
  TTestNestedListsI32x3 *tobject = T_TEST_NESTED_LISTS_I32X3 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->integerlist != NULL)
  {
    g_ptr_array_unref (tobject->integerlist);
    tobject->integerlist = NULL;
  }
}

static void
t_test_nested_lists_i32x3_class_init (TTestNestedListsI32x3Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_nested_lists_i32x3_read;
  struct_class->write = t_test_nested_lists_i32x3_write;

  gobject_class->finalize = t_test_nested_lists_i32x3_finalize;
  gobject_class->get_property = t_test_nested_lists_i32x3_get_property;
  gobject_class->set_property = t_test_nested_lists_i32x3_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_NESTED_LISTS_I32X3_INTEGERLIST,
     g_param_spec_boxed ("integerlist",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_test_nested_lists_i32x3_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestNestedListsI32x3Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_nested_lists_i32x3_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestNestedListsI32x3),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_nested_lists_i32x3_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestNestedListsI32x3Type",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestNestedMixedx2Properties
{
  PROP_T_TEST_NESTED_MIXEDX2_0,
  PROP_T_TEST_NESTED_MIXEDX2_INT_SET_LIST,
  PROP_T_TEST_NESTED_MIXEDX2_MAP_INT_STRSET,
  PROP_T_TEST_NESTED_MIXEDX2_MAP_INT_STRSET_LIST
};

/* reads a nested_mixedx2 object */
static gint32
t_test_nested_mixedx2_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestNestedMixedx2 * this_object = T_TEST_NESTED_MIXEDX2(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GHashTable * _elem54 = NULL;
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through the set elements */
                for (i = 0; i < size; ++i)
                {
                  gint32* _elem55 = g_new (gint32, 1);
                  if ((ret = thrift_protocol_read_i32 (protocol, &*_elem55, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_hash_table_insert ((GHashTable *) _elem54, (gpointer) _elem55, (gpointer) 1);
                }
                if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;

              }
              g_ptr_array_add (this_object->int_set_list, _elem54);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_int_set_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint32* key56 = g_new (gint32, 1);
              GHashTable * val57 = NULL;
              if ((ret = thrift_protocol_read_i32 (protocol, &*key56, error)) < 0)
                return -1;
              xfer += ret;
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through the set elements */
                for (i = 0; i < size; ++i)
                {
                  gchar * _elem58 = NULL;
                  if (_elem58 != NULL)
                  {
                    g_free(_elem58);
                    _elem58 = NULL;
                  }

                  if ((ret = thrift_protocol_read_string (protocol, &_elem58, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_hash_table_insert ((GHashTable *) val57, (gpointer) _elem58, (gpointer) 1);
                }
                if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;

              }
              g_hash_table_insert ((GHashTable *)this_object->map_int_strset, (gpointer) key56, (gpointer) val57);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_map_int_strset = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GHashTable * _elem59 = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, (GDestroyNotify) g_hash_table_destroy);
              {
                guint32 size;
                guint32 i;
                ThriftType key_type;
                ThriftType value_type;

                /* read the map begin marker */
                if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through each of the map's fields */
                for (i = 0; i < size; i++)
                {
                  gint32* key60 = g_new (gint32, 1);
                  GHashTable * val61 = NULL;
                  if ((ret = thrift_protocol_read_i32 (protocol, &*key60, error)) < 0)
                    return -1;
                  xfer += ret;
                  {
                    guint32 size;
                    guint32 i;
                    ThriftType element_type;

                    if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
                      return -1;
                    xfer += ret;

                    /* iterate through the set elements */
                    for (i = 0; i < size; ++i)
                    {
                      gchar * _elem62 = NULL;
                      if (_elem62 != NULL)
                      {
                        g_free(_elem62);
                        _elem62 = NULL;
                      }

                      if ((ret = thrift_protocol_read_string (protocol, &_elem62, error)) < 0)
                        return -1;
                      xfer += ret;
                      g_hash_table_insert ((GHashTable *) val61, (gpointer) _elem62, (gpointer) 1);
                    }
                    if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
                      return -1;
                    xfer += ret;

                  }
                  g_hash_table_insert ((GHashTable *)_elem59, (gpointer) key60, (gpointer) val61);
                }

                /* read the map end marker */
                if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              g_ptr_array_add (this_object->map_int_strset_list, _elem59);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_map_int_strset_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_nested_mixedx2_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestNestedMixedx2 * this_object = T_TEST_NESTED_MIXEDX2(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NestedMixedx2", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "int_set_list", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i63;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_SET, (gint32) this_object->int_set_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i63 = 0; i63 < this_object->int_set_list->len; i63++)
    {
      {
        GList *key_list = NULL, *iter = NULL;
        gint32** keys;
        int i = 0, key_count;
        gint32* elem;
        gpointer value;
        THRIFT_UNUSED_VAR (value);

        if ((ret = thrift_protocol_write_set_begin (protocol, T_I32, (gint32) g_hash_table_size ((GHashTable *) ((GHashTable*)g_ptr_array_index ((GPtrArray *) this_object->int_set_list, i63))), error)) < 0)
          return -1;
        xfer += ret;
        g_hash_table_foreach ((GHashTable *) ((GHashTable*)g_ptr_array_index ((GPtrArray *) this_object->int_set_list, i63)), thrift_hash_table_get_keys, &key_list);
        key_count = g_list_length (key_list);
        keys = g_newa (gint32*, key_count);
        for (iter = g_list_first (key_list); iter; iter = iter->next)
          keys[i++] = (gint32*) iter->data;
        g_list_free (key_list);

        for (i = 0; i < key_count; ++i)
        {
          elem = keys[i];
          value = (gpointer) g_hash_table_lookup (((GHashTable *) ((GHashTable*)g_ptr_array_index ((GPtrArray *) this_object->int_set_list, i63))), (gpointer) elem);

          if ((ret = thrift_protocol_write_i32 (protocol, *elem, error)) < 0)
            return -1;
        }
        if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "map_int_strset", T_MAP, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint32* key64 = g_new (gint32, 1);
    GHashTable * val65 = NULL;
    GList *key_list = NULL, *iter = NULL;
    gint32** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_SET, (gint32) g_hash_table_size ((GHashTable *) this_object->map_int_strset), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->map_int_strset, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint32*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint32*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key64 = keys[i];
      val65 = (GHashTable *) g_hash_table_lookup (((GHashTable *) this_object->map_int_strset), (gpointer) key64);

      if ((ret = thrift_protocol_write_i32 (protocol, * key64, error)) < 0)
        return -1;
      {
        GList *key_list = NULL, *iter = NULL;
        gchar ** keys;
        int i = 0, key_count;
        gchar * elem;
        gpointer value;
        THRIFT_UNUSED_VAR (value);

        if ((ret = thrift_protocol_write_set_begin (protocol, T_STRING, (gint32) g_hash_table_size ((GHashTable *)  val65), error)) < 0)
          return -1;
        xfer += ret;
        g_hash_table_foreach ((GHashTable *)  val65, thrift_hash_table_get_keys, &key_list);
        key_count = g_list_length (key_list);
        keys = g_newa (gchar *, key_count);
        for (iter = g_list_first (key_list); iter; iter = iter->next)
          keys[i++] = (gchar *) iter->data;
        g_list_free (key_list);

        for (i = 0; i < key_count; ++i)
        {
          elem = keys[i];
          value = (gpointer) g_hash_table_lookup (((GHashTable *)  val65), (gpointer) elem);

          if ((ret = thrift_protocol_write_string (protocol, elem, error)) < 0)
            return -1;
        }
        if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "map_int_strset_list", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i66;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_MAP, (gint32) this_object->map_int_strset_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i66 = 0; i66 < this_object->map_int_strset_list->len; i66++)
    {
      {
        gint32* key67 = g_new (gint32, 1);
        GHashTable * val68 = NULL;
        GList *key_list = NULL, *iter = NULL;
        gint32** keys;
        int i = 0, key_count;

        if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_SET, (gint32) g_hash_table_size ((GHashTable *) ((GHashTable*)g_ptr_array_index ((GPtrArray *) this_object->map_int_strset_list, i66))), error)) < 0)
          return -1;
        xfer += ret;
        g_hash_table_foreach ((GHashTable *) ((GHashTable*)g_ptr_array_index ((GPtrArray *) this_object->map_int_strset_list, i66)), thrift_hash_table_get_keys, &key_list);
        key_count = g_list_length (key_list);
        keys = g_newa (gint32*, key_count);
        for (iter = g_list_first (key_list); iter; iter = iter->next)
          keys[i++] = (gint32*) iter->data;
        g_list_free (key_list);

        for (i = 0; i < key_count; ++i)
        {
          key67 = keys[i];
          val68 = (GHashTable *) g_hash_table_lookup (((GHashTable *) ((GHashTable*)g_ptr_array_index ((GPtrArray *) this_object->map_int_strset_list, i66))), (gpointer) key67);

          if ((ret = thrift_protocol_write_i32 (protocol, * key67, error)) < 0)
            return -1;
          {
            GList *key_list = NULL, *iter = NULL;
            gchar ** keys;
            int i = 0, key_count;
            gchar * elem;
            gpointer value;
            THRIFT_UNUSED_VAR (value);

            if ((ret = thrift_protocol_write_set_begin (protocol, T_STRING, (gint32) g_hash_table_size ((GHashTable *)  val68), error)) < 0)
              return -1;
            xfer += ret;
            g_hash_table_foreach ((GHashTable *)  val68, thrift_hash_table_get_keys, &key_list);
            key_count = g_list_length (key_list);
            keys = g_newa (gchar *, key_count);
            for (iter = g_list_first (key_list); iter; iter = iter->next)
              keys[i++] = (gchar *) iter->data;
            g_list_free (key_list);

            for (i = 0; i < key_count; ++i)
            {
              elem = keys[i];
              value = (gpointer) g_hash_table_lookup (((GHashTable *)  val68), (gpointer) elem);

              if ((ret = thrift_protocol_write_string (protocol, elem, error)) < 0)
                return -1;
            }
            if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
        }
        if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_nested_mixedx2_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  TTestNestedMixedx2 *self = T_TEST_NESTED_MIXEDX2 (object);

  switch (property_id)
  {
    case PROP_T_TEST_NESTED_MIXEDX2_INT_SET_LIST:
      if (self->int_set_list != NULL)
        g_ptr_array_unref (self->int_set_list);
      self->int_set_list = g_value_dup_boxed (value);
      self->__isset_int_set_list = TRUE;
      break;

    case PROP_T_TEST_NESTED_MIXEDX2_MAP_INT_STRSET:
      if (self->map_int_strset != NULL)
        g_hash_table_unref (self->map_int_strset);
      self->map_int_strset = g_value_dup_boxed (value);
      self->__isset_map_int_strset = TRUE;
      break;

    case PROP_T_TEST_NESTED_MIXEDX2_MAP_INT_STRSET_LIST:
      if (self->map_int_strset_list != NULL)
        g_ptr_array_unref (self->map_int_strset_list);
      self->map_int_strset_list = g_value_dup_boxed (value);
      self->__isset_map_int_strset_list = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_nested_mixedx2_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  TTestNestedMixedx2 *self = T_TEST_NESTED_MIXEDX2 (object);

  switch (property_id)
  {
    case PROP_T_TEST_NESTED_MIXEDX2_INT_SET_LIST:
      g_value_set_boxed (value, self->int_set_list);
      break;

    case PROP_T_TEST_NESTED_MIXEDX2_MAP_INT_STRSET:
      g_value_set_boxed (value, self->map_int_strset);
      break;

    case PROP_T_TEST_NESTED_MIXEDX2_MAP_INT_STRSET_LIST:
      g_value_set_boxed (value, self->map_int_strset_list);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_nested_mixedx2_instance_init (TTestNestedMixedx2 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->int_set_list = g_ptr_array_new_with_free_func ((GDestroyNotify) g_hash_table_destroy);
  object->__isset_int_set_list = FALSE;
  object->map_int_strset = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, (GDestroyNotify) g_hash_table_destroy);
  object->__isset_map_int_strset = FALSE;
  object->map_int_strset_list = g_ptr_array_new_with_free_func ((GDestroyNotify) g_hash_table_destroy);
  object->__isset_map_int_strset_list = FALSE;
}

static void 
t_test_nested_mixedx2_finalize (GObject *object)
{
  TTestNestedMixedx2 *tobject = T_TEST_NESTED_MIXEDX2 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->int_set_list != NULL)
  {
    g_ptr_array_unref (tobject->int_set_list);
    tobject->int_set_list = NULL;
  }
  if (tobject->map_int_strset != NULL)
  {
    g_hash_table_destroy (tobject->map_int_strset);
    tobject->map_int_strset = NULL;
  }
  if (tobject->map_int_strset_list != NULL)
  {
    g_ptr_array_unref (tobject->map_int_strset_list);
    tobject->map_int_strset_list = NULL;
  }
}

static void
t_test_nested_mixedx2_class_init (TTestNestedMixedx2Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_nested_mixedx2_read;
  struct_class->write = t_test_nested_mixedx2_write;

  gobject_class->finalize = t_test_nested_mixedx2_finalize;
  gobject_class->get_property = t_test_nested_mixedx2_get_property;
  gobject_class->set_property = t_test_nested_mixedx2_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_NESTED_MIXEDX2_INT_SET_LIST,
     g_param_spec_boxed ("int_set_list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_NESTED_MIXEDX2_MAP_INT_STRSET,
     g_param_spec_boxed ("map_int_strset",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_NESTED_MIXEDX2_MAP_INT_STRSET_LIST,
     g_param_spec_boxed ("map_int_strset_list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_test_nested_mixedx2_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestNestedMixedx2Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_nested_mixedx2_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestNestedMixedx2),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_nested_mixedx2_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestNestedMixedx2Type",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestListBonksProperties
{
  PROP_T_TEST_LIST_BONKS_0,
  PROP_T_TEST_LIST_BONKS_BONK
};

/* reads a list_bonks object */
static gint32
t_test_list_bonks_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestListBonks * this_object = T_TEST_LIST_BONKS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TTestBonk * _elem69 = NULL;
              if ( _elem69 != NULL)
              {
                g_object_unref (_elem69);
              }
              _elem69 = g_object_new (T_TEST_TYPE_BONK, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem69), protocol, error)) < 0)
              {
                g_object_unref (_elem69);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->bonk, _elem69);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_bonk = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_list_bonks_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestListBonks * this_object = T_TEST_LIST_BONKS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ListBonks", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "bonk", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i70;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->bonk->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i70 = 0; i70 < this_object->bonk->len; i70++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->bonk, i70))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_list_bonks_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  TTestListBonks *self = T_TEST_LIST_BONKS (object);

  switch (property_id)
  {
    case PROP_T_TEST_LIST_BONKS_BONK:
      if (self->bonk != NULL)
        g_ptr_array_unref (self->bonk);
      self->bonk = g_value_dup_boxed (value);
      self->__isset_bonk = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_list_bonks_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  TTestListBonks *self = T_TEST_LIST_BONKS (object);

  switch (property_id)
  {
    case PROP_T_TEST_LIST_BONKS_BONK:
      g_value_set_boxed (value, self->bonk);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_list_bonks_instance_init (TTestListBonks * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->bonk = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_bonk = FALSE;
}

static void 
t_test_list_bonks_finalize (GObject *object)
{
  TTestListBonks *tobject = T_TEST_LIST_BONKS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->bonk != NULL)
  {
    g_ptr_array_unref (tobject->bonk);
    tobject->bonk = NULL;
  }
}

static void
t_test_list_bonks_class_init (TTestListBonksClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_list_bonks_read;
  struct_class->write = t_test_list_bonks_write;

  gobject_class->finalize = t_test_list_bonks_finalize;
  gobject_class->get_property = t_test_list_bonks_get_property;
  gobject_class->set_property = t_test_list_bonks_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_LIST_BONKS_BONK,
     g_param_spec_boxed ("bonk",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_test_list_bonks_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestListBonksClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_list_bonks_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestListBonks),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_list_bonks_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestListBonksType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestNestedListsBonkProperties
{
  PROP_T_TEST_NESTED_LISTS_BONK_0,
  PROP_T_TEST_NESTED_LISTS_BONK_BONK
};

/* reads a nested_lists_bonk object */
static gint32
t_test_nested_lists_bonk_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestNestedListsBonk * this_object = T_TEST_NESTED_LISTS_BONK(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GPtrArray * _elem71 = g_ptr_array_new_with_free_func ((GDestroyNotify) g_ptr_array_unref);
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                for (i = 0; i < size; i++)
                {
                  GPtrArray * _elem72 = g_ptr_array_new_with_free_func (g_object_unref);
                  {
                    guint32 size;
                    guint32 i;
                    ThriftType element_type;

                    if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                      return -1;
                    xfer += ret;

                    /* iterate through list elements */
                    for (i = 0; i < size; i++)
                    {
                      TTestBonk * _elem73 = NULL;
                      if ( _elem73 != NULL)
                      {
                        g_object_unref (_elem73);
                      }
                      _elem73 = g_object_new (T_TEST_TYPE_BONK, NULL);
                      if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem73), protocol, error)) < 0)
                      {
                        g_object_unref (_elem73);
                        return -1;
                      }
                      xfer += ret;
                      g_ptr_array_add (_elem72, _elem73);
                    }
                    if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                      return -1;
                    xfer += ret;
                  }
                  g_ptr_array_add (_elem71, _elem72);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              g_ptr_array_add (this_object->bonk, _elem71);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_bonk = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_nested_lists_bonk_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestNestedListsBonk * this_object = T_TEST_NESTED_LISTS_BONK(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NestedListsBonk", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "bonk", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i74;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_LIST, (gint32) this_object->bonk->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i74 = 0; i74 < this_object->bonk->len; i74++)
    {
      {
        guint i75;

        if ((ret = thrift_protocol_write_list_begin (protocol, T_LIST, (gint32) ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->bonk, i74))->len, error)) < 0)
          return -1;
        xfer += ret;
        for (i75 = 0; i75 < ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->bonk, i74))->len; i75++)
        {
          {
            guint i76;

            if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) ((GPtrArray*)g_ptr_array_index ((GPtrArray *) ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->bonk, i74)), i75))->len, error)) < 0)
              return -1;
            xfer += ret;
            for (i76 = 0; i76 < ((GPtrArray*)g_ptr_array_index ((GPtrArray *) ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->bonk, i74)), i75))->len; i76++)
            {
              if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) ((GPtrArray*)g_ptr_array_index ((GPtrArray *) ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->bonk, i74)), i75)), i76))), protocol, error)) < 0)
                return -1;
              xfer += ret;

            }
            if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_nested_lists_bonk_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  TTestNestedListsBonk *self = T_TEST_NESTED_LISTS_BONK (object);

  switch (property_id)
  {
    case PROP_T_TEST_NESTED_LISTS_BONK_BONK:
      if (self->bonk != NULL)
        g_ptr_array_unref (self->bonk);
      self->bonk = g_value_dup_boxed (value);
      self->__isset_bonk = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_nested_lists_bonk_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  TTestNestedListsBonk *self = T_TEST_NESTED_LISTS_BONK (object);

  switch (property_id)
  {
    case PROP_T_TEST_NESTED_LISTS_BONK_BONK:
      g_value_set_boxed (value, self->bonk);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_nested_lists_bonk_instance_init (TTestNestedListsBonk * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->bonk = g_ptr_array_new_with_free_func ((GDestroyNotify) g_ptr_array_unref);
  object->__isset_bonk = FALSE;
}

static void 
t_test_nested_lists_bonk_finalize (GObject *object)
{
  TTestNestedListsBonk *tobject = T_TEST_NESTED_LISTS_BONK (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->bonk != NULL)
  {
    g_ptr_array_unref (tobject->bonk);
    tobject->bonk = NULL;
  }
}

static void
t_test_nested_lists_bonk_class_init (TTestNestedListsBonkClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_nested_lists_bonk_read;
  struct_class->write = t_test_nested_lists_bonk_write;

  gobject_class->finalize = t_test_nested_lists_bonk_finalize;
  gobject_class->get_property = t_test_nested_lists_bonk_get_property;
  gobject_class->set_property = t_test_nested_lists_bonk_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_NESTED_LISTS_BONK_BONK,
     g_param_spec_boxed ("bonk",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_test_nested_lists_bonk_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestNestedListsBonkClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_nested_lists_bonk_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestNestedListsBonk),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_nested_lists_bonk_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestNestedListsBonkType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestBoolTestProperties
{
  PROP_T_TEST_BOOL_TEST_0,
  PROP_T_TEST_BOOL_TEST_B,
  PROP_T_TEST_BOOL_TEST_S
};

/* reads a bool_test object */
static gint32
t_test_bool_test_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestBoolTest * this_object = T_TEST_BOOL_TEST(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->b, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_b = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->s != NULL)
          {
            g_free(this_object->s);
            this_object->s = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->s, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_s = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_bool_test_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestBoolTest * this_object = T_TEST_BOOL_TEST(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BoolTest", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_b == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "b", T_BOOL, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->b, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_s == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "s", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->s, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_bool_test_set_property (GObject *object,
                               guint property_id,
                               const GValue *value,
                               GParamSpec *pspec)
{
  TTestBoolTest *self = T_TEST_BOOL_TEST (object);

  switch (property_id)
  {
    case PROP_T_TEST_BOOL_TEST_B:
      self->b = g_value_get_boolean (value);
      self->__isset_b = TRUE;
      break;

    case PROP_T_TEST_BOOL_TEST_S:
      if (self->s != NULL)
        g_free (self->s);
      self->s = g_value_dup_string (value);
      self->__isset_s = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_bool_test_get_property (GObject *object,
                               guint property_id,
                               GValue *value,
                               GParamSpec *pspec)
{
  TTestBoolTest *self = T_TEST_BOOL_TEST (object);

  switch (property_id)
  {
    case PROP_T_TEST_BOOL_TEST_B:
      g_value_set_boolean (value, self->b);
      break;

    case PROP_T_TEST_BOOL_TEST_S:
      g_value_set_string (value, self->s);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_bool_test_instance_init (TTestBoolTest * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->b = 1;
  object->__isset_b = FALSE;
  object->s = g_strdup ("true");
  object->__isset_s = FALSE;
}

static void 
t_test_bool_test_finalize (GObject *object)
{
  TTestBoolTest *tobject = T_TEST_BOOL_TEST (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->s != NULL)
  {
    g_free(tobject->s);
    tobject->s = NULL;
  }
}

static void
t_test_bool_test_class_init (TTestBoolTestClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_bool_test_read;
  struct_class->write = t_test_bool_test_write;

  gobject_class->finalize = t_test_bool_test_finalize;
  gobject_class->get_property = t_test_bool_test_get_property;
  gobject_class->set_property = t_test_bool_test_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_BOOL_TEST_B,
     g_param_spec_boolean ("b",
                           NULL,
                           NULL,
                           TRUE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_BOOL_TEST_S,
     g_param_spec_string ("s",
                          NULL,
                          NULL,
                          "true",
                          G_PARAM_READWRITE));
}

GType
t_test_bool_test_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestBoolTestClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_bool_test_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestBoolTest),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_bool_test_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestBoolTestType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestStructAProperties
{
  PROP_T_TEST_STRUCT_A_0,
  PROP_T_TEST_STRUCT_A_S
};

/* reads a struct_a object */
static gint32
t_test_struct_a_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestStructA * this_object = T_TEST_STRUCT_A(object);
  gboolean isset_s = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->s != NULL)
          {
            g_free(this_object->s);
            this_object->s = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->s, error)) < 0)
            return -1;
          xfer += ret;
          isset_s = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_s)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_test_struct_a_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestStructA * this_object = T_TEST_STRUCT_A(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "StructA", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "s", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->s, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_struct_a_set_property (GObject *object,
                              guint property_id,
                              const GValue *value,
                              GParamSpec *pspec)
{
  TTestStructA *self = T_TEST_STRUCT_A (object);

  switch (property_id)
  {
    case PROP_T_TEST_STRUCT_A_S:
      if (self->s != NULL)
        g_free (self->s);
      self->s = g_value_dup_string (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_struct_a_get_property (GObject *object,
                              guint property_id,
                              GValue *value,
                              GParamSpec *pspec)
{
  TTestStructA *self = T_TEST_STRUCT_A (object);

  switch (property_id)
  {
    case PROP_T_TEST_STRUCT_A_S:
      g_value_set_string (value, self->s);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_struct_a_instance_init (TTestStructA * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->s = NULL;
}

static void 
t_test_struct_a_finalize (GObject *object)
{
  TTestStructA *tobject = T_TEST_STRUCT_A (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->s != NULL)
  {
    g_free(tobject->s);
    tobject->s = NULL;
  }
}

static void
t_test_struct_a_class_init (TTestStructAClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_struct_a_read;
  struct_class->write = t_test_struct_a_write;

  gobject_class->finalize = t_test_struct_a_finalize;
  gobject_class->get_property = t_test_struct_a_get_property;
  gobject_class->set_property = t_test_struct_a_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_STRUCT_A_S,
     g_param_spec_string ("s",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
t_test_struct_a_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestStructAClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_struct_a_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestStructA),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_struct_a_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestStructAType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestStructBProperties
{
  PROP_T_TEST_STRUCT_B_0,
  PROP_T_TEST_STRUCT_B_AA,
  PROP_T_TEST_STRUCT_B_AB
};

/* reads a struct_b object */
static gint32
t_test_struct_b_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestStructB * this_object = T_TEST_STRUCT_B(object);
  gboolean isset_ab = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->aa), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_aa = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ab), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_ab = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_ab)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_test_struct_b_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestStructB * this_object = T_TEST_STRUCT_B(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "StructB", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_aa == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "aa", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->aa), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "ab", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ab), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_struct_b_set_property (GObject *object,
                              guint property_id,
                              const GValue *value,
                              GParamSpec *pspec)
{
  TTestStructB *self = T_TEST_STRUCT_B (object);

  switch (property_id)
  {
    case PROP_T_TEST_STRUCT_B_AA:
      if (self->aa != NULL)
        g_object_unref (self->aa);
      self->aa = g_value_dup_object (value);
      self->__isset_aa = TRUE;
      break;

    case PROP_T_TEST_STRUCT_B_AB:
      if (self->ab != NULL)
        g_object_unref (self->ab);
      self->ab = g_value_dup_object (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_struct_b_get_property (GObject *object,
                              guint property_id,
                              GValue *value,
                              GParamSpec *pspec)
{
  TTestStructB *self = T_TEST_STRUCT_B (object);

  switch (property_id)
  {
    case PROP_T_TEST_STRUCT_B_AA:
      g_value_set_object (value, self->aa);
      break;

    case PROP_T_TEST_STRUCT_B_AB:
      g_value_set_object (value, self->ab);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_struct_b_instance_init (TTestStructB * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->aa = g_object_new (T_TEST_TYPE_STRUCT_A, NULL);
  object->__isset_aa = FALSE;
  object->ab = g_object_new (T_TEST_TYPE_STRUCT_A, NULL);
}

static void 
t_test_struct_b_finalize (GObject *object)
{
  TTestStructB *tobject = T_TEST_STRUCT_B (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->aa != NULL)
  {
    g_object_unref(tobject->aa);
    tobject->aa = NULL;
  }
  if (tobject->ab != NULL)
  {
    g_object_unref(tobject->ab);
    tobject->ab = NULL;
  }
}

static void
t_test_struct_b_class_init (TTestStructBClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_struct_b_read;
  struct_class->write = t_test_struct_b_write;

  gobject_class->finalize = t_test_struct_b_finalize;
  gobject_class->get_property = t_test_struct_b_get_property;
  gobject_class->set_property = t_test_struct_b_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_STRUCT_B_AA,
     g_param_spec_object ("aa",
                         NULL,
                         NULL,
                         T_TEST_TYPE_STRUCT_A,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_STRUCT_B_AB,
     g_param_spec_object ("ab",
                         NULL,
                         NULL,
                         T_TEST_TYPE_STRUCT_A,
                         G_PARAM_READWRITE));
}

GType
t_test_struct_b_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestStructBClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_struct_b_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestStructB),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_struct_b_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestStructBType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */

/* reads a thrift_test_test_void_args object */
static gint32
t_test_thrift_test_test_void_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestVoidArgs * this_object = T_TEST_THRIFT_TEST_TEST_VOID_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_void_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestVoidArgs * this_object = T_TEST_THRIFT_TEST_TEST_VOID_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestVoidArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_thrift_test_test_void_args_instance_init (TTestThriftTestTestVoidArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
t_test_thrift_test_test_void_args_finalize (GObject *object)
{
  TTestThriftTestTestVoidArgs *tobject = T_TEST_THRIFT_TEST_TEST_VOID_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_thrift_test_test_void_args_class_init (TTestThriftTestTestVoidArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_void_args_read;
  struct_class->write = t_test_thrift_test_test_void_args_write;

  gobject_class->finalize = t_test_thrift_test_test_void_args_finalize;
}

GType
t_test_thrift_test_test_void_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestVoidArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_void_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestVoidArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_void_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestVoidArgsType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a thrift_test_test_void_result object */
static gint32
t_test_thrift_test_test_void_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestVoidResult * this_object = T_TEST_THRIFT_TEST_TEST_VOID_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_void_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestVoidResult * this_object = T_TEST_THRIFT_TEST_TEST_VOID_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestVoidResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_thrift_test_test_void_result_instance_init (TTestThriftTestTestVoidResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
t_test_thrift_test_test_void_result_finalize (GObject *object)
{
  TTestThriftTestTestVoidResult *tobject = T_TEST_THRIFT_TEST_TEST_VOID_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_thrift_test_test_void_result_class_init (TTestThriftTestTestVoidResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_void_result_read;
  struct_class->write = t_test_thrift_test_test_void_result_write;

  gobject_class->finalize = t_test_thrift_test_test_void_result_finalize;
}

GType
t_test_thrift_test_test_void_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestVoidResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_void_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestVoidResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_void_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestVoidResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestStringArgsProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_STRING_ARGS_0,
  PROP_T_TEST_THRIFT_TEST_TEST_STRING_ARGS_THING
};

/* reads a thrift_test_test_string_args object */
static gint32
t_test_thrift_test_test_string_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestStringArgs * this_object = T_TEST_THRIFT_TEST_TEST_STRING_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->thing != NULL)
          {
            g_free(this_object->thing);
            this_object->thing = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->thing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_string_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestStringArgs * this_object = T_TEST_THRIFT_TEST_TEST_STRING_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestStringArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->thing, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_string_args_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  TTestThriftTestTestStringArgs *self = T_TEST_THRIFT_TEST_TEST_STRING_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_STRING_ARGS_THING:
      if (self->thing != NULL)
        g_free (self->thing);
      self->thing = g_value_dup_string (value);
      self->__isset_thing = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_string_args_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  TTestThriftTestTestStringArgs *self = T_TEST_THRIFT_TEST_TEST_STRING_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_STRING_ARGS_THING:
      g_value_set_string (value, self->thing);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_string_args_instance_init (TTestThriftTestTestStringArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thing = NULL;
  object->__isset_thing = FALSE;
}

static void 
t_test_thrift_test_test_string_args_finalize (GObject *object)
{
  TTestThriftTestTestStringArgs *tobject = T_TEST_THRIFT_TEST_TEST_STRING_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thing != NULL)
  {
    g_free(tobject->thing);
    tobject->thing = NULL;
  }
}

static void
t_test_thrift_test_test_string_args_class_init (TTestThriftTestTestStringArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_string_args_read;
  struct_class->write = t_test_thrift_test_test_string_args_write;

  gobject_class->finalize = t_test_thrift_test_test_string_args_finalize;
  gobject_class->get_property = t_test_thrift_test_test_string_args_get_property;
  gobject_class->set_property = t_test_thrift_test_test_string_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_STRING_ARGS_THING,
     g_param_spec_string ("thing",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_string_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestStringArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_string_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestStringArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_string_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestStringArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestStringResultProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_STRING_RESULT_0,
  PROP_T_TEST_THRIFT_TEST_TEST_STRING_RESULT_SUCCESS
};

/* reads a thrift_test_test_string_result object */
static gint32
t_test_thrift_test_test_string_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestStringResult * this_object = T_TEST_THRIFT_TEST_TEST_STRING_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_string_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestStringResult * this_object = T_TEST_THRIFT_TEST_TEST_STRING_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestStringResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_string_result_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  TTestThriftTestTestStringResult *self = T_TEST_THRIFT_TEST_TEST_STRING_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_STRING_RESULT_SUCCESS:
      if (self->success != NULL)
        g_free (self->success);
      self->success = g_value_dup_string (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_string_result_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  TTestThriftTestTestStringResult *self = T_TEST_THRIFT_TEST_TEST_STRING_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_STRING_RESULT_SUCCESS:
      g_value_set_string (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_string_result_instance_init (TTestThriftTestTestStringResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
}

static void 
t_test_thrift_test_test_string_result_finalize (GObject *object)
{
  TTestThriftTestTestStringResult *tobject = T_TEST_THRIFT_TEST_TEST_STRING_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_free(tobject->success);
    tobject->success = NULL;
  }
}

static void
t_test_thrift_test_test_string_result_class_init (TTestThriftTestTestStringResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_string_result_read;
  struct_class->write = t_test_thrift_test_test_string_result_write;

  gobject_class->finalize = t_test_thrift_test_test_string_result_finalize;
  gobject_class->get_property = t_test_thrift_test_test_string_result_get_property;
  gobject_class->set_property = t_test_thrift_test_test_string_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_STRING_RESULT_SUCCESS,
     g_param_spec_string ("success",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_string_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestStringResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_string_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestStringResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_string_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestStringResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestBoolArgsProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_BOOL_ARGS_0,
  PROP_T_TEST_THRIFT_TEST_TEST_BOOL_ARGS_THING
};

/* reads a thrift_test_test_bool_args object */
static gint32
t_test_thrift_test_test_bool_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestBoolArgs * this_object = T_TEST_THRIFT_TEST_TEST_BOOL_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->thing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_bool_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestBoolArgs * this_object = T_TEST_THRIFT_TEST_TEST_BOOL_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestBoolArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->thing, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_bool_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  TTestThriftTestTestBoolArgs *self = T_TEST_THRIFT_TEST_TEST_BOOL_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_BOOL_ARGS_THING:
      self->thing = g_value_get_boolean (value);
      self->__isset_thing = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_bool_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  TTestThriftTestTestBoolArgs *self = T_TEST_THRIFT_TEST_TEST_BOOL_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_BOOL_ARGS_THING:
      g_value_set_boolean (value, self->thing);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_bool_args_instance_init (TTestThriftTestTestBoolArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thing = 0;
  object->__isset_thing = FALSE;
}

static void 
t_test_thrift_test_test_bool_args_finalize (GObject *object)
{
  TTestThriftTestTestBoolArgs *tobject = T_TEST_THRIFT_TEST_TEST_BOOL_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_thrift_test_test_bool_args_class_init (TTestThriftTestTestBoolArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_bool_args_read;
  struct_class->write = t_test_thrift_test_test_bool_args_write;

  gobject_class->finalize = t_test_thrift_test_test_bool_args_finalize;
  gobject_class->get_property = t_test_thrift_test_test_bool_args_get_property;
  gobject_class->set_property = t_test_thrift_test_test_bool_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_BOOL_ARGS_THING,
     g_param_spec_boolean ("thing",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_bool_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestBoolArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_bool_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestBoolArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_bool_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestBoolArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestBoolResultProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_BOOL_RESULT_0,
  PROP_T_TEST_THRIFT_TEST_TEST_BOOL_RESULT_SUCCESS
};

/* reads a thrift_test_test_bool_result object */
static gint32
t_test_thrift_test_test_bool_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestBoolResult * this_object = T_TEST_THRIFT_TEST_TEST_BOOL_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_bool_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestBoolResult * this_object = T_TEST_THRIFT_TEST_TEST_BOOL_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestBoolResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BOOL, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_bool_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  TTestThriftTestTestBoolResult *self = T_TEST_THRIFT_TEST_TEST_BOOL_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_BOOL_RESULT_SUCCESS:
      self->success = g_value_get_boolean (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_bool_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  TTestThriftTestTestBoolResult *self = T_TEST_THRIFT_TEST_TEST_BOOL_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_BOOL_RESULT_SUCCESS:
      g_value_set_boolean (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_bool_result_instance_init (TTestThriftTestTestBoolResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
t_test_thrift_test_test_bool_result_finalize (GObject *object)
{
  TTestThriftTestTestBoolResult *tobject = T_TEST_THRIFT_TEST_TEST_BOOL_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_thrift_test_test_bool_result_class_init (TTestThriftTestTestBoolResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_bool_result_read;
  struct_class->write = t_test_thrift_test_test_bool_result_write;

  gobject_class->finalize = t_test_thrift_test_test_bool_result_finalize;
  gobject_class->get_property = t_test_thrift_test_test_bool_result_get_property;
  gobject_class->set_property = t_test_thrift_test_test_bool_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_BOOL_RESULT_SUCCESS,
     g_param_spec_boolean ("success",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_bool_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestBoolResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_bool_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestBoolResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_bool_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestBoolResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestByteArgsProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_BYTE_ARGS_0,
  PROP_T_TEST_THRIFT_TEST_TEST_BYTE_ARGS_THING
};

/* reads a thrift_test_test_byte_args object */
static gint32
t_test_thrift_test_test_byte_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestByteArgs * this_object = T_TEST_THRIFT_TEST_TEST_BYTE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->thing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_byte_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestByteArgs * this_object = T_TEST_THRIFT_TEST_TEST_BYTE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestByteArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_BYTE, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->thing, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_byte_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  TTestThriftTestTestByteArgs *self = T_TEST_THRIFT_TEST_TEST_BYTE_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_BYTE_ARGS_THING:
      self->thing = g_value_get_int (value);
      self->__isset_thing = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_byte_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  TTestThriftTestTestByteArgs *self = T_TEST_THRIFT_TEST_TEST_BYTE_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_BYTE_ARGS_THING:
      g_value_set_int (value, self->thing);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_byte_args_instance_init (TTestThriftTestTestByteArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thing = 0;
  object->__isset_thing = FALSE;
}

static void 
t_test_thrift_test_test_byte_args_finalize (GObject *object)
{
  TTestThriftTestTestByteArgs *tobject = T_TEST_THRIFT_TEST_TEST_BYTE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_thrift_test_test_byte_args_class_init (TTestThriftTestTestByteArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_byte_args_read;
  struct_class->write = t_test_thrift_test_test_byte_args_write;

  gobject_class->finalize = t_test_thrift_test_test_byte_args_finalize;
  gobject_class->get_property = t_test_thrift_test_test_byte_args_get_property;
  gobject_class->set_property = t_test_thrift_test_test_byte_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_BYTE_ARGS_THING,
     g_param_spec_int ("thing",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_byte_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestByteArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_byte_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestByteArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_byte_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestByteArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestByteResultProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_BYTE_RESULT_0,
  PROP_T_TEST_THRIFT_TEST_TEST_BYTE_RESULT_SUCCESS
};

/* reads a thrift_test_test_byte_result object */
static gint32
t_test_thrift_test_test_byte_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestByteResult * this_object = T_TEST_THRIFT_TEST_TEST_BYTE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_byte_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestByteResult * this_object = T_TEST_THRIFT_TEST_TEST_BYTE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestByteResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BYTE, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_byte (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_byte_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  TTestThriftTestTestByteResult *self = T_TEST_THRIFT_TEST_TEST_BYTE_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_BYTE_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_byte_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  TTestThriftTestTestByteResult *self = T_TEST_THRIFT_TEST_TEST_BYTE_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_BYTE_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_byte_result_instance_init (TTestThriftTestTestByteResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
t_test_thrift_test_test_byte_result_finalize (GObject *object)
{
  TTestThriftTestTestByteResult *tobject = T_TEST_THRIFT_TEST_TEST_BYTE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_thrift_test_test_byte_result_class_init (TTestThriftTestTestByteResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_byte_result_read;
  struct_class->write = t_test_thrift_test_test_byte_result_write;

  gobject_class->finalize = t_test_thrift_test_test_byte_result_finalize;
  gobject_class->get_property = t_test_thrift_test_test_byte_result_get_property;
  gobject_class->set_property = t_test_thrift_test_test_byte_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_BYTE_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_byte_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestByteResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_byte_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestByteResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_byte_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestByteResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestI32ArgsProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_I32_ARGS_0,
  PROP_T_TEST_THRIFT_TEST_TEST_I32_ARGS_THING
};

/* reads a thrift_test_test_i32_args object */
static gint32
t_test_thrift_test_test_i32_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestI32Args * this_object = T_TEST_THRIFT_TEST_TEST_I32_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->thing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_i32_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestI32Args * this_object = T_TEST_THRIFT_TEST_TEST_I32_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestI32Args", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->thing, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_i32_args_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  TTestThriftTestTestI32Args *self = T_TEST_THRIFT_TEST_TEST_I32_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_I32_ARGS_THING:
      self->thing = g_value_get_int (value);
      self->__isset_thing = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_i32_args_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  TTestThriftTestTestI32Args *self = T_TEST_THRIFT_TEST_TEST_I32_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_I32_ARGS_THING:
      g_value_set_int (value, self->thing);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_i32_args_instance_init (TTestThriftTestTestI32Args * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thing = 0;
  object->__isset_thing = FALSE;
}

static void 
t_test_thrift_test_test_i32_args_finalize (GObject *object)
{
  TTestThriftTestTestI32Args *tobject = T_TEST_THRIFT_TEST_TEST_I32_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_thrift_test_test_i32_args_class_init (TTestThriftTestTestI32ArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_i32_args_read;
  struct_class->write = t_test_thrift_test_test_i32_args_write;

  gobject_class->finalize = t_test_thrift_test_test_i32_args_finalize;
  gobject_class->get_property = t_test_thrift_test_test_i32_args_get_property;
  gobject_class->set_property = t_test_thrift_test_test_i32_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_I32_ARGS_THING,
     g_param_spec_int ("thing",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_i32_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestI32ArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_i32_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestI32Args),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_i32_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestI32ArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestI32ResultProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_I32_RESULT_0,
  PROP_T_TEST_THRIFT_TEST_TEST_I32_RESULT_SUCCESS
};

/* reads a thrift_test_test_i32_result object */
static gint32
t_test_thrift_test_test_i32_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestI32Result * this_object = T_TEST_THRIFT_TEST_TEST_I32_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_i32_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestI32Result * this_object = T_TEST_THRIFT_TEST_TEST_I32_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestI32Result", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_i32_result_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  TTestThriftTestTestI32Result *self = T_TEST_THRIFT_TEST_TEST_I32_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_I32_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_i32_result_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  TTestThriftTestTestI32Result *self = T_TEST_THRIFT_TEST_TEST_I32_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_I32_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_i32_result_instance_init (TTestThriftTestTestI32Result * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
t_test_thrift_test_test_i32_result_finalize (GObject *object)
{
  TTestThriftTestTestI32Result *tobject = T_TEST_THRIFT_TEST_TEST_I32_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_thrift_test_test_i32_result_class_init (TTestThriftTestTestI32ResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_i32_result_read;
  struct_class->write = t_test_thrift_test_test_i32_result_write;

  gobject_class->finalize = t_test_thrift_test_test_i32_result_finalize;
  gobject_class->get_property = t_test_thrift_test_test_i32_result_get_property;
  gobject_class->set_property = t_test_thrift_test_test_i32_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_I32_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_i32_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestI32ResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_i32_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestI32Result),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_i32_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestI32ResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestI64ArgsProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_I64_ARGS_0,
  PROP_T_TEST_THRIFT_TEST_TEST_I64_ARGS_THING
};

/* reads a thrift_test_test_i64_args object */
static gint32
t_test_thrift_test_test_i64_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestI64Args * this_object = T_TEST_THRIFT_TEST_TEST_I64_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->thing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_i64_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestI64Args * this_object = T_TEST_THRIFT_TEST_TEST_I64_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestI64Args", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->thing, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_i64_args_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  TTestThriftTestTestI64Args *self = T_TEST_THRIFT_TEST_TEST_I64_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_I64_ARGS_THING:
      self->thing = g_value_get_int64 (value);
      self->__isset_thing = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_i64_args_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  TTestThriftTestTestI64Args *self = T_TEST_THRIFT_TEST_TEST_I64_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_I64_ARGS_THING:
      g_value_set_int64 (value, self->thing);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_i64_args_instance_init (TTestThriftTestTestI64Args * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thing = 0;
  object->__isset_thing = FALSE;
}

static void 
t_test_thrift_test_test_i64_args_finalize (GObject *object)
{
  TTestThriftTestTestI64Args *tobject = T_TEST_THRIFT_TEST_TEST_I64_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_thrift_test_test_i64_args_class_init (TTestThriftTestTestI64ArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_i64_args_read;
  struct_class->write = t_test_thrift_test_test_i64_args_write;

  gobject_class->finalize = t_test_thrift_test_test_i64_args_finalize;
  gobject_class->get_property = t_test_thrift_test_test_i64_args_get_property;
  gobject_class->set_property = t_test_thrift_test_test_i64_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_I64_ARGS_THING,
     g_param_spec_int64 ("thing",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_i64_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestI64ArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_i64_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestI64Args),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_i64_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestI64ArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestI64ResultProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_I64_RESULT_0,
  PROP_T_TEST_THRIFT_TEST_TEST_I64_RESULT_SUCCESS
};

/* reads a thrift_test_test_i64_result object */
static gint32
t_test_thrift_test_test_i64_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestI64Result * this_object = T_TEST_THRIFT_TEST_TEST_I64_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_i64_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestI64Result * this_object = T_TEST_THRIFT_TEST_TEST_I64_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestI64Result", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I64, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_i64_result_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  TTestThriftTestTestI64Result *self = T_TEST_THRIFT_TEST_TEST_I64_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_I64_RESULT_SUCCESS:
      self->success = g_value_get_int64 (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_i64_result_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  TTestThriftTestTestI64Result *self = T_TEST_THRIFT_TEST_TEST_I64_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_I64_RESULT_SUCCESS:
      g_value_set_int64 (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_i64_result_instance_init (TTestThriftTestTestI64Result * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
t_test_thrift_test_test_i64_result_finalize (GObject *object)
{
  TTestThriftTestTestI64Result *tobject = T_TEST_THRIFT_TEST_TEST_I64_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_thrift_test_test_i64_result_class_init (TTestThriftTestTestI64ResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_i64_result_read;
  struct_class->write = t_test_thrift_test_test_i64_result_write;

  gobject_class->finalize = t_test_thrift_test_test_i64_result_finalize;
  gobject_class->get_property = t_test_thrift_test_test_i64_result_get_property;
  gobject_class->set_property = t_test_thrift_test_test_i64_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_I64_RESULT_SUCCESS,
     g_param_spec_int64 ("success",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_i64_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestI64ResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_i64_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestI64Result),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_i64_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestI64ResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestDoubleArgsProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_DOUBLE_ARGS_0,
  PROP_T_TEST_THRIFT_TEST_TEST_DOUBLE_ARGS_THING
};

/* reads a thrift_test_test_double_args object */
static gint32
t_test_thrift_test_test_double_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestDoubleArgs * this_object = T_TEST_THRIFT_TEST_TEST_DOUBLE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->thing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_double_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestDoubleArgs * this_object = T_TEST_THRIFT_TEST_TEST_DOUBLE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestDoubleArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_DOUBLE, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->thing, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_double_args_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  TTestThriftTestTestDoubleArgs *self = T_TEST_THRIFT_TEST_TEST_DOUBLE_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_DOUBLE_ARGS_THING:
      self->thing = g_value_get_double (value);
      self->__isset_thing = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_double_args_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  TTestThriftTestTestDoubleArgs *self = T_TEST_THRIFT_TEST_TEST_DOUBLE_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_DOUBLE_ARGS_THING:
      g_value_set_double (value, self->thing);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_double_args_instance_init (TTestThriftTestTestDoubleArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thing = 0;
  object->__isset_thing = FALSE;
}

static void 
t_test_thrift_test_test_double_args_finalize (GObject *object)
{
  TTestThriftTestTestDoubleArgs *tobject = T_TEST_THRIFT_TEST_TEST_DOUBLE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_thrift_test_test_double_args_class_init (TTestThriftTestTestDoubleArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_double_args_read;
  struct_class->write = t_test_thrift_test_test_double_args_write;

  gobject_class->finalize = t_test_thrift_test_test_double_args_finalize;
  gobject_class->get_property = t_test_thrift_test_test_double_args_get_property;
  gobject_class->set_property = t_test_thrift_test_test_double_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_DOUBLE_ARGS_THING,
     g_param_spec_double ("thing",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_double_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestDoubleArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_double_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestDoubleArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_double_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestDoubleArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestDoubleResultProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_DOUBLE_RESULT_0,
  PROP_T_TEST_THRIFT_TEST_TEST_DOUBLE_RESULT_SUCCESS
};

/* reads a thrift_test_test_double_result object */
static gint32
t_test_thrift_test_test_double_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestDoubleResult * this_object = T_TEST_THRIFT_TEST_TEST_DOUBLE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_double_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestDoubleResult * this_object = T_TEST_THRIFT_TEST_TEST_DOUBLE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestDoubleResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_DOUBLE, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_double (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_double_result_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  TTestThriftTestTestDoubleResult *self = T_TEST_THRIFT_TEST_TEST_DOUBLE_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_DOUBLE_RESULT_SUCCESS:
      self->success = g_value_get_double (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_double_result_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  TTestThriftTestTestDoubleResult *self = T_TEST_THRIFT_TEST_TEST_DOUBLE_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_DOUBLE_RESULT_SUCCESS:
      g_value_set_double (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_double_result_instance_init (TTestThriftTestTestDoubleResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
t_test_thrift_test_test_double_result_finalize (GObject *object)
{
  TTestThriftTestTestDoubleResult *tobject = T_TEST_THRIFT_TEST_TEST_DOUBLE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_thrift_test_test_double_result_class_init (TTestThriftTestTestDoubleResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_double_result_read;
  struct_class->write = t_test_thrift_test_test_double_result_write;

  gobject_class->finalize = t_test_thrift_test_test_double_result_finalize;
  gobject_class->get_property = t_test_thrift_test_test_double_result_get_property;
  gobject_class->set_property = t_test_thrift_test_test_double_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_DOUBLE_RESULT_SUCCESS,
     g_param_spec_double ("success",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_double_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestDoubleResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_double_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestDoubleResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_double_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestDoubleResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestBinaryArgsProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_BINARY_ARGS_0,
  PROP_T_TEST_THRIFT_TEST_TEST_BINARY_ARGS_THING
};

/* reads a thrift_test_test_binary_args object */
static gint32
t_test_thrift_test_test_binary_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestBinaryArgs * this_object = T_TEST_THRIFT_TEST_TEST_BINARY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->thing != NULL)
          {
            g_free(this_object->thing);
            this_object->thing = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->thing = g_byte_array_new();
          g_byte_array_append (this_object->thing, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_binary_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestBinaryArgs * this_object = T_TEST_THRIFT_TEST_TEST_BINARY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestBinaryArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->thing)->data, ((GByteArray *) this_object->thing)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_binary_args_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  TTestThriftTestTestBinaryArgs *self = T_TEST_THRIFT_TEST_TEST_BINARY_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_BINARY_ARGS_THING:
      if (self->thing != NULL)
        g_byte_array_unref (self->thing);
      self->thing = g_value_dup_boxed (value);
      self->__isset_thing = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_binary_args_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  TTestThriftTestTestBinaryArgs *self = T_TEST_THRIFT_TEST_TEST_BINARY_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_BINARY_ARGS_THING:
      g_value_set_boxed (value, self->thing);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_binary_args_instance_init (TTestThriftTestTestBinaryArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thing = NULL;
  object->__isset_thing = FALSE;
}

static void 
t_test_thrift_test_test_binary_args_finalize (GObject *object)
{
  TTestThriftTestTestBinaryArgs *tobject = T_TEST_THRIFT_TEST_TEST_BINARY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thing != NULL)
  {
    thrift_string_free(tobject->thing);
    tobject->thing = NULL;
  }
}

static void
t_test_thrift_test_test_binary_args_class_init (TTestThriftTestTestBinaryArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_binary_args_read;
  struct_class->write = t_test_thrift_test_test_binary_args_write;

  gobject_class->finalize = t_test_thrift_test_test_binary_args_finalize;
  gobject_class->get_property = t_test_thrift_test_test_binary_args_get_property;
  gobject_class->set_property = t_test_thrift_test_test_binary_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_BINARY_ARGS_THING,
     g_param_spec_boxed ("thing",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_binary_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestBinaryArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_binary_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestBinaryArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_binary_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestBinaryArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestBinaryResultProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_BINARY_RESULT_0,
  PROP_T_TEST_THRIFT_TEST_TEST_BINARY_RESULT_SUCCESS
};

/* reads a thrift_test_test_binary_result object */
static gint32
t_test_thrift_test_test_binary_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestBinaryResult * this_object = T_TEST_THRIFT_TEST_TEST_BINARY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->success = g_byte_array_new();
          g_byte_array_append (this_object->success, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_binary_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestBinaryResult * this_object = T_TEST_THRIFT_TEST_TEST_BINARY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestBinaryResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->success)->data, ((GByteArray *) this_object->success)->len, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_binary_result_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  TTestThriftTestTestBinaryResult *self = T_TEST_THRIFT_TEST_TEST_BINARY_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_BINARY_RESULT_SUCCESS:
      if (self->success != NULL)
        g_byte_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_binary_result_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  TTestThriftTestTestBinaryResult *self = T_TEST_THRIFT_TEST_TEST_BINARY_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_BINARY_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_binary_result_instance_init (TTestThriftTestTestBinaryResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
}

static void 
t_test_thrift_test_test_binary_result_finalize (GObject *object)
{
  TTestThriftTestTestBinaryResult *tobject = T_TEST_THRIFT_TEST_TEST_BINARY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    thrift_string_free(tobject->success);
    tobject->success = NULL;
  }
}

static void
t_test_thrift_test_test_binary_result_class_init (TTestThriftTestTestBinaryResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_binary_result_read;
  struct_class->write = t_test_thrift_test_test_binary_result_write;

  gobject_class->finalize = t_test_thrift_test_test_binary_result_finalize;
  gobject_class->get_property = t_test_thrift_test_test_binary_result_get_property;
  gobject_class->set_property = t_test_thrift_test_test_binary_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_BINARY_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_binary_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestBinaryResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_binary_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestBinaryResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_binary_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestBinaryResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestStructArgsProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_STRUCT_ARGS_0,
  PROP_T_TEST_THRIFT_TEST_TEST_STRUCT_ARGS_THING
};

/* reads a thrift_test_test_struct_args object */
static gint32
t_test_thrift_test_test_struct_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestStructArgs * this_object = T_TEST_THRIFT_TEST_TEST_STRUCT_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->thing), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_struct_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestStructArgs * this_object = T_TEST_THRIFT_TEST_TEST_STRUCT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestStructArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->thing), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_struct_args_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  TTestThriftTestTestStructArgs *self = T_TEST_THRIFT_TEST_TEST_STRUCT_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_STRUCT_ARGS_THING:
      if (self->thing != NULL)
        g_object_unref (self->thing);
      self->thing = g_value_dup_object (value);
      self->__isset_thing = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_struct_args_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  TTestThriftTestTestStructArgs *self = T_TEST_THRIFT_TEST_TEST_STRUCT_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_STRUCT_ARGS_THING:
      g_value_set_object (value, self->thing);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_struct_args_instance_init (TTestThriftTestTestStructArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thing = g_object_new (T_TEST_TYPE_XTRUCT, NULL);
  object->__isset_thing = FALSE;
}

static void 
t_test_thrift_test_test_struct_args_finalize (GObject *object)
{
  TTestThriftTestTestStructArgs *tobject = T_TEST_THRIFT_TEST_TEST_STRUCT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thing != NULL)
  {
    g_object_unref(tobject->thing);
    tobject->thing = NULL;
  }
}

static void
t_test_thrift_test_test_struct_args_class_init (TTestThriftTestTestStructArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_struct_args_read;
  struct_class->write = t_test_thrift_test_test_struct_args_write;

  gobject_class->finalize = t_test_thrift_test_test_struct_args_finalize;
  gobject_class->get_property = t_test_thrift_test_test_struct_args_get_property;
  gobject_class->set_property = t_test_thrift_test_test_struct_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_STRUCT_ARGS_THING,
     g_param_spec_object ("thing",
                         NULL,
                         NULL,
                         T_TEST_TYPE_XTRUCT,
                         G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_struct_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestStructArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_struct_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestStructArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_struct_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestStructArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestStructResultProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_STRUCT_RESULT_0,
  PROP_T_TEST_THRIFT_TEST_TEST_STRUCT_RESULT_SUCCESS
};

/* reads a thrift_test_test_struct_result object */
static gint32
t_test_thrift_test_test_struct_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestStructResult * this_object = T_TEST_THRIFT_TEST_TEST_STRUCT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_struct_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestStructResult * this_object = T_TEST_THRIFT_TEST_TEST_STRUCT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestStructResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_struct_result_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  TTestThriftTestTestStructResult *self = T_TEST_THRIFT_TEST_TEST_STRUCT_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_STRUCT_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_struct_result_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  TTestThriftTestTestStructResult *self = T_TEST_THRIFT_TEST_TEST_STRUCT_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_STRUCT_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_struct_result_instance_init (TTestThriftTestTestStructResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (T_TEST_TYPE_XTRUCT, NULL);
  object->__isset_success = FALSE;
}

static void 
t_test_thrift_test_test_struct_result_finalize (GObject *object)
{
  TTestThriftTestTestStructResult *tobject = T_TEST_THRIFT_TEST_TEST_STRUCT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
t_test_thrift_test_test_struct_result_class_init (TTestThriftTestTestStructResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_struct_result_read;
  struct_class->write = t_test_thrift_test_test_struct_result_write;

  gobject_class->finalize = t_test_thrift_test_test_struct_result_finalize;
  gobject_class->get_property = t_test_thrift_test_test_struct_result_get_property;
  gobject_class->set_property = t_test_thrift_test_test_struct_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_STRUCT_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         T_TEST_TYPE_XTRUCT,
                         G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_struct_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestStructResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_struct_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestStructResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_struct_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestStructResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestNestArgsProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_NEST_ARGS_0,
  PROP_T_TEST_THRIFT_TEST_TEST_NEST_ARGS_THING
};

/* reads a thrift_test_test_nest_args object */
static gint32
t_test_thrift_test_test_nest_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestNestArgs * this_object = T_TEST_THRIFT_TEST_TEST_NEST_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->thing), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_nest_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestNestArgs * this_object = T_TEST_THRIFT_TEST_TEST_NEST_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestNestArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->thing), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_nest_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  TTestThriftTestTestNestArgs *self = T_TEST_THRIFT_TEST_TEST_NEST_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_NEST_ARGS_THING:
      if (self->thing != NULL)
        g_object_unref (self->thing);
      self->thing = g_value_dup_object (value);
      self->__isset_thing = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_nest_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  TTestThriftTestTestNestArgs *self = T_TEST_THRIFT_TEST_TEST_NEST_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_NEST_ARGS_THING:
      g_value_set_object (value, self->thing);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_nest_args_instance_init (TTestThriftTestTestNestArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thing = g_object_new (T_TEST_TYPE_XTRUCT2, NULL);
  object->__isset_thing = FALSE;
}

static void 
t_test_thrift_test_test_nest_args_finalize (GObject *object)
{
  TTestThriftTestTestNestArgs *tobject = T_TEST_THRIFT_TEST_TEST_NEST_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thing != NULL)
  {
    g_object_unref(tobject->thing);
    tobject->thing = NULL;
  }
}

static void
t_test_thrift_test_test_nest_args_class_init (TTestThriftTestTestNestArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_nest_args_read;
  struct_class->write = t_test_thrift_test_test_nest_args_write;

  gobject_class->finalize = t_test_thrift_test_test_nest_args_finalize;
  gobject_class->get_property = t_test_thrift_test_test_nest_args_get_property;
  gobject_class->set_property = t_test_thrift_test_test_nest_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_NEST_ARGS_THING,
     g_param_spec_object ("thing",
                         NULL,
                         NULL,
                         T_TEST_TYPE_XTRUCT2,
                         G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_nest_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestNestArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_nest_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestNestArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_nest_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestNestArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestNestResultProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_NEST_RESULT_0,
  PROP_T_TEST_THRIFT_TEST_TEST_NEST_RESULT_SUCCESS
};

/* reads a thrift_test_test_nest_result object */
static gint32
t_test_thrift_test_test_nest_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestNestResult * this_object = T_TEST_THRIFT_TEST_TEST_NEST_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_nest_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestNestResult * this_object = T_TEST_THRIFT_TEST_TEST_NEST_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestNestResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_nest_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  TTestThriftTestTestNestResult *self = T_TEST_THRIFT_TEST_TEST_NEST_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_NEST_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_nest_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  TTestThriftTestTestNestResult *self = T_TEST_THRIFT_TEST_TEST_NEST_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_NEST_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_nest_result_instance_init (TTestThriftTestTestNestResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (T_TEST_TYPE_XTRUCT2, NULL);
  object->__isset_success = FALSE;
}

static void 
t_test_thrift_test_test_nest_result_finalize (GObject *object)
{
  TTestThriftTestTestNestResult *tobject = T_TEST_THRIFT_TEST_TEST_NEST_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
t_test_thrift_test_test_nest_result_class_init (TTestThriftTestTestNestResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_nest_result_read;
  struct_class->write = t_test_thrift_test_test_nest_result_write;

  gobject_class->finalize = t_test_thrift_test_test_nest_result_finalize;
  gobject_class->get_property = t_test_thrift_test_test_nest_result_get_property;
  gobject_class->set_property = t_test_thrift_test_test_nest_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_NEST_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         T_TEST_TYPE_XTRUCT2,
                         G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_nest_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestNestResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_nest_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestNestResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_nest_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestNestResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestMapArgsProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_MAP_ARGS_0,
  PROP_T_TEST_THRIFT_TEST_TEST_MAP_ARGS_THING
};

/* reads a thrift_test_test_map_args object */
static gint32
t_test_thrift_test_test_map_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestMapArgs * this_object = T_TEST_THRIFT_TEST_TEST_MAP_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint32* key77 = g_new (gint32, 1);
              gint32* val78 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*key77, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_i32 (protocol, &*val78, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->thing, (gpointer) key77, (gpointer) val78);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_map_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestMapArgs * this_object = T_TEST_THRIFT_TEST_TEST_MAP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestMapArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_MAP, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint32* key79 = g_new (gint32, 1);
    gint32* val80 = g_new (gint32, 1);
    GList *key_list = NULL, *iter = NULL;
    gint32** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_I32, (gint32) g_hash_table_size ((GHashTable *) this_object->thing), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->thing, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint32*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint32*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key79 = keys[i];
      val80 = (gint32*) g_hash_table_lookup (((GHashTable *) this_object->thing), (gpointer) key79);

      if ((ret = thrift_protocol_write_i32 (protocol, * key79, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_i32 (protocol, * val80, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_map_args_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  TTestThriftTestTestMapArgs *self = T_TEST_THRIFT_TEST_TEST_MAP_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_MAP_ARGS_THING:
      if (self->thing != NULL)
        g_hash_table_unref (self->thing);
      self->thing = g_value_dup_boxed (value);
      self->__isset_thing = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_map_args_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  TTestThriftTestTestMapArgs *self = T_TEST_THRIFT_TEST_TEST_MAP_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_MAP_ARGS_THING:
      g_value_set_boxed (value, self->thing);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_map_args_instance_init (TTestThriftTestTestMapArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thing = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_free);
  object->__isset_thing = FALSE;
}

static void 
t_test_thrift_test_test_map_args_finalize (GObject *object)
{
  TTestThriftTestTestMapArgs *tobject = T_TEST_THRIFT_TEST_TEST_MAP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thing != NULL)
  {
    g_hash_table_destroy (tobject->thing);
    tobject->thing = NULL;
  }
}

static void
t_test_thrift_test_test_map_args_class_init (TTestThriftTestTestMapArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_map_args_read;
  struct_class->write = t_test_thrift_test_test_map_args_write;

  gobject_class->finalize = t_test_thrift_test_test_map_args_finalize;
  gobject_class->get_property = t_test_thrift_test_test_map_args_get_property;
  gobject_class->set_property = t_test_thrift_test_test_map_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_MAP_ARGS_THING,
     g_param_spec_boxed ("thing",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_map_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestMapArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_map_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestMapArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_map_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestMapArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestMapResultProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_MAP_RESULT_0,
  PROP_T_TEST_THRIFT_TEST_TEST_MAP_RESULT_SUCCESS
};

/* reads a thrift_test_test_map_result object */
static gint32
t_test_thrift_test_test_map_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestMapResult * this_object = T_TEST_THRIFT_TEST_TEST_MAP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint32* key81 = g_new (gint32, 1);
              gint32* val82 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*key81, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_i32 (protocol, &*val82, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->success, (gpointer) key81, (gpointer) val82);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_map_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestMapResult * this_object = T_TEST_THRIFT_TEST_TEST_MAP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestMapResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_MAP, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      gint32* key83 = g_new (gint32, 1);
      gint32* val84 = g_new (gint32, 1);
      GList *key_list = NULL, *iter = NULL;
      gint32** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_I32, (gint32) g_hash_table_size ((GHashTable *) this_object->success), error)) < 0)
        return -1;
      xfer += ret;
      g_hash_table_foreach ((GHashTable *) this_object->success, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gint32*, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gint32*) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key83 = keys[i];
        val84 = (gint32*) g_hash_table_lookup (((GHashTable *) this_object->success), (gpointer) key83);

        if ((ret = thrift_protocol_write_i32 (protocol, * key83, error)) < 0)
          return -1;
        if ((ret = thrift_protocol_write_i32 (protocol, * val84, error)) < 0)
          return -1;
      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_map_result_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  TTestThriftTestTestMapResult *self = T_TEST_THRIFT_TEST_TEST_MAP_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_MAP_RESULT_SUCCESS:
      if (self->success != NULL)
        g_hash_table_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_map_result_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  TTestThriftTestTestMapResult *self = T_TEST_THRIFT_TEST_TEST_MAP_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_MAP_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_map_result_instance_init (TTestThriftTestTestMapResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_free);
  object->__isset_success = FALSE;
}

static void 
t_test_thrift_test_test_map_result_finalize (GObject *object)
{
  TTestThriftTestTestMapResult *tobject = T_TEST_THRIFT_TEST_TEST_MAP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_hash_table_destroy (tobject->success);
    tobject->success = NULL;
  }
}

static void
t_test_thrift_test_test_map_result_class_init (TTestThriftTestTestMapResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_map_result_read;
  struct_class->write = t_test_thrift_test_test_map_result_write;

  gobject_class->finalize = t_test_thrift_test_test_map_result_finalize;
  gobject_class->get_property = t_test_thrift_test_test_map_result_get_property;
  gobject_class->set_property = t_test_thrift_test_test_map_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_MAP_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_map_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestMapResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_map_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestMapResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_map_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestMapResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestStringMapArgsProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_STRING_MAP_ARGS_0,
  PROP_T_TEST_THRIFT_TEST_TEST_STRING_MAP_ARGS_THING
};

/* reads a thrift_test_test_string_map_args object */
static gint32
t_test_thrift_test_test_string_map_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestStringMapArgs * this_object = T_TEST_THRIFT_TEST_TEST_STRING_MAP_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key85 = NULL;
              gchar * val86 = NULL;
              if (key85 != NULL)
              {
                g_free(key85);
                key85 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key85, error)) < 0)
                return -1;
              xfer += ret;
              if (val86 != NULL)
              {
                g_free(val86);
                val86 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val86, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->thing, (gpointer) key85, (gpointer) val86);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_string_map_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestStringMapArgs * this_object = T_TEST_THRIFT_TEST_TEST_STRING_MAP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestStringMapArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_MAP, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    gchar * key87 = NULL;
    gchar * val88 = NULL;
    GList *key_list = NULL, *iter = NULL;
    gchar ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, (gint32) g_hash_table_size ((GHashTable *) this_object->thing), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->thing, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gchar *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gchar *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key87 = keys[i];
      val88 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->thing), (gpointer) key87);

      if ((ret = thrift_protocol_write_string (protocol,  key87, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_string (protocol,  val88, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_string_map_args_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  TTestThriftTestTestStringMapArgs *self = T_TEST_THRIFT_TEST_TEST_STRING_MAP_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_STRING_MAP_ARGS_THING:
      if (self->thing != NULL)
        g_hash_table_unref (self->thing);
      self->thing = g_value_dup_boxed (value);
      self->__isset_thing = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_string_map_args_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  TTestThriftTestTestStringMapArgs *self = T_TEST_THRIFT_TEST_TEST_STRING_MAP_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_STRING_MAP_ARGS_THING:
      g_value_set_boxed (value, self->thing);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_string_map_args_instance_init (TTestThriftTestTestStringMapArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thing = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_thing = FALSE;
}

static void 
t_test_thrift_test_test_string_map_args_finalize (GObject *object)
{
  TTestThriftTestTestStringMapArgs *tobject = T_TEST_THRIFT_TEST_TEST_STRING_MAP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thing != NULL)
  {
    g_hash_table_destroy (tobject->thing);
    tobject->thing = NULL;
  }
}

static void
t_test_thrift_test_test_string_map_args_class_init (TTestThriftTestTestStringMapArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_string_map_args_read;
  struct_class->write = t_test_thrift_test_test_string_map_args_write;

  gobject_class->finalize = t_test_thrift_test_test_string_map_args_finalize;
  gobject_class->get_property = t_test_thrift_test_test_string_map_args_get_property;
  gobject_class->set_property = t_test_thrift_test_test_string_map_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_STRING_MAP_ARGS_THING,
     g_param_spec_boxed ("thing",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_string_map_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestStringMapArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_string_map_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestStringMapArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_string_map_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestStringMapArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestStringMapResultProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_STRING_MAP_RESULT_0,
  PROP_T_TEST_THRIFT_TEST_TEST_STRING_MAP_RESULT_SUCCESS
};

/* reads a thrift_test_test_string_map_result object */
static gint32
t_test_thrift_test_test_string_map_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestStringMapResult * this_object = T_TEST_THRIFT_TEST_TEST_STRING_MAP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key89 = NULL;
              gchar * val90 = NULL;
              if (key89 != NULL)
              {
                g_free(key89);
                key89 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key89, error)) < 0)
                return -1;
              xfer += ret;
              if (val90 != NULL)
              {
                g_free(val90);
                val90 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val90, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->success, (gpointer) key89, (gpointer) val90);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_string_map_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestStringMapResult * this_object = T_TEST_THRIFT_TEST_TEST_STRING_MAP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestStringMapResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_MAP, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key91 = NULL;
      gchar * val92 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, (gint32) g_hash_table_size ((GHashTable *) this_object->success), error)) < 0)
        return -1;
      xfer += ret;
      g_hash_table_foreach ((GHashTable *) this_object->success, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key91 = keys[i];
        val92 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->success), (gpointer) key91);

        if ((ret = thrift_protocol_write_string (protocol,  key91, error)) < 0)
          return -1;
        if ((ret = thrift_protocol_write_string (protocol,  val92, error)) < 0)
          return -1;
      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_string_map_result_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  TTestThriftTestTestStringMapResult *self = T_TEST_THRIFT_TEST_TEST_STRING_MAP_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_STRING_MAP_RESULT_SUCCESS:
      if (self->success != NULL)
        g_hash_table_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_string_map_result_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  TTestThriftTestTestStringMapResult *self = T_TEST_THRIFT_TEST_TEST_STRING_MAP_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_STRING_MAP_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_string_map_result_instance_init (TTestThriftTestTestStringMapResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_success = FALSE;
}

static void 
t_test_thrift_test_test_string_map_result_finalize (GObject *object)
{
  TTestThriftTestTestStringMapResult *tobject = T_TEST_THRIFT_TEST_TEST_STRING_MAP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_hash_table_destroy (tobject->success);
    tobject->success = NULL;
  }
}

static void
t_test_thrift_test_test_string_map_result_class_init (TTestThriftTestTestStringMapResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_string_map_result_read;
  struct_class->write = t_test_thrift_test_test_string_map_result_write;

  gobject_class->finalize = t_test_thrift_test_test_string_map_result_finalize;
  gobject_class->get_property = t_test_thrift_test_test_string_map_result_get_property;
  gobject_class->set_property = t_test_thrift_test_test_string_map_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_STRING_MAP_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_string_map_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestStringMapResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_string_map_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestStringMapResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_string_map_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestStringMapResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestSetArgsProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_SET_ARGS_0,
  PROP_T_TEST_THRIFT_TEST_TEST_SET_ARGS_THING
};

/* reads a thrift_test_test_set_args object */
static gint32
t_test_thrift_test_test_set_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestSetArgs * this_object = T_TEST_THRIFT_TEST_TEST_SET_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            for (i = 0; i < size; ++i)
            {
              gint32* _elem93 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem93, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *) this_object->thing, (gpointer) _elem93, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_set_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestSetArgs * this_object = T_TEST_THRIFT_TEST_TEST_SET_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestSetArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_SET, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    GList *key_list = NULL, *iter = NULL;
    gint32** keys;
    int i = 0, key_count;
    gint32* elem;
    gpointer value;
    THRIFT_UNUSED_VAR (value);

    if ((ret = thrift_protocol_write_set_begin (protocol, T_I32, (gint32) g_hash_table_size ((GHashTable *) this_object->thing), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->thing, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint32*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint32*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      elem = keys[i];
      value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->thing), (gpointer) elem);

      if ((ret = thrift_protocol_write_i32 (protocol, *elem, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_set_args_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  TTestThriftTestTestSetArgs *self = T_TEST_THRIFT_TEST_TEST_SET_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_SET_ARGS_THING:
      if (self->thing != NULL)
        g_hash_table_unref (self->thing);
      self->thing = g_value_dup_boxed (value);
      self->__isset_thing = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_set_args_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  TTestThriftTestTestSetArgs *self = T_TEST_THRIFT_TEST_TEST_SET_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_SET_ARGS_THING:
      g_value_set_boxed (value, self->thing);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_set_args_instance_init (TTestThriftTestTestSetArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thing = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, NULL);
  object->__isset_thing = FALSE;
}

static void 
t_test_thrift_test_test_set_args_finalize (GObject *object)
{
  TTestThriftTestTestSetArgs *tobject = T_TEST_THRIFT_TEST_TEST_SET_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thing != NULL)
  {
    g_hash_table_destroy (tobject->thing);
    tobject->thing = NULL;
  }
}

static void
t_test_thrift_test_test_set_args_class_init (TTestThriftTestTestSetArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_set_args_read;
  struct_class->write = t_test_thrift_test_test_set_args_write;

  gobject_class->finalize = t_test_thrift_test_test_set_args_finalize;
  gobject_class->get_property = t_test_thrift_test_test_set_args_get_property;
  gobject_class->set_property = t_test_thrift_test_test_set_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_SET_ARGS_THING,
     g_param_spec_boxed ("thing",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_set_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestSetArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_set_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestSetArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_set_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestSetArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestSetResultProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_SET_RESULT_0,
  PROP_T_TEST_THRIFT_TEST_TEST_SET_RESULT_SUCCESS
};

/* reads a thrift_test_test_set_result object */
static gint32
t_test_thrift_test_test_set_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestSetResult * this_object = T_TEST_THRIFT_TEST_TEST_SET_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            for (i = 0; i < size; ++i)
            {
              gint32* _elem94 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem94, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *) this_object->success, (gpointer) _elem94, (gpointer) 1);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_set_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestSetResult * this_object = T_TEST_THRIFT_TEST_TEST_SET_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestSetResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_SET, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      GList *key_list = NULL, *iter = NULL;
      gint32** keys;
      int i = 0, key_count;
      gint32* elem;
      gpointer value;
      THRIFT_UNUSED_VAR (value);

      if ((ret = thrift_protocol_write_set_begin (protocol, T_I32, (gint32) g_hash_table_size ((GHashTable *) this_object->success), error)) < 0)
        return -1;
      xfer += ret;
      g_hash_table_foreach ((GHashTable *) this_object->success, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gint32*, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gint32*) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        elem = keys[i];
        value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->success), (gpointer) elem);

        if ((ret = thrift_protocol_write_i32 (protocol, *elem, error)) < 0)
          return -1;
      }
      if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_set_result_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  TTestThriftTestTestSetResult *self = T_TEST_THRIFT_TEST_TEST_SET_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_SET_RESULT_SUCCESS:
      if (self->success != NULL)
        g_hash_table_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_set_result_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  TTestThriftTestTestSetResult *self = T_TEST_THRIFT_TEST_TEST_SET_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_SET_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_set_result_instance_init (TTestThriftTestTestSetResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, NULL);
  object->__isset_success = FALSE;
}

static void 
t_test_thrift_test_test_set_result_finalize (GObject *object)
{
  TTestThriftTestTestSetResult *tobject = T_TEST_THRIFT_TEST_TEST_SET_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_hash_table_destroy (tobject->success);
    tobject->success = NULL;
  }
}

static void
t_test_thrift_test_test_set_result_class_init (TTestThriftTestTestSetResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_set_result_read;
  struct_class->write = t_test_thrift_test_test_set_result_write;

  gobject_class->finalize = t_test_thrift_test_test_set_result_finalize;
  gobject_class->get_property = t_test_thrift_test_test_set_result_get_property;
  gobject_class->set_property = t_test_thrift_test_test_set_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_SET_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_set_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestSetResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_set_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestSetResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_set_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestSetResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestListArgsProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_LIST_ARGS_0,
  PROP_T_TEST_THRIFT_TEST_TEST_LIST_ARGS_THING
};

/* reads a thrift_test_test_list_args object */
static gint32
t_test_thrift_test_test_list_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestListArgs * this_object = T_TEST_THRIFT_TEST_TEST_LIST_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem95 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem95, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->thing, _elem95, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_list_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestListArgs * this_object = T_TEST_THRIFT_TEST_TEST_LIST_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestListArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i96;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) this_object->thing->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i96 = 0; i96 < this_object->thing->len; i96++)
    {
      if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->thing, gint32, i96)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_list_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  TTestThriftTestTestListArgs *self = T_TEST_THRIFT_TEST_TEST_LIST_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_LIST_ARGS_THING:
      if (self->thing != NULL)
        g_array_unref (self->thing);
      self->thing = g_value_dup_boxed (value);
      self->__isset_thing = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_list_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  TTestThriftTestTestListArgs *self = T_TEST_THRIFT_TEST_TEST_LIST_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_LIST_ARGS_THING:
      g_value_set_boxed (value, self->thing);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_list_args_instance_init (TTestThriftTestTestListArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thing = g_array_new (0, 1, sizeof (gint32));
  object->__isset_thing = FALSE;
}

static void 
t_test_thrift_test_test_list_args_finalize (GObject *object)
{
  TTestThriftTestTestListArgs *tobject = T_TEST_THRIFT_TEST_TEST_LIST_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thing != NULL)
  {
    g_array_unref (tobject->thing);
    tobject->thing = NULL;
  }
}

static void
t_test_thrift_test_test_list_args_class_init (TTestThriftTestTestListArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_list_args_read;
  struct_class->write = t_test_thrift_test_test_list_args_write;

  gobject_class->finalize = t_test_thrift_test_test_list_args_finalize;
  gobject_class->get_property = t_test_thrift_test_test_list_args_get_property;
  gobject_class->set_property = t_test_thrift_test_test_list_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_LIST_ARGS_THING,
     g_param_spec_boxed ("thing",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_list_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestListArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_list_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestListArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_list_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestListArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestListResultProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_LIST_RESULT_0,
  PROP_T_TEST_THRIFT_TEST_TEST_LIST_RESULT_SUCCESS
};

/* reads a thrift_test_test_list_result object */
static gint32
t_test_thrift_test_test_list_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestListResult * this_object = T_TEST_THRIFT_TEST_TEST_LIST_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem97 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem97, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->success, _elem97, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_list_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestListResult * this_object = T_TEST_THRIFT_TEST_TEST_LIST_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestListResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i98;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) this_object->success->len, error)) < 0)
        return -1;
      xfer += ret;
      for (i98 = 0; i98 < this_object->success->len; i98++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->success, gint32, i98)), error)) < 0)
          return -1;
      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_list_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  TTestThriftTestTestListResult *self = T_TEST_THRIFT_TEST_TEST_LIST_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_LIST_RESULT_SUCCESS:
      if (self->success != NULL)
        g_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_list_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  TTestThriftTestTestListResult *self = T_TEST_THRIFT_TEST_TEST_LIST_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_LIST_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_list_result_instance_init (TTestThriftTestTestListResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_array_new (0, 1, sizeof (gint32));
  object->__isset_success = FALSE;
}

static void 
t_test_thrift_test_test_list_result_finalize (GObject *object)
{
  TTestThriftTestTestListResult *tobject = T_TEST_THRIFT_TEST_TEST_LIST_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_array_unref (tobject->success);
    tobject->success = NULL;
  }
}

static void
t_test_thrift_test_test_list_result_class_init (TTestThriftTestTestListResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_list_result_read;
  struct_class->write = t_test_thrift_test_test_list_result_write;

  gobject_class->finalize = t_test_thrift_test_test_list_result_finalize;
  gobject_class->get_property = t_test_thrift_test_test_list_result_get_property;
  gobject_class->set_property = t_test_thrift_test_test_list_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_LIST_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_list_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestListResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_list_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestListResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_list_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestListResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestEnumArgsProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_ENUM_ARGS_0,
  PROP_T_TEST_THRIFT_TEST_TEST_ENUM_ARGS_THING
};

/* reads a thrift_test_test_enum_args object */
static gint32
t_test_thrift_test_test_enum_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestEnumArgs * this_object = T_TEST_THRIFT_TEST_TEST_ENUM_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast99;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast99, error)) < 0)
            return -1;
          xfer += ret;
          this_object->thing = (TTestNumberz)ecast99;
          this_object->__isset_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_enum_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestEnumArgs * this_object = T_TEST_THRIFT_TEST_TEST_ENUM_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestEnumArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->thing, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_enum_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  TTestThriftTestTestEnumArgs *self = T_TEST_THRIFT_TEST_TEST_ENUM_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_ENUM_ARGS_THING:
      self->thing = g_value_get_int (value);
      self->__isset_thing = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_enum_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  TTestThriftTestTestEnumArgs *self = T_TEST_THRIFT_TEST_TEST_ENUM_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_ENUM_ARGS_THING:
      g_value_set_int (value, self->thing);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_enum_args_instance_init (TTestThriftTestTestEnumArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_thing = FALSE;
}

static void 
t_test_thrift_test_test_enum_args_finalize (GObject *object)
{
  TTestThriftTestTestEnumArgs *tobject = T_TEST_THRIFT_TEST_TEST_ENUM_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_thrift_test_test_enum_args_class_init (TTestThriftTestTestEnumArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_enum_args_read;
  struct_class->write = t_test_thrift_test_test_enum_args_write;

  gobject_class->finalize = t_test_thrift_test_test_enum_args_finalize;
  gobject_class->get_property = t_test_thrift_test_test_enum_args_get_property;
  gobject_class->set_property = t_test_thrift_test_test_enum_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_ENUM_ARGS_THING,
     g_param_spec_int ("thing",
                       NULL,
                       NULL,
                       1,
                       8,
                       1,
                       G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_enum_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestEnumArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_enum_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestEnumArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_enum_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestEnumArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestEnumResultProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_ENUM_RESULT_0,
  PROP_T_TEST_THRIFT_TEST_TEST_ENUM_RESULT_SUCCESS
};

/* reads a thrift_test_test_enum_result object */
static gint32
t_test_thrift_test_test_enum_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestEnumResult * this_object = T_TEST_THRIFT_TEST_TEST_ENUM_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          gint32 ecast100;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast100, error)) < 0)
            return -1;
          xfer += ret;
          this_object->success = (TTestNumberz)ecast100;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_enum_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestEnumResult * this_object = T_TEST_THRIFT_TEST_TEST_ENUM_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestEnumResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_enum_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  TTestThriftTestTestEnumResult *self = T_TEST_THRIFT_TEST_TEST_ENUM_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_ENUM_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_enum_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  TTestThriftTestTestEnumResult *self = T_TEST_THRIFT_TEST_TEST_ENUM_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_ENUM_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_enum_result_instance_init (TTestThriftTestTestEnumResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_success = FALSE;
}

static void 
t_test_thrift_test_test_enum_result_finalize (GObject *object)
{
  TTestThriftTestTestEnumResult *tobject = T_TEST_THRIFT_TEST_TEST_ENUM_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_thrift_test_test_enum_result_class_init (TTestThriftTestTestEnumResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_enum_result_read;
  struct_class->write = t_test_thrift_test_test_enum_result_write;

  gobject_class->finalize = t_test_thrift_test_test_enum_result_finalize;
  gobject_class->get_property = t_test_thrift_test_test_enum_result_get_property;
  gobject_class->set_property = t_test_thrift_test_test_enum_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_ENUM_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       1,
                       8,
                       1,
                       G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_enum_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestEnumResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_enum_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestEnumResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_enum_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestEnumResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestTypedefArgsProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_TYPEDEF_ARGS_0,
  PROP_T_TEST_THRIFT_TEST_TEST_TYPEDEF_ARGS_THING
};

/* reads a thrift_test_test_typedef_args object */
static gint32
t_test_thrift_test_test_typedef_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestTypedefArgs * this_object = T_TEST_THRIFT_TEST_TEST_TYPEDEF_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->thing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_typedef_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestTypedefArgs * this_object = T_TEST_THRIFT_TEST_TEST_TYPEDEF_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestTypedefArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->thing, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_typedef_args_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  TTestThriftTestTestTypedefArgs *self = T_TEST_THRIFT_TEST_TEST_TYPEDEF_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_TYPEDEF_ARGS_THING:
      self->thing = g_value_get_int64 (value);
      self->__isset_thing = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_typedef_args_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  TTestThriftTestTestTypedefArgs *self = T_TEST_THRIFT_TEST_TEST_TYPEDEF_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_TYPEDEF_ARGS_THING:
      g_value_set_int64 (value, self->thing);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_typedef_args_instance_init (TTestThriftTestTestTypedefArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thing = 0;
  object->__isset_thing = FALSE;
}

static void 
t_test_thrift_test_test_typedef_args_finalize (GObject *object)
{
  TTestThriftTestTestTypedefArgs *tobject = T_TEST_THRIFT_TEST_TEST_TYPEDEF_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_thrift_test_test_typedef_args_class_init (TTestThriftTestTestTypedefArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_typedef_args_read;
  struct_class->write = t_test_thrift_test_test_typedef_args_write;

  gobject_class->finalize = t_test_thrift_test_test_typedef_args_finalize;
  gobject_class->get_property = t_test_thrift_test_test_typedef_args_get_property;
  gobject_class->set_property = t_test_thrift_test_test_typedef_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_TYPEDEF_ARGS_THING,
     g_param_spec_int64 ("thing",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_typedef_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestTypedefArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_typedef_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestTypedefArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_typedef_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestTypedefArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestTypedefResultProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_TYPEDEF_RESULT_0,
  PROP_T_TEST_THRIFT_TEST_TEST_TYPEDEF_RESULT_SUCCESS
};

/* reads a thrift_test_test_typedef_result object */
static gint32
t_test_thrift_test_test_typedef_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestTypedefResult * this_object = T_TEST_THRIFT_TEST_TEST_TYPEDEF_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_typedef_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestTypedefResult * this_object = T_TEST_THRIFT_TEST_TEST_TYPEDEF_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestTypedefResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I64, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_typedef_result_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  TTestThriftTestTestTypedefResult *self = T_TEST_THRIFT_TEST_TEST_TYPEDEF_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_TYPEDEF_RESULT_SUCCESS:
      self->success = g_value_get_int64 (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_typedef_result_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  TTestThriftTestTestTypedefResult *self = T_TEST_THRIFT_TEST_TEST_TYPEDEF_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_TYPEDEF_RESULT_SUCCESS:
      g_value_set_int64 (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_typedef_result_instance_init (TTestThriftTestTestTypedefResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
t_test_thrift_test_test_typedef_result_finalize (GObject *object)
{
  TTestThriftTestTestTypedefResult *tobject = T_TEST_THRIFT_TEST_TEST_TYPEDEF_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_thrift_test_test_typedef_result_class_init (TTestThriftTestTestTypedefResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_typedef_result_read;
  struct_class->write = t_test_thrift_test_test_typedef_result_write;

  gobject_class->finalize = t_test_thrift_test_test_typedef_result_finalize;
  gobject_class->get_property = t_test_thrift_test_test_typedef_result_get_property;
  gobject_class->set_property = t_test_thrift_test_test_typedef_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_TYPEDEF_RESULT_SUCCESS,
     g_param_spec_int64 ("success",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_typedef_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestTypedefResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_typedef_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestTypedefResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_typedef_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestTypedefResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestMapMapArgsProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_MAP_MAP_ARGS_0,
  PROP_T_TEST_THRIFT_TEST_TEST_MAP_MAP_ARGS_HELLO
};

/* reads a thrift_test_test_map_map_args object */
static gint32
t_test_thrift_test_test_map_map_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestMapMapArgs * this_object = T_TEST_THRIFT_TEST_TEST_MAP_MAP_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->hello, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_hello = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_map_map_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestMapMapArgs * this_object = T_TEST_THRIFT_TEST_TEST_MAP_MAP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestMapMapArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "hello", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->hello, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_map_map_args_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  TTestThriftTestTestMapMapArgs *self = T_TEST_THRIFT_TEST_TEST_MAP_MAP_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_MAP_MAP_ARGS_HELLO:
      self->hello = g_value_get_int (value);
      self->__isset_hello = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_map_map_args_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  TTestThriftTestTestMapMapArgs *self = T_TEST_THRIFT_TEST_TEST_MAP_MAP_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_MAP_MAP_ARGS_HELLO:
      g_value_set_int (value, self->hello);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_map_map_args_instance_init (TTestThriftTestTestMapMapArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->hello = 0;
  object->__isset_hello = FALSE;
}

static void 
t_test_thrift_test_test_map_map_args_finalize (GObject *object)
{
  TTestThriftTestTestMapMapArgs *tobject = T_TEST_THRIFT_TEST_TEST_MAP_MAP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_thrift_test_test_map_map_args_class_init (TTestThriftTestTestMapMapArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_map_map_args_read;
  struct_class->write = t_test_thrift_test_test_map_map_args_write;

  gobject_class->finalize = t_test_thrift_test_test_map_map_args_finalize;
  gobject_class->get_property = t_test_thrift_test_test_map_map_args_get_property;
  gobject_class->set_property = t_test_thrift_test_test_map_map_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_MAP_MAP_ARGS_HELLO,
     g_param_spec_int ("hello",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_map_map_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestMapMapArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_map_map_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestMapMapArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_map_map_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestMapMapArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestMapMapResultProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_MAP_MAP_RESULT_0,
  PROP_T_TEST_THRIFT_TEST_TEST_MAP_MAP_RESULT_SUCCESS
};

/* reads a thrift_test_test_map_map_result object */
static gint32
t_test_thrift_test_test_map_map_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestMapMapResult * this_object = T_TEST_THRIFT_TEST_TEST_MAP_MAP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint32* key101 = g_new (gint32, 1);
              GHashTable * val102 = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_free);
              if ((ret = thrift_protocol_read_i32 (protocol, &*key101, error)) < 0)
                return -1;
              xfer += ret;
              {
                guint32 size;
                guint32 i;
                ThriftType key_type;
                ThriftType value_type;

                /* read the map begin marker */
                if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through each of the map's fields */
                for (i = 0; i < size; i++)
                {
                  gint32* key103 = g_new (gint32, 1);
                  gint32* val104 = g_new (gint32, 1);
                  if ((ret = thrift_protocol_read_i32 (protocol, &*key103, error)) < 0)
                    return -1;
                  xfer += ret;
                  if ((ret = thrift_protocol_read_i32 (protocol, &*val104, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_hash_table_insert ((GHashTable *)val102, (gpointer) key103, (gpointer) val104);
                }

                /* read the map end marker */
                if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              g_hash_table_insert ((GHashTable *)this_object->success, (gpointer) key101, (gpointer) val102);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_map_map_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestMapMapResult * this_object = T_TEST_THRIFT_TEST_TEST_MAP_MAP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestMapMapResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_MAP, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      gint32* key105 = g_new (gint32, 1);
      GHashTable * val106 = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_free);
      GList *key_list = NULL, *iter = NULL;
      gint32** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_MAP, (gint32) g_hash_table_size ((GHashTable *) this_object->success), error)) < 0)
        return -1;
      xfer += ret;
      g_hash_table_foreach ((GHashTable *) this_object->success, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gint32*, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gint32*) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key105 = keys[i];
        val106 = (GHashTable *) g_hash_table_lookup (((GHashTable *) this_object->success), (gpointer) key105);

        if ((ret = thrift_protocol_write_i32 (protocol, * key105, error)) < 0)
          return -1;
        {
          gint32* key107 = g_new (gint32, 1);
          gint32* val108 = g_new (gint32, 1);
          GList *key_list = NULL, *iter = NULL;
          gint32** keys;
          int i = 0, key_count;

          if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_I32, (gint32) g_hash_table_size ((GHashTable *)  val106), error)) < 0)
            return -1;
          xfer += ret;
          g_hash_table_foreach ((GHashTable *)  val106, thrift_hash_table_get_keys, &key_list);
          key_count = g_list_length (key_list);
          keys = g_newa (gint32*, key_count);
          for (iter = g_list_first (key_list); iter; iter = iter->next)
            keys[i++] = (gint32*) iter->data;
          g_list_free (key_list);

          for (i = 0; i < key_count; ++i)
          {
            key107 = keys[i];
            val108 = (gint32*) g_hash_table_lookup (((GHashTable *)  val106), (gpointer) key107);

            if ((ret = thrift_protocol_write_i32 (protocol, * key107, error)) < 0)
              return -1;
            if ((ret = thrift_protocol_write_i32 (protocol, * val108, error)) < 0)
              return -1;
          }
          if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
            return -1;
          xfer += ret;
        }
      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_map_map_result_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  TTestThriftTestTestMapMapResult *self = T_TEST_THRIFT_TEST_TEST_MAP_MAP_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_MAP_MAP_RESULT_SUCCESS:
      if (self->success != NULL)
        g_hash_table_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_map_map_result_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  TTestThriftTestTestMapMapResult *self = T_TEST_THRIFT_TEST_TEST_MAP_MAP_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_MAP_MAP_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_map_map_result_instance_init (TTestThriftTestTestMapMapResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, (GDestroyNotify) g_hash_table_destroy);
  object->__isset_success = FALSE;
}

static void 
t_test_thrift_test_test_map_map_result_finalize (GObject *object)
{
  TTestThriftTestTestMapMapResult *tobject = T_TEST_THRIFT_TEST_TEST_MAP_MAP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_hash_table_destroy (tobject->success);
    tobject->success = NULL;
  }
}

static void
t_test_thrift_test_test_map_map_result_class_init (TTestThriftTestTestMapMapResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_map_map_result_read;
  struct_class->write = t_test_thrift_test_test_map_map_result_write;

  gobject_class->finalize = t_test_thrift_test_test_map_map_result_finalize;
  gobject_class->get_property = t_test_thrift_test_test_map_map_result_get_property;
  gobject_class->set_property = t_test_thrift_test_test_map_map_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_MAP_MAP_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_map_map_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestMapMapResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_map_map_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestMapMapResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_map_map_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestMapMapResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestInsanityArgsProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_INSANITY_ARGS_0,
  PROP_T_TEST_THRIFT_TEST_TEST_INSANITY_ARGS_ARGUMENT
};

/* reads a thrift_test_test_insanity_args object */
static gint32
t_test_thrift_test_test_insanity_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestInsanityArgs * this_object = T_TEST_THRIFT_TEST_TEST_INSANITY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->argument), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_argument = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_insanity_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestInsanityArgs * this_object = T_TEST_THRIFT_TEST_TEST_INSANITY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestInsanityArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "argument", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->argument), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_insanity_args_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  TTestThriftTestTestInsanityArgs *self = T_TEST_THRIFT_TEST_TEST_INSANITY_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_INSANITY_ARGS_ARGUMENT:
      if (self->argument != NULL)
        g_object_unref (self->argument);
      self->argument = g_value_dup_object (value);
      self->__isset_argument = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_insanity_args_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  TTestThriftTestTestInsanityArgs *self = T_TEST_THRIFT_TEST_TEST_INSANITY_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_INSANITY_ARGS_ARGUMENT:
      g_value_set_object (value, self->argument);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_insanity_args_instance_init (TTestThriftTestTestInsanityArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->argument = g_object_new (T_TEST_TYPE_INSANITY, NULL);
  object->__isset_argument = FALSE;
}

static void 
t_test_thrift_test_test_insanity_args_finalize (GObject *object)
{
  TTestThriftTestTestInsanityArgs *tobject = T_TEST_THRIFT_TEST_TEST_INSANITY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->argument != NULL)
  {
    g_object_unref(tobject->argument);
    tobject->argument = NULL;
  }
}

static void
t_test_thrift_test_test_insanity_args_class_init (TTestThriftTestTestInsanityArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_insanity_args_read;
  struct_class->write = t_test_thrift_test_test_insanity_args_write;

  gobject_class->finalize = t_test_thrift_test_test_insanity_args_finalize;
  gobject_class->get_property = t_test_thrift_test_test_insanity_args_get_property;
  gobject_class->set_property = t_test_thrift_test_test_insanity_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_INSANITY_ARGS_ARGUMENT,
     g_param_spec_object ("argument",
                         NULL,
                         NULL,
                         T_TEST_TYPE_INSANITY,
                         G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_insanity_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestInsanityArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_insanity_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestInsanityArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_insanity_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestInsanityArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestInsanityResultProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_INSANITY_RESULT_0,
  PROP_T_TEST_THRIFT_TEST_TEST_INSANITY_RESULT_SUCCESS
};

/* reads a thrift_test_test_insanity_result object */
static gint32
t_test_thrift_test_test_insanity_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestInsanityResult * this_object = T_TEST_THRIFT_TEST_TEST_INSANITY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              TTestUserId* key109 = g_new (TTestUserId, 1);
              GHashTable * val110 = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_object_unref);
              if ((ret = thrift_protocol_read_i64 (protocol, &*key109, error)) < 0)
                return -1;
              xfer += ret;
              {
                guint32 size;
                guint32 i;
                ThriftType key_type;
                ThriftType value_type;

                /* read the map begin marker */
                if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through each of the map's fields */
                for (i = 0; i < size; i++)
                {
                  TTestNumberz key111;
                  TTestInsanity * val112 = NULL;
                  gint32 ecast113;
                  if ((ret = thrift_protocol_read_i32 (protocol, &ecast113, error)) < 0)
                    return -1;
                  xfer += ret;
                  key111 = (TTestNumberz)ecast113;
                  if ( val112 != NULL)
                  {
                    g_object_unref (val112);
                  }
                  val112 = g_object_new (T_TEST_TYPE_INSANITY, NULL);
                  if ((ret = thrift_struct_read (THRIFT_STRUCT (val112), protocol, error)) < 0)
                  {
                    g_object_unref (val112);
                    return -1;
                  }
                  xfer += ret;
                  g_hash_table_insert ((GHashTable *)val110, (gpointer) key111, (gpointer) val112);
                }

                /* read the map end marker */
                if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              g_hash_table_insert ((GHashTable *)this_object->success, (gpointer) key109, (gpointer) val110);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_insanity_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestInsanityResult * this_object = T_TEST_THRIFT_TEST_TEST_INSANITY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestInsanityResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_MAP, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      TTestUserId* key114 = g_new (TTestUserId, 1);
      GHashTable * val115 = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_object_unref);
      GList *key_list = NULL, *iter = NULL;
      TTestUserId** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_I64, T_MAP, (gint32) g_hash_table_size ((GHashTable *) this_object->success), error)) < 0)
        return -1;
      xfer += ret;
      g_hash_table_foreach ((GHashTable *) this_object->success, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (TTestUserId*, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (TTestUserId*) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key114 = keys[i];
        val115 = (GHashTable *) g_hash_table_lookup (((GHashTable *) this_object->success), (gpointer) key114);

        if ((ret = thrift_protocol_write_i64 (protocol, * key114, error)) < 0)
          return -1;
        {
          TTestNumberz key116;
          TTestInsanity * val117 = NULL;
          GList *key_list = NULL, *iter = NULL;
          TTestNumberz* keys;
          int i = 0, key_count;

          if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_STRUCT, (gint32) g_hash_table_size ((GHashTable *)  val115), error)) < 0)
            return -1;
          xfer += ret;
          g_hash_table_foreach ((GHashTable *)  val115, thrift_hash_table_get_keys, &key_list);
          key_count = g_list_length (key_list);
          keys = g_newa (TTestNumberz, key_count);
          for (iter = g_list_first (key_list); iter; iter = iter->next)
            keys[i++] = (TTestNumberz) iter->data;
          g_list_free (key_list);

          for (i = 0; i < key_count; ++i)
          {
            key116 = keys[i];
            val117 = (TTestInsanity *) g_hash_table_lookup (((GHashTable *)  val115), (gpointer) key116);

            if ((ret = thrift_protocol_write_i32 (protocol, (gint32)  key116, error)) < 0)
              return -1;
            if ((ret = thrift_struct_write (THRIFT_STRUCT ( val117), protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
            return -1;
          xfer += ret;
        }
      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_insanity_result_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  TTestThriftTestTestInsanityResult *self = T_TEST_THRIFT_TEST_TEST_INSANITY_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_INSANITY_RESULT_SUCCESS:
      if (self->success != NULL)
        g_hash_table_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_insanity_result_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  TTestThriftTestTestInsanityResult *self = T_TEST_THRIFT_TEST_TEST_INSANITY_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_INSANITY_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_insanity_result_instance_init (TTestThriftTestTestInsanityResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_hash_table_new_full (g_int64_hash, g_int64_equal, g_free, (GDestroyNotify) g_hash_table_destroy);
  object->__isset_success = FALSE;
}

static void 
t_test_thrift_test_test_insanity_result_finalize (GObject *object)
{
  TTestThriftTestTestInsanityResult *tobject = T_TEST_THRIFT_TEST_TEST_INSANITY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_hash_table_destroy (tobject->success);
    tobject->success = NULL;
  }
}

static void
t_test_thrift_test_test_insanity_result_class_init (TTestThriftTestTestInsanityResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_insanity_result_read;
  struct_class->write = t_test_thrift_test_test_insanity_result_write;

  gobject_class->finalize = t_test_thrift_test_test_insanity_result_finalize;
  gobject_class->get_property = t_test_thrift_test_test_insanity_result_get_property;
  gobject_class->set_property = t_test_thrift_test_test_insanity_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_INSANITY_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_insanity_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestInsanityResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_insanity_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestInsanityResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_insanity_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestInsanityResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestMultiArgsProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_MULTI_ARGS_0,
  PROP_T_TEST_THRIFT_TEST_TEST_MULTI_ARGS_ARG0,
  PROP_T_TEST_THRIFT_TEST_TEST_MULTI_ARGS_ARG1,
  PROP_T_TEST_THRIFT_TEST_TEST_MULTI_ARGS_ARG2,
  PROP_T_TEST_THRIFT_TEST_TEST_MULTI_ARGS_ARG3,
  PROP_T_TEST_THRIFT_TEST_TEST_MULTI_ARGS_ARG4,
  PROP_T_TEST_THRIFT_TEST_TEST_MULTI_ARGS_ARG5
};

/* reads a thrift_test_test_multi_args object */
static gint32
t_test_thrift_test_test_multi_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestMultiArgs * this_object = T_TEST_THRIFT_TEST_TEST_MULTI_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->arg0, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_arg0 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->arg1, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_arg1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->arg2, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_arg2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint16* key118 = g_new (gint16, 1);
              gchar * val119 = NULL;
              if ((ret = thrift_protocol_read_i16 (protocol, &*key118, error)) < 0)
                return -1;
              xfer += ret;
              if (val119 != NULL)
              {
                g_free(val119);
                val119 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val119, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->arg3, (gpointer) key118, (gpointer) val119);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_arg3 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          gint32 ecast120;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast120, error)) < 0)
            return -1;
          xfer += ret;
          this_object->arg4 = (TTestNumberz)ecast120;
          this_object->__isset_arg4 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->arg5, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_arg5 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_multi_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestMultiArgs * this_object = T_TEST_THRIFT_TEST_TEST_MULTI_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestMultiArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "arg0", T_BYTE, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->arg0, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "arg1", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->arg1, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "arg2", T_I64, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->arg2, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "arg3", T_MAP, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint16* key121 = g_new (gint16, 1);
    gchar * val122 = NULL;
    GList *key_list = NULL, *iter = NULL;
    gint16** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_I16, T_STRING, (gint32) g_hash_table_size ((GHashTable *) this_object->arg3), error)) < 0)
      return -1;
    xfer += ret;
    g_hash_table_foreach ((GHashTable *) this_object->arg3, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint16*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint16*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key121 = keys[i];
      val122 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->arg3), (gpointer) key121);

      if ((ret = thrift_protocol_write_i16 (protocol, * key121, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_string (protocol,  val122, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "arg4", T_I32, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->arg4, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "arg5", T_I64, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->arg5, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_multi_args_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  TTestThriftTestTestMultiArgs *self = T_TEST_THRIFT_TEST_TEST_MULTI_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_MULTI_ARGS_ARG0:
      self->arg0 = g_value_get_int (value);
      self->__isset_arg0 = TRUE;
      break;

    case PROP_T_TEST_THRIFT_TEST_TEST_MULTI_ARGS_ARG1:
      self->arg1 = g_value_get_int (value);
      self->__isset_arg1 = TRUE;
      break;

    case PROP_T_TEST_THRIFT_TEST_TEST_MULTI_ARGS_ARG2:
      self->arg2 = g_value_get_int64 (value);
      self->__isset_arg2 = TRUE;
      break;

    case PROP_T_TEST_THRIFT_TEST_TEST_MULTI_ARGS_ARG3:
      if (self->arg3 != NULL)
        g_hash_table_unref (self->arg3);
      self->arg3 = g_value_dup_boxed (value);
      self->__isset_arg3 = TRUE;
      break;

    case PROP_T_TEST_THRIFT_TEST_TEST_MULTI_ARGS_ARG4:
      self->arg4 = g_value_get_int (value);
      self->__isset_arg4 = TRUE;
      break;

    case PROP_T_TEST_THRIFT_TEST_TEST_MULTI_ARGS_ARG5:
      self->arg5 = g_value_get_int64 (value);
      self->__isset_arg5 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_multi_args_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  TTestThriftTestTestMultiArgs *self = T_TEST_THRIFT_TEST_TEST_MULTI_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_MULTI_ARGS_ARG0:
      g_value_set_int (value, self->arg0);
      break;

    case PROP_T_TEST_THRIFT_TEST_TEST_MULTI_ARGS_ARG1:
      g_value_set_int (value, self->arg1);
      break;

    case PROP_T_TEST_THRIFT_TEST_TEST_MULTI_ARGS_ARG2:
      g_value_set_int64 (value, self->arg2);
      break;

    case PROP_T_TEST_THRIFT_TEST_TEST_MULTI_ARGS_ARG3:
      g_value_set_boxed (value, self->arg3);
      break;

    case PROP_T_TEST_THRIFT_TEST_TEST_MULTI_ARGS_ARG4:
      g_value_set_int (value, self->arg4);
      break;

    case PROP_T_TEST_THRIFT_TEST_TEST_MULTI_ARGS_ARG5:
      g_value_set_int64 (value, self->arg5);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_multi_args_instance_init (TTestThriftTestTestMultiArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->arg0 = 0;
  object->__isset_arg0 = FALSE;
  object->arg1 = 0;
  object->__isset_arg1 = FALSE;
  object->arg2 = 0;
  object->__isset_arg2 = FALSE;
  object->arg3 = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_free);
  object->__isset_arg3 = FALSE;
  object->__isset_arg4 = FALSE;
  object->arg5 = 0;
  object->__isset_arg5 = FALSE;
}

static void 
t_test_thrift_test_test_multi_args_finalize (GObject *object)
{
  TTestThriftTestTestMultiArgs *tobject = T_TEST_THRIFT_TEST_TEST_MULTI_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->arg3 != NULL)
  {
    g_hash_table_destroy (tobject->arg3);
    tobject->arg3 = NULL;
  }
}

static void
t_test_thrift_test_test_multi_args_class_init (TTestThriftTestTestMultiArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_multi_args_read;
  struct_class->write = t_test_thrift_test_test_multi_args_write;

  gobject_class->finalize = t_test_thrift_test_test_multi_args_finalize;
  gobject_class->get_property = t_test_thrift_test_test_multi_args_get_property;
  gobject_class->set_property = t_test_thrift_test_test_multi_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_MULTI_ARGS_ARG0,
     g_param_spec_int ("arg0",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_MULTI_ARGS_ARG1,
     g_param_spec_int ("arg1",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_MULTI_ARGS_ARG2,
     g_param_spec_int64 ("arg2",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_MULTI_ARGS_ARG3,
     g_param_spec_boxed ("arg3",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_MULTI_ARGS_ARG4,
     g_param_spec_int ("arg4",
                       NULL,
                       NULL,
                       1,
                       8,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_MULTI_ARGS_ARG5,
     g_param_spec_int64 ("arg5",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_multi_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestMultiArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_multi_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestMultiArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_multi_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestMultiArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestMultiResultProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_MULTI_RESULT_0,
  PROP_T_TEST_THRIFT_TEST_TEST_MULTI_RESULT_SUCCESS
};

/* reads a thrift_test_test_multi_result object */
static gint32
t_test_thrift_test_test_multi_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestMultiResult * this_object = T_TEST_THRIFT_TEST_TEST_MULTI_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_multi_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestMultiResult * this_object = T_TEST_THRIFT_TEST_TEST_MULTI_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestMultiResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_multi_result_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  TTestThriftTestTestMultiResult *self = T_TEST_THRIFT_TEST_TEST_MULTI_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_MULTI_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_multi_result_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  TTestThriftTestTestMultiResult *self = T_TEST_THRIFT_TEST_TEST_MULTI_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_MULTI_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_multi_result_instance_init (TTestThriftTestTestMultiResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (T_TEST_TYPE_XTRUCT, NULL);
  object->__isset_success = FALSE;
}

static void 
t_test_thrift_test_test_multi_result_finalize (GObject *object)
{
  TTestThriftTestTestMultiResult *tobject = T_TEST_THRIFT_TEST_TEST_MULTI_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
t_test_thrift_test_test_multi_result_class_init (TTestThriftTestTestMultiResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_multi_result_read;
  struct_class->write = t_test_thrift_test_test_multi_result_write;

  gobject_class->finalize = t_test_thrift_test_test_multi_result_finalize;
  gobject_class->get_property = t_test_thrift_test_test_multi_result_get_property;
  gobject_class->set_property = t_test_thrift_test_test_multi_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_MULTI_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         T_TEST_TYPE_XTRUCT,
                         G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_multi_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestMultiResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_multi_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestMultiResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_multi_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestMultiResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestExceptionArgsProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_EXCEPTION_ARGS_0,
  PROP_T_TEST_THRIFT_TEST_TEST_EXCEPTION_ARGS_ARG
};

/* reads a thrift_test_test_exception_args object */
static gint32
t_test_thrift_test_test_exception_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestExceptionArgs * this_object = T_TEST_THRIFT_TEST_TEST_EXCEPTION_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->arg != NULL)
          {
            g_free(this_object->arg);
            this_object->arg = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->arg, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_arg = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_exception_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestExceptionArgs * this_object = T_TEST_THRIFT_TEST_TEST_EXCEPTION_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestExceptionArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "arg", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->arg, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_exception_args_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  TTestThriftTestTestExceptionArgs *self = T_TEST_THRIFT_TEST_TEST_EXCEPTION_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_EXCEPTION_ARGS_ARG:
      if (self->arg != NULL)
        g_free (self->arg);
      self->arg = g_value_dup_string (value);
      self->__isset_arg = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_exception_args_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  TTestThriftTestTestExceptionArgs *self = T_TEST_THRIFT_TEST_TEST_EXCEPTION_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_EXCEPTION_ARGS_ARG:
      g_value_set_string (value, self->arg);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_exception_args_instance_init (TTestThriftTestTestExceptionArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->arg = NULL;
  object->__isset_arg = FALSE;
}

static void 
t_test_thrift_test_test_exception_args_finalize (GObject *object)
{
  TTestThriftTestTestExceptionArgs *tobject = T_TEST_THRIFT_TEST_TEST_EXCEPTION_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->arg != NULL)
  {
    g_free(tobject->arg);
    tobject->arg = NULL;
  }
}

static void
t_test_thrift_test_test_exception_args_class_init (TTestThriftTestTestExceptionArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_exception_args_read;
  struct_class->write = t_test_thrift_test_test_exception_args_write;

  gobject_class->finalize = t_test_thrift_test_test_exception_args_finalize;
  gobject_class->get_property = t_test_thrift_test_test_exception_args_get_property;
  gobject_class->set_property = t_test_thrift_test_test_exception_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_EXCEPTION_ARGS_ARG,
     g_param_spec_string ("arg",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_exception_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestExceptionArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_exception_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestExceptionArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_exception_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestExceptionArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestExceptionResultProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_EXCEPTION_RESULT_0,
  PROP_T_TEST_THRIFT_TEST_TEST_EXCEPTION_RESULT_ERR1
};

/* reads a thrift_test_test_exception_result object */
static gint32
t_test_thrift_test_test_exception_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestExceptionResult * this_object = T_TEST_THRIFT_TEST_TEST_EXCEPTION_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->err1 != NULL)
          {
            g_object_unref (this_object->err1);
          }
          this_object->err1 = g_object_new (T_TEST_TYPE_XCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->err1), protocol, error)) < 0)
          {
            g_object_unref (this_object->err1);
            this_object->err1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_err1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_exception_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestExceptionResult * this_object = T_TEST_THRIFT_TEST_TEST_EXCEPTION_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestExceptionResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_err1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "err1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->err1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_exception_result_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  TTestThriftTestTestExceptionResult *self = T_TEST_THRIFT_TEST_TEST_EXCEPTION_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_EXCEPTION_RESULT_ERR1:
      if (self->err1 != NULL)
        g_object_unref (self->err1);
      self->err1 = g_value_dup_object (value);
      self->__isset_err1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_exception_result_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  TTestThriftTestTestExceptionResult *self = T_TEST_THRIFT_TEST_TEST_EXCEPTION_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_EXCEPTION_RESULT_ERR1:
      g_value_set_object (value, self->err1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_exception_result_instance_init (TTestThriftTestTestExceptionResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->err1 = NULL;
  object->__isset_err1 = FALSE;
}

static void 
t_test_thrift_test_test_exception_result_finalize (GObject *object)
{
  TTestThriftTestTestExceptionResult *tobject = T_TEST_THRIFT_TEST_TEST_EXCEPTION_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->err1 != NULL)
  {
    g_object_unref(tobject->err1);
    tobject->err1 = NULL;
  }
}

static void
t_test_thrift_test_test_exception_result_class_init (TTestThriftTestTestExceptionResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_exception_result_read;
  struct_class->write = t_test_thrift_test_test_exception_result_write;

  gobject_class->finalize = t_test_thrift_test_test_exception_result_finalize;
  gobject_class->get_property = t_test_thrift_test_test_exception_result_get_property;
  gobject_class->set_property = t_test_thrift_test_test_exception_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_EXCEPTION_RESULT_ERR1,
     g_param_spec_object ("err1",
                         NULL,
                         NULL,
                         T_TEST_TYPE_XCEPTION,
                         G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_exception_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestExceptionResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_exception_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestExceptionResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_exception_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestExceptionResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestMultiExceptionArgsProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_ARGS_0,
  PROP_T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_ARGS_ARG0,
  PROP_T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_ARGS_ARG1
};

/* reads a thrift_test_test_multi_exception_args object */
static gint32
t_test_thrift_test_test_multi_exception_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestMultiExceptionArgs * this_object = T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->arg0 != NULL)
          {
            g_free(this_object->arg0);
            this_object->arg0 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->arg0, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_arg0 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->arg1 != NULL)
          {
            g_free(this_object->arg1);
            this_object->arg1 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->arg1, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_arg1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_multi_exception_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestMultiExceptionArgs * this_object = T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestMultiExceptionArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "arg0", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->arg0, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "arg1", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->arg1, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_multi_exception_args_set_property (GObject *object,
                                                           guint property_id,
                                                           const GValue *value,
                                                           GParamSpec *pspec)
{
  TTestThriftTestTestMultiExceptionArgs *self = T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_ARGS_ARG0:
      if (self->arg0 != NULL)
        g_free (self->arg0);
      self->arg0 = g_value_dup_string (value);
      self->__isset_arg0 = TRUE;
      break;

    case PROP_T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_ARGS_ARG1:
      if (self->arg1 != NULL)
        g_free (self->arg1);
      self->arg1 = g_value_dup_string (value);
      self->__isset_arg1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_multi_exception_args_get_property (GObject *object,
                                                           guint property_id,
                                                           GValue *value,
                                                           GParamSpec *pspec)
{
  TTestThriftTestTestMultiExceptionArgs *self = T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_ARGS_ARG0:
      g_value_set_string (value, self->arg0);
      break;

    case PROP_T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_ARGS_ARG1:
      g_value_set_string (value, self->arg1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_multi_exception_args_instance_init (TTestThriftTestTestMultiExceptionArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->arg0 = NULL;
  object->__isset_arg0 = FALSE;
  object->arg1 = NULL;
  object->__isset_arg1 = FALSE;
}

static void 
t_test_thrift_test_test_multi_exception_args_finalize (GObject *object)
{
  TTestThriftTestTestMultiExceptionArgs *tobject = T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->arg0 != NULL)
  {
    g_free(tobject->arg0);
    tobject->arg0 = NULL;
  }
  if (tobject->arg1 != NULL)
  {
    g_free(tobject->arg1);
    tobject->arg1 = NULL;
  }
}

static void
t_test_thrift_test_test_multi_exception_args_class_init (TTestThriftTestTestMultiExceptionArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_multi_exception_args_read;
  struct_class->write = t_test_thrift_test_test_multi_exception_args_write;

  gobject_class->finalize = t_test_thrift_test_test_multi_exception_args_finalize;
  gobject_class->get_property = t_test_thrift_test_test_multi_exception_args_get_property;
  gobject_class->set_property = t_test_thrift_test_test_multi_exception_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_ARGS_ARG0,
     g_param_spec_string ("arg0",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_ARGS_ARG1,
     g_param_spec_string ("arg1",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_multi_exception_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestMultiExceptionArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_multi_exception_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestMultiExceptionArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_multi_exception_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestMultiExceptionArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestMultiExceptionResultProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_RESULT_0,
  PROP_T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_RESULT_SUCCESS,
  PROP_T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_RESULT_ERR1,
  PROP_T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_RESULT_ERR2
};

/* reads a thrift_test_test_multi_exception_result object */
static gint32
t_test_thrift_test_test_multi_exception_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestMultiExceptionResult * this_object = T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->err1 != NULL)
          {
            g_object_unref (this_object->err1);
          }
          this_object->err1 = g_object_new (T_TEST_TYPE_XCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->err1), protocol, error)) < 0)
          {
            g_object_unref (this_object->err1);
            this_object->err1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_err1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->err2 != NULL)
          {
            g_object_unref (this_object->err2);
          }
          this_object->err2 = g_object_new (T_TEST_TYPE_XCEPTION2, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->err2), protocol, error)) < 0)
          {
            g_object_unref (this_object->err2);
            this_object->err2 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_err2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_multi_exception_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestMultiExceptionResult * this_object = T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestMultiExceptionResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_err1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "err1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->err1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_err2 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "err2", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->err2), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_multi_exception_result_set_property (GObject *object,
                                                             guint property_id,
                                                             const GValue *value,
                                                             GParamSpec *pspec)
{
  TTestThriftTestTestMultiExceptionResult *self = T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_RESULT_ERR1:
      if (self->err1 != NULL)
        g_object_unref (self->err1);
      self->err1 = g_value_dup_object (value);
      self->__isset_err1 = TRUE;
      break;

    case PROP_T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_RESULT_ERR2:
      if (self->err2 != NULL)
        g_object_unref (self->err2);
      self->err2 = g_value_dup_object (value);
      self->__isset_err2 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_multi_exception_result_get_property (GObject *object,
                                                             guint property_id,
                                                             GValue *value,
                                                             GParamSpec *pspec)
{
  TTestThriftTestTestMultiExceptionResult *self = T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_RESULT_ERR1:
      g_value_set_object (value, self->err1);
      break;

    case PROP_T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_RESULT_ERR2:
      g_value_set_object (value, self->err2);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_multi_exception_result_instance_init (TTestThriftTestTestMultiExceptionResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (T_TEST_TYPE_XTRUCT, NULL);
  object->__isset_success = FALSE;
  object->err1 = NULL;
  object->__isset_err1 = FALSE;
  object->err2 = NULL;
  object->__isset_err2 = FALSE;
}

static void 
t_test_thrift_test_test_multi_exception_result_finalize (GObject *object)
{
  TTestThriftTestTestMultiExceptionResult *tobject = T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->err1 != NULL)
  {
    g_object_unref(tobject->err1);
    tobject->err1 = NULL;
  }
  if (tobject->err2 != NULL)
  {
    g_object_unref(tobject->err2);
    tobject->err2 = NULL;
  }
}

static void
t_test_thrift_test_test_multi_exception_result_class_init (TTestThriftTestTestMultiExceptionResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_multi_exception_result_read;
  struct_class->write = t_test_thrift_test_test_multi_exception_result_write;

  gobject_class->finalize = t_test_thrift_test_test_multi_exception_result_finalize;
  gobject_class->get_property = t_test_thrift_test_test_multi_exception_result_get_property;
  gobject_class->set_property = t_test_thrift_test_test_multi_exception_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         T_TEST_TYPE_XTRUCT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_RESULT_ERR1,
     g_param_spec_object ("err1",
                         NULL,
                         NULL,
                         T_TEST_TYPE_XCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_MULTI_EXCEPTION_RESULT_ERR2,
     g_param_spec_object ("err2",
                         NULL,
                         NULL,
                         T_TEST_TYPE_XCEPTION2,
                         G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_multi_exception_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestMultiExceptionResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_multi_exception_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestMultiExceptionResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_multi_exception_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestMultiExceptionResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestThriftTestTestOnewayArgsProperties
{
  PROP_T_TEST_THRIFT_TEST_TEST_ONEWAY_ARGS_0,
  PROP_T_TEST_THRIFT_TEST_TEST_ONEWAY_ARGS_SECONDS_TO_SLEEP
};

/* reads a thrift_test_test_oneway_args object */
static gint32
t_test_thrift_test_test_oneway_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestThriftTestTestOnewayArgs * this_object = T_TEST_THRIFT_TEST_TEST_ONEWAY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->secondsToSleep, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_secondsToSleep = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_thrift_test_test_oneway_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestThriftTestTestOnewayArgs * this_object = T_TEST_THRIFT_TEST_TEST_ONEWAY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ThriftTestTestOnewayArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "secondsToSleep", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->secondsToSleep, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_thrift_test_test_oneway_args_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  TTestThriftTestTestOnewayArgs *self = T_TEST_THRIFT_TEST_TEST_ONEWAY_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_ONEWAY_ARGS_SECONDS_TO_SLEEP:
      self->secondsToSleep = g_value_get_int (value);
      self->__isset_secondsToSleep = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_test_oneway_args_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  TTestThriftTestTestOnewayArgs *self = T_TEST_THRIFT_TEST_TEST_ONEWAY_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_TEST_ONEWAY_ARGS_SECONDS_TO_SLEEP:
      g_value_set_int (value, self->secondsToSleep);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_thrift_test_test_oneway_args_instance_init (TTestThriftTestTestOnewayArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->secondsToSleep = 0;
  object->__isset_secondsToSleep = FALSE;
}

static void 
t_test_thrift_test_test_oneway_args_finalize (GObject *object)
{
  TTestThriftTestTestOnewayArgs *tobject = T_TEST_THRIFT_TEST_TEST_ONEWAY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_thrift_test_test_oneway_args_class_init (TTestThriftTestTestOnewayArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_thrift_test_test_oneway_args_read;
  struct_class->write = t_test_thrift_test_test_oneway_args_write;

  gobject_class->finalize = t_test_thrift_test_test_oneway_args_finalize;
  gobject_class->get_property = t_test_thrift_test_test_oneway_args_get_property;
  gobject_class->set_property = t_test_thrift_test_test_oneway_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_THRIFT_TEST_TEST_ONEWAY_ARGS_SECONDS_TO_SLEEP,
     g_param_spec_int ("secondsToSleep",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
t_test_thrift_test_test_oneway_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestThriftTestTestOnewayArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_thrift_test_test_oneway_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestThriftTestTestOnewayArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_thrift_test_test_oneway_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestThriftTestTestOnewayArgsType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a second_service_blah_blah_args object */
static gint32
t_test_second_service_blah_blah_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestSecondServiceBlahBlahArgs * this_object = T_TEST_SECOND_SERVICE_BLAH_BLAH_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_second_service_blah_blah_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestSecondServiceBlahBlahArgs * this_object = T_TEST_SECOND_SERVICE_BLAH_BLAH_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SecondServiceBlahBlahArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_second_service_blah_blah_args_instance_init (TTestSecondServiceBlahBlahArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
t_test_second_service_blah_blah_args_finalize (GObject *object)
{
  TTestSecondServiceBlahBlahArgs *tobject = T_TEST_SECOND_SERVICE_BLAH_BLAH_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_second_service_blah_blah_args_class_init (TTestSecondServiceBlahBlahArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_second_service_blah_blah_args_read;
  struct_class->write = t_test_second_service_blah_blah_args_write;

  gobject_class->finalize = t_test_second_service_blah_blah_args_finalize;
}

GType
t_test_second_service_blah_blah_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestSecondServiceBlahBlahArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_second_service_blah_blah_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestSecondServiceBlahBlahArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_second_service_blah_blah_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestSecondServiceBlahBlahArgsType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a second_service_blah_blah_result object */
static gint32
t_test_second_service_blah_blah_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestSecondServiceBlahBlahResult * this_object = T_TEST_SECOND_SERVICE_BLAH_BLAH_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_second_service_blah_blah_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestSecondServiceBlahBlahResult * this_object = T_TEST_SECOND_SERVICE_BLAH_BLAH_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SecondServiceBlahBlahResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
t_test_second_service_blah_blah_result_instance_init (TTestSecondServiceBlahBlahResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
t_test_second_service_blah_blah_result_finalize (GObject *object)
{
  TTestSecondServiceBlahBlahResult *tobject = T_TEST_SECOND_SERVICE_BLAH_BLAH_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_test_second_service_blah_blah_result_class_init (TTestSecondServiceBlahBlahResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_second_service_blah_blah_result_read;
  struct_class->write = t_test_second_service_blah_blah_result_write;

  gobject_class->finalize = t_test_second_service_blah_blah_result_finalize;
}

GType
t_test_second_service_blah_blah_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestSecondServiceBlahBlahResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_second_service_blah_blah_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestSecondServiceBlahBlahResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_second_service_blah_blah_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestSecondServiceBlahBlahResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestSecondServiceSecondtestStringArgsProperties
{
  PROP_T_TEST_SECOND_SERVICE_SECONDTEST_STRING_ARGS_0,
  PROP_T_TEST_SECOND_SERVICE_SECONDTEST_STRING_ARGS_THING
};

/* reads a second_service_secondtest_string_args object */
static gint32
t_test_second_service_secondtest_string_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestSecondServiceSecondtestStringArgs * this_object = T_TEST_SECOND_SERVICE_SECONDTEST_STRING_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->thing != NULL)
          {
            g_free(this_object->thing);
            this_object->thing = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->thing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_thing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_second_service_secondtest_string_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestSecondServiceSecondtestStringArgs * this_object = T_TEST_SECOND_SERVICE_SECONDTEST_STRING_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SecondServiceSecondtestStringArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->thing, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_second_service_secondtest_string_args_set_property (GObject *object,
                                                           guint property_id,
                                                           const GValue *value,
                                                           GParamSpec *pspec)
{
  TTestSecondServiceSecondtestStringArgs *self = T_TEST_SECOND_SERVICE_SECONDTEST_STRING_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_SECOND_SERVICE_SECONDTEST_STRING_ARGS_THING:
      if (self->thing != NULL)
        g_free (self->thing);
      self->thing = g_value_dup_string (value);
      self->__isset_thing = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_second_service_secondtest_string_args_get_property (GObject *object,
                                                           guint property_id,
                                                           GValue *value,
                                                           GParamSpec *pspec)
{
  TTestSecondServiceSecondtestStringArgs *self = T_TEST_SECOND_SERVICE_SECONDTEST_STRING_ARGS (object);

  switch (property_id)
  {
    case PROP_T_TEST_SECOND_SERVICE_SECONDTEST_STRING_ARGS_THING:
      g_value_set_string (value, self->thing);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_second_service_secondtest_string_args_instance_init (TTestSecondServiceSecondtestStringArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thing = NULL;
  object->__isset_thing = FALSE;
}

static void 
t_test_second_service_secondtest_string_args_finalize (GObject *object)
{
  TTestSecondServiceSecondtestStringArgs *tobject = T_TEST_SECOND_SERVICE_SECONDTEST_STRING_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thing != NULL)
  {
    g_free(tobject->thing);
    tobject->thing = NULL;
  }
}

static void
t_test_second_service_secondtest_string_args_class_init (TTestSecondServiceSecondtestStringArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_second_service_secondtest_string_args_read;
  struct_class->write = t_test_second_service_secondtest_string_args_write;

  gobject_class->finalize = t_test_second_service_secondtest_string_args_finalize;
  gobject_class->get_property = t_test_second_service_secondtest_string_args_get_property;
  gobject_class->set_property = t_test_second_service_secondtest_string_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_SECOND_SERVICE_SECONDTEST_STRING_ARGS_THING,
     g_param_spec_string ("thing",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
t_test_second_service_secondtest_string_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestSecondServiceSecondtestStringArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_second_service_secondtest_string_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestSecondServiceSecondtestStringArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_second_service_secondtest_string_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestSecondServiceSecondtestStringArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TTestSecondServiceSecondtestStringResultProperties
{
  PROP_T_TEST_SECOND_SERVICE_SECONDTEST_STRING_RESULT_0,
  PROP_T_TEST_SECOND_SERVICE_SECONDTEST_STRING_RESULT_SUCCESS
};

/* reads a second_service_secondtest_string_result object */
static gint32
t_test_second_service_secondtest_string_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTestSecondServiceSecondtestStringResult * this_object = T_TEST_SECOND_SERVICE_SECONDTEST_STRING_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_test_second_service_secondtest_string_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTestSecondServiceSecondtestStringResult * this_object = T_TEST_SECOND_SERVICE_SECONDTEST_STRING_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SecondServiceSecondtestStringResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_test_second_service_secondtest_string_result_set_property (GObject *object,
                                                             guint property_id,
                                                             const GValue *value,
                                                             GParamSpec *pspec)
{
  TTestSecondServiceSecondtestStringResult *self = T_TEST_SECOND_SERVICE_SECONDTEST_STRING_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_SECOND_SERVICE_SECONDTEST_STRING_RESULT_SUCCESS:
      if (self->success != NULL)
        g_free (self->success);
      self->success = g_value_dup_string (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_second_service_secondtest_string_result_get_property (GObject *object,
                                                             guint property_id,
                                                             GValue *value,
                                                             GParamSpec *pspec)
{
  TTestSecondServiceSecondtestStringResult *self = T_TEST_SECOND_SERVICE_SECONDTEST_STRING_RESULT (object);

  switch (property_id)
  {
    case PROP_T_TEST_SECOND_SERVICE_SECONDTEST_STRING_RESULT_SUCCESS:
      g_value_set_string (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_test_second_service_secondtest_string_result_instance_init (TTestSecondServiceSecondtestStringResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
}

static void 
t_test_second_service_secondtest_string_result_finalize (GObject *object)
{
  TTestSecondServiceSecondtestStringResult *tobject = T_TEST_SECOND_SERVICE_SECONDTEST_STRING_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_free(tobject->success);
    tobject->success = NULL;
  }
}

static void
t_test_second_service_secondtest_string_result_class_init (TTestSecondServiceSecondtestStringResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_test_second_service_secondtest_string_result_read;
  struct_class->write = t_test_second_service_secondtest_string_result_write;

  gobject_class->finalize = t_test_second_service_secondtest_string_result_finalize;
  gobject_class->get_property = t_test_second_service_secondtest_string_result_get_property;
  gobject_class->set_property = t_test_second_service_secondtest_string_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TEST_SECOND_SERVICE_SECONDTEST_STRING_RESULT_SUCCESS,
     g_param_spec_string ("success",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
t_test_second_service_secondtest_string_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTestSecondServiceSecondtestStringResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_test_second_service_secondtest_string_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTestSecondServiceSecondtestStringResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_test_second_service_secondtest_string_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTestSecondServiceSecondtestStringResultType",
                                   &type_info, 0);
  }

  return type;
}

