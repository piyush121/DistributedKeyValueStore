/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include <string.h>
#include <thrift/c_glib/thrift.h>
#include <thrift/c_glib/thrift_application_exception.h>
#include "t_test_thrift_test.h"

gboolean
t_test_thrift_test_if_test_void (TTestThriftTestIf *iface, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_void (iface, error);
}

gboolean
t_test_thrift_test_if_test_string (TTestThriftTestIf *iface, gchar ** _return, const gchar * thing, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_string (iface, _return, thing, error);
}

gboolean
t_test_thrift_test_if_test_bool (TTestThriftTestIf *iface, gboolean* _return, const gboolean thing, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_bool (iface, _return, thing, error);
}

gboolean
t_test_thrift_test_if_test_byte (TTestThriftTestIf *iface, gint8* _return, const gint8 thing, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_byte (iface, _return, thing, error);
}

gboolean
t_test_thrift_test_if_test_i32 (TTestThriftTestIf *iface, gint32* _return, const gint32 thing, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_i32 (iface, _return, thing, error);
}

gboolean
t_test_thrift_test_if_test_i64 (TTestThriftTestIf *iface, gint64* _return, const gint64 thing, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_i64 (iface, _return, thing, error);
}

gboolean
t_test_thrift_test_if_test_double (TTestThriftTestIf *iface, gdouble* _return, const gdouble thing, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_double (iface, _return, thing, error);
}

gboolean
t_test_thrift_test_if_test_binary (TTestThriftTestIf *iface, GByteArray ** _return, const GByteArray * thing, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_binary (iface, _return, thing, error);
}

gboolean
t_test_thrift_test_if_test_struct (TTestThriftTestIf *iface, TTestXtruct ** _return, const TTestXtruct * thing, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_struct (iface, _return, thing, error);
}

gboolean
t_test_thrift_test_if_test_nest (TTestThriftTestIf *iface, TTestXtruct2 ** _return, const TTestXtruct2 * thing, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_nest (iface, _return, thing, error);
}

gboolean
t_test_thrift_test_if_test_map (TTestThriftTestIf *iface, GHashTable ** _return, const GHashTable * thing, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_map (iface, _return, thing, error);
}

gboolean
t_test_thrift_test_if_test_string_map (TTestThriftTestIf *iface, GHashTable ** _return, const GHashTable * thing, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_string_map (iface, _return, thing, error);
}

gboolean
t_test_thrift_test_if_test_set (TTestThriftTestIf *iface, GHashTable ** _return, const GHashTable * thing, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_set (iface, _return, thing, error);
}

gboolean
t_test_thrift_test_if_test_list (TTestThriftTestIf *iface, GArray ** _return, const GArray * thing, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_list (iface, _return, thing, error);
}

gboolean
t_test_thrift_test_if_test_enum (TTestThriftTestIf *iface, TTestNumberz* _return, const TTestNumberz thing, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_enum (iface, _return, thing, error);
}

gboolean
t_test_thrift_test_if_test_typedef (TTestThriftTestIf *iface, TTestUserId* _return, const TTestUserId thing, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_typedef (iface, _return, thing, error);
}

gboolean
t_test_thrift_test_if_test_map_map (TTestThriftTestIf *iface, GHashTable ** _return, const gint32 hello, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_map_map (iface, _return, hello, error);
}

gboolean
t_test_thrift_test_if_test_insanity (TTestThriftTestIf *iface, GHashTable ** _return, const TTestInsanity * argument, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_insanity (iface, _return, argument, error);
}

gboolean
t_test_thrift_test_if_test_multi (TTestThriftTestIf *iface, TTestXtruct ** _return, const gint8 arg0, const gint32 arg1, const gint64 arg2, const GHashTable * arg3, const TTestNumberz arg4, const TTestUserId arg5, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_multi (iface, _return, arg0, arg1, arg2, arg3, arg4, arg5, error);
}

gboolean
t_test_thrift_test_if_test_exception (TTestThriftTestIf *iface, const gchar * arg, TTestXception ** err1, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_exception (iface, arg, err1, error);
}

gboolean
t_test_thrift_test_if_test_multi_exception (TTestThriftTestIf *iface, TTestXtruct ** _return, const gchar * arg0, const gchar * arg1, TTestXception ** err1, TTestXception2 ** err2, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_multi_exception (iface, _return, arg0, arg1, err1, err2, error);
}

gboolean
t_test_thrift_test_if_test_oneway (TTestThriftTestIf *iface, const gint32 secondsToSleep, GError **error)
{
  return T_TEST_THRIFT_TEST_IF_GET_INTERFACE (iface)->test_oneway (iface, secondsToSleep, error);
}

GType
t_test_thrift_test_if_get_type (void)
{
  static GType type = 0;
  if (type == 0)
  {
    static const GTypeInfo type_info =
    {
      sizeof (TTestThriftTestIfInterface),
      NULL,  /* base_init */
      NULL,  /* base_finalize */
      NULL,  /* class_init */
      NULL,  /* class_finalize */
      NULL,  /* class_data */
      0,     /* instance_size */
      0,     /* n_preallocs */
      NULL,  /* instance_init */
      NULL   /* value_table */
    };
    type = g_type_register_static (G_TYPE_INTERFACE,
                                   "TTestThriftTestIf",
                                   &type_info, 0);
  }
  return type;
}

static void 
t_test_thrift_test_if_interface_init (TTestThriftTestIfInterface *iface);

G_DEFINE_TYPE_WITH_CODE (TTestThriftTestClient, t_test_thrift_test_client,
                         G_TYPE_OBJECT, 
                         G_IMPLEMENT_INTERFACE (T_TEST_TYPE_THRIFT_TEST_IF,
                                                t_test_thrift_test_if_interface_init))

enum _TTestThriftTestClientProperties
{
  PROP_0,
  PROP_T_TEST_THRIFT_TEST_CLIENT_INPUT_PROTOCOL,
  PROP_T_TEST_THRIFT_TEST_CLIENT_OUTPUT_PROTOCOL
};

void
t_test_thrift_test_client_set_property (GObject *object, guint property_id, const GValue *value, GParamSpec *pspec)
{
  TTestThriftTestClient *client = T_TEST_THRIFT_TEST_CLIENT (object);

  THRIFT_UNUSED_VAR (pspec);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_CLIENT_INPUT_PROTOCOL:
      client->input_protocol = g_value_get_object (value);
      break;
    case PROP_T_TEST_THRIFT_TEST_CLIENT_OUTPUT_PROTOCOL:
      client->output_protocol = g_value_get_object (value);
      break;
  }
}

void
t_test_thrift_test_client_get_property (GObject *object, guint property_id, GValue *value, GParamSpec *pspec)
{
  TTestThriftTestClient *client = T_TEST_THRIFT_TEST_CLIENT (object);

  THRIFT_UNUSED_VAR (pspec);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_CLIENT_INPUT_PROTOCOL:
      g_value_set_object (value, client->input_protocol);
      break;
    case PROP_T_TEST_THRIFT_TEST_CLIENT_OUTPUT_PROTOCOL:
      g_value_set_object (value, client->output_protocol);
      break;
  }
}

gboolean t_test_thrift_test_client_send_test_void (TTestThriftTestIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testVoid", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testVoid_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_void (TTestThriftTestIf * iface, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testVoid", 8) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testVoid", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_void (TTestThriftTestIf * iface, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_void (iface, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_void (iface, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_string (TTestThriftTestIf * iface, const gchar * thing, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testString", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testString_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, thing, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_string (TTestThriftTestIf * iface, gchar ** _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testString", 10) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testString", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_string (TTestThriftTestIf * iface, gchar ** _return, const gchar * thing, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_string (iface, thing, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_string (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_bool (TTestThriftTestIf * iface, const gboolean thing, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testBool", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testBool_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_BOOL, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, thing, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_bool (TTestThriftTestIf * iface, gboolean* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testBool", 8) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testBool", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_BOOL)
          {
            if ((ret = thrift_protocol_read_bool (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_bool (TTestThriftTestIf * iface, gboolean* _return, const gboolean thing, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_bool (iface, thing, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_bool (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_byte (TTestThriftTestIf * iface, const gint8 thing, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testByte", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testByte_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_BYTE, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_byte (protocol, thing, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_byte (TTestThriftTestIf * iface, gint8* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testByte", 8) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testByte", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_BYTE)
          {
            if ((ret = thrift_protocol_read_byte (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_byte (TTestThriftTestIf * iface, gint8* _return, const gint8 thing, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_byte (iface, thing, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_byte (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_i32 (TTestThriftTestIf * iface, const gint32 thing, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testI32", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testI32_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, thing, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_i32 (TTestThriftTestIf * iface, gint32* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testI32", 7) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testI32", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_i32 (TTestThriftTestIf * iface, gint32* _return, const gint32 thing, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_i32 (iface, thing, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_i32 (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_i64 (TTestThriftTestIf * iface, const gint64 thing, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testI64", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testI64_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, thing, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_i64 (TTestThriftTestIf * iface, gint64* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testI64", 7) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testI64", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I64)
          {
            if ((ret = thrift_protocol_read_i64 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_i64 (TTestThriftTestIf * iface, gint64* _return, const gint64 thing, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_i64 (iface, thing, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_i64 (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_double (TTestThriftTestIf * iface, const gdouble thing, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testDouble", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testDouble_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_DOUBLE, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_double (protocol, thing, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_double (TTestThriftTestIf * iface, gdouble* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testDouble", 10) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testDouble", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_DOUBLE)
          {
            if ((ret = thrift_protocol_read_double (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_double (TTestThriftTestIf * iface, gdouble* _return, const gdouble thing, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_double (iface, thing, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_double (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_binary (TTestThriftTestIf * iface, const GByteArray * thing, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testBinary", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testBinary_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) thing)->data, ((GByteArray *) thing)->len, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_binary (TTestThriftTestIf * iface, GByteArray ** _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testBinary", 10) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testBinary", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
              return 0;
            xfer += ret;
            *_return = g_byte_array_new();
            g_byte_array_append (*_return, (guint8 *) data, (guint) len);
            g_free (data);
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_binary (TTestThriftTestIf * iface, GByteArray ** _return, const GByteArray * thing, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_binary (iface, thing, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_binary (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_struct (TTestThriftTestIf * iface, const TTestXtruct * thing, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testStruct", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testStruct_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (thing), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_struct (TTestThriftTestIf * iface, TTestXtruct ** _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testStruct", 10) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testStruct", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_struct (TTestThriftTestIf * iface, TTestXtruct ** _return, const TTestXtruct * thing, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_struct (iface, thing, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_struct (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_nest (TTestThriftTestIf * iface, const TTestXtruct2 * thing, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testNest", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testNest_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (thing), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_nest (TTestThriftTestIf * iface, TTestXtruct2 ** _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testNest", 8) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testNest", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_nest (TTestThriftTestIf * iface, TTestXtruct2 ** _return, const TTestXtruct2 * thing, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_nest (iface, thing, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_nest (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_map (TTestThriftTestIf * iface, const GHashTable * thing, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testMap", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testMap_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_MAP, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      gint32* key123 = g_new (gint32, 1);
      gint32* val124 = g_new (gint32, 1);
      GList *key_list = NULL, *iter = NULL;
      gint32** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_I32, (gint32) g_hash_table_size ((GHashTable *) thing), error)) < 0)
        return 0;
      xfer += ret;
      g_hash_table_foreach ((GHashTable *) thing, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gint32*, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gint32*) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key123 = keys[i];
        val124 = (gint32*) g_hash_table_lookup (((GHashTable *) thing), (gpointer) key123);

        if ((ret = thrift_protocol_write_i32 (protocol, * key123, error)) < 0)
          return 0;
        if ((ret = thrift_protocol_write_i32 (protocol, * val124, error)) < 0)
          return 0;
      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_map (TTestThriftTestIf * iface, GHashTable ** _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testMap", 7) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testMap", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_MAP)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType key_type;
              ThriftType value_type;

              /* read the map begin marker */
              if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through each of the map's fields */
              for (i = 0; i < size; i++)
              {
                gint32* key125 = g_new (gint32, 1);
                gint32* val126 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*key125, error)) < 0)
                  return 0;
                xfer += ret;
                if ((ret = thrift_protocol_read_i32 (protocol, &*val126, error)) < 0)
                  return 0;
                xfer += ret;
                g_hash_table_insert ((GHashTable *)*_return, (gpointer) key125, (gpointer) val126);
              }

              /* read the map end marker */
              if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_map (TTestThriftTestIf * iface, GHashTable ** _return, const GHashTable * thing, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_map (iface, thing, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_map (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_string_map (TTestThriftTestIf * iface, const GHashTable * thing, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testStringMap", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testStringMap_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_MAP, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      gchar * key127 = NULL;
      gchar * val128 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, (gint32) g_hash_table_size ((GHashTable *) thing), error)) < 0)
        return 0;
      xfer += ret;
      g_hash_table_foreach ((GHashTable *) thing, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key127 = keys[i];
        val128 = (gchar *) g_hash_table_lookup (((GHashTable *) thing), (gpointer) key127);

        if ((ret = thrift_protocol_write_string (protocol,  key127, error)) < 0)
          return 0;
        if ((ret = thrift_protocol_write_string (protocol,  val128, error)) < 0)
          return 0;
      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_string_map (TTestThriftTestIf * iface, GHashTable ** _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testStringMap", 13) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testStringMap", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_MAP)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType key_type;
              ThriftType value_type;

              /* read the map begin marker */
              if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through each of the map's fields */
              for (i = 0; i < size; i++)
              {
                gchar * key129 = NULL;
                gchar * val130 = NULL;
                if (key129 != NULL)
                {
                  g_free(key129);
                  key129 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &key129, error)) < 0)
                  return 0;
                xfer += ret;
                if (val130 != NULL)
                {
                  g_free(val130);
                  val130 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &val130, error)) < 0)
                  return 0;
                xfer += ret;
                g_hash_table_insert ((GHashTable *)*_return, (gpointer) key129, (gpointer) val130);
              }

              /* read the map end marker */
              if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_string_map (TTestThriftTestIf * iface, GHashTable ** _return, const GHashTable * thing, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_string_map (iface, thing, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_string_map (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_set (TTestThriftTestIf * iface, const GHashTable * thing, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testSet", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testSet_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_SET, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      GList *key_list = NULL, *iter = NULL;
      gint32** keys;
      int i = 0, key_count;
      gint32* elem;
      gpointer value;
      THRIFT_UNUSED_VAR (value);

      if ((ret = thrift_protocol_write_set_begin (protocol, T_I32, (gint32) g_hash_table_size ((GHashTable *) thing), error)) < 0)
        return 0;
      xfer += ret;
      g_hash_table_foreach ((GHashTable *) thing, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gint32*, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gint32*) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        elem = keys[i];
        value = (gpointer) g_hash_table_lookup (((GHashTable *) thing), (gpointer) elem);

        if ((ret = thrift_protocol_write_i32 (protocol, *elem, error)) < 0)
          return 0;
      }
      if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_set (TTestThriftTestIf * iface, GHashTable ** _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testSet", 7) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testSet", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_SET)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through the set elements */
              for (i = 0; i < size; ++i)
              {
                gint32* _elem131 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*_elem131, error)) < 0)
                  return 0;
                xfer += ret;
                g_hash_table_insert ((GHashTable *) *_return, (gpointer) _elem131, (gpointer) 1);
              }
              if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
                return 0;
              xfer += ret;

            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_set (TTestThriftTestIf * iface, GHashTable ** _return, const GHashTable * thing, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_set (iface, thing, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_set (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_list (TTestThriftTestIf * iface, const GArray * thing, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testList", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testList_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i132;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) thing->len, error)) < 0)
        return 0;
      xfer += ret;
      for (i132 = 0; i132 < thing->len; i132++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (thing, gint32, i132)), error)) < 0)
          return 0;
      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_list (TTestThriftTestIf * iface, GArray ** _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testList", 8) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testList", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gint32* _elem133 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*_elem133, error)) < 0)
                  return 0;
                xfer += ret;
                g_array_append_vals (*_return, _elem133, 1);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_list (TTestThriftTestIf * iface, GArray ** _return, const GArray * thing, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_list (iface, thing, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_list (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_enum (TTestThriftTestIf * iface, const TTestNumberz thing, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testEnum", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testEnum_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) thing, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_enum (TTestThriftTestIf * iface, TTestNumberz* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testEnum", 8) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testEnum", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            gint32 ecast134;
            if ((ret = thrift_protocol_read_i32 (protocol, &ecast134, error)) < 0)
              return 0;
            xfer += ret;
            *_return = (TTestNumberz)ecast134;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_enum (TTestThriftTestIf * iface, TTestNumberz* _return, const TTestNumberz thing, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_enum (iface, thing, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_enum (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_typedef (TTestThriftTestIf * iface, const TTestUserId thing, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testTypedef", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testTypedef_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thing", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, thing, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_typedef (TTestThriftTestIf * iface, TTestUserId* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testTypedef", 11) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testTypedef", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I64)
          {
            if ((ret = thrift_protocol_read_i64 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_typedef (TTestThriftTestIf * iface, TTestUserId* _return, const TTestUserId thing, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_typedef (iface, thing, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_typedef (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_map_map (TTestThriftTestIf * iface, const gint32 hello, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testMapMap", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testMapMap_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "hello", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, hello, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_map_map (TTestThriftTestIf * iface, GHashTable ** _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testMapMap", 10) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testMapMap", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_MAP)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType key_type;
              ThriftType value_type;

              /* read the map begin marker */
              if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through each of the map's fields */
              for (i = 0; i < size; i++)
              {
                gint32* key135 = g_new (gint32, 1);
                GHashTable * val136 = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, g_free);
                if ((ret = thrift_protocol_read_i32 (protocol, &*key135, error)) < 0)
                  return 0;
                xfer += ret;
                {
                  guint32 size;
                  guint32 i;
                  ThriftType key_type;
                  ThriftType value_type;

                  /* read the map begin marker */
                  if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                    return 0;
                  xfer += ret;

                  /* iterate through each of the map's fields */
                  for (i = 0; i < size; i++)
                  {
                    gint32* key137 = g_new (gint32, 1);
                    gint32* val138 = g_new (gint32, 1);
                    if ((ret = thrift_protocol_read_i32 (protocol, &*key137, error)) < 0)
                      return 0;
                    xfer += ret;
                    if ((ret = thrift_protocol_read_i32 (protocol, &*val138, error)) < 0)
                      return 0;
                    xfer += ret;
                    g_hash_table_insert ((GHashTable *)val136, (gpointer) key137, (gpointer) val138);
                  }

                  /* read the map end marker */
                  if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                    return 0;
                  xfer += ret;
                }
                g_hash_table_insert ((GHashTable *)*_return, (gpointer) key135, (gpointer) val136);
              }

              /* read the map end marker */
              if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_map_map (TTestThriftTestIf * iface, GHashTable ** _return, const gint32 hello, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_map_map (iface, hello, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_map_map (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_insanity (TTestThriftTestIf * iface, const TTestInsanity * argument, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testInsanity", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testInsanity_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "argument", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (argument), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_insanity (TTestThriftTestIf * iface, GHashTable ** _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testInsanity", 12) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testInsanity", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_MAP)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType key_type;
              ThriftType value_type;

              /* read the map begin marker */
              if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through each of the map's fields */
              for (i = 0; i < size; i++)
              {
                TTestUserId* key139 = g_new (TTestUserId, 1);
                GHashTable * val140 = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_object_unref);
                if ((ret = thrift_protocol_read_i64 (protocol, &*key139, error)) < 0)
                  return 0;
                xfer += ret;
                {
                  guint32 size;
                  guint32 i;
                  ThriftType key_type;
                  ThriftType value_type;

                  /* read the map begin marker */
                  if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                    return 0;
                  xfer += ret;

                  /* iterate through each of the map's fields */
                  for (i = 0; i < size; i++)
                  {
                    TTestNumberz key141;
                    TTestInsanity * val142 = NULL;
                    gint32 ecast143;
                    if ((ret = thrift_protocol_read_i32 (protocol, &ecast143, error)) < 0)
                      return 0;
                    xfer += ret;
                    key141 = (TTestNumberz)ecast143;
                    if ( val142 != NULL)
                    {
                      g_object_unref (val142);
                    }
                    val142 = g_object_new (T_TEST_TYPE_INSANITY, NULL);
                    if ((ret = thrift_struct_read (THRIFT_STRUCT (val142), protocol, error)) < 0)
                    {
                      g_object_unref (val142);
                      return 0;
                    }
                    xfer += ret;
                    g_hash_table_insert ((GHashTable *)val140, (gpointer) key141, (gpointer) val142);
                  }

                  /* read the map end marker */
                  if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                    return 0;
                  xfer += ret;
                }
                g_hash_table_insert ((GHashTable *)*_return, (gpointer) key139, (gpointer) val140);
              }

              /* read the map end marker */
              if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_insanity (TTestThriftTestIf * iface, GHashTable ** _return, const TTestInsanity * argument, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_insanity (iface, argument, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_insanity (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_multi (TTestThriftTestIf * iface, const gint8 arg0, const gint32 arg1, const gint64 arg2, const GHashTable * arg3, const TTestNumberz arg4, const TTestUserId arg5, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testMulti", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testMulti_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "arg0", T_BYTE, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_byte (protocol, arg0, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "arg1", T_I32, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, arg1, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "arg2", T_I64, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, arg2, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "arg3", T_MAP, 4, error)) < 0)
      return 0;
    xfer += ret;
    {
      gint16* key144 = g_new (gint16, 1);
      gchar * val145 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gint16** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_I16, T_STRING, (gint32) g_hash_table_size ((GHashTable *) arg3), error)) < 0)
        return 0;
      xfer += ret;
      g_hash_table_foreach ((GHashTable *) arg3, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gint16*, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gint16*) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key144 = keys[i];
        val145 = (gchar *) g_hash_table_lookup (((GHashTable *) arg3), (gpointer) key144);

        if ((ret = thrift_protocol_write_i16 (protocol, * key144, error)) < 0)
          return 0;
        if ((ret = thrift_protocol_write_string (protocol,  val145, error)) < 0)
          return 0;
      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "arg4", T_I32, 5, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) arg4, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "arg5", T_I64, 6, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, arg5, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_multi (TTestThriftTestIf * iface, TTestXtruct ** _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testMulti", 9) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testMulti", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_multi (TTestThriftTestIf * iface, TTestXtruct ** _return, const gint8 arg0, const gint32 arg1, const gint64 arg2, const GHashTable * arg3, const TTestNumberz arg4, const TTestUserId arg5, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_multi (iface, arg0, arg1, arg2, arg3, arg4, arg5, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_multi (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_exception (TTestThriftTestIf * iface, const gchar * arg, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testException", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testException_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "arg", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, arg, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_exception (TTestThriftTestIf * iface, TTestXception ** err1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testException", 13) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testException", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *err1 != NULL)
            {
              g_object_unref (*err1);
            }
            *err1 = g_object_new (T_TEST_TYPE_XCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*err1), protocol, error)) < 0)
            {
              g_object_unref (*err1);
              *err1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*err1 != NULL)
  {
      g_set_error (error, T_TEST_XCEPTION_ERROR, T_TEST_XCEPTION_ERROR_CODE, "Xception");
      return FALSE;
  }
  return TRUE;
}

gboolean t_test_thrift_test_client_test_exception (TTestThriftTestIf * iface, const gchar * arg, TTestXception ** err1, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_exception (iface, arg, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_exception (iface, err1, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_multi_exception (TTestThriftTestIf * iface, const gchar * arg0, const gchar * arg1, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testMultiException", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testMultiException_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "arg0", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, arg0, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "arg1", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, arg1, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_recv_test_multi_exception (TTestThriftTestIf * iface, TTestXtruct ** _return, TTestXception ** err1, TTestXception2 ** err2, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "testMultiException", 18) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected testMultiException", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *err1 != NULL)
            {
              g_object_unref (*err1);
            }
            *err1 = g_object_new (T_TEST_TYPE_XCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*err1), protocol, error)) < 0)
            {
              g_object_unref (*err1);
              *err1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *err2 != NULL)
            {
              g_object_unref (*err2);
            }
            *err2 = g_object_new (T_TEST_TYPE_XCEPTION2, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*err2), protocol, error)) < 0)
            {
              g_object_unref (*err2);
              *err2 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*err1 != NULL)
  {
      g_set_error (error, T_TEST_XCEPTION_ERROR, T_TEST_XCEPTION_ERROR_CODE, "Xception");
      return FALSE;
  }
  if (*err2 != NULL)
  {
      g_set_error (error, T_TEST_XCEPTION2_ERROR, T_TEST_XCEPTION2_ERROR_CODE, "Xception2");
      return FALSE;
  }
  return TRUE;
}

gboolean t_test_thrift_test_client_test_multi_exception (TTestThriftTestIf * iface, TTestXtruct ** _return, const gchar * arg0, const gchar * arg1, TTestXception ** err1, TTestXception2 ** err2, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_multi_exception (iface, arg0, arg1, error))
    return FALSE;
  if (!t_test_thrift_test_client_recv_test_multi_exception (iface, _return, err1, err2, error))
    return FALSE;
  return TRUE;
}

gboolean t_test_thrift_test_client_send_test_oneway (TTestThriftTestIf * iface, const gint32 secondsToSleep, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = T_TEST_THRIFT_TEST_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "testOneway", T_ONEWAY, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "testOneway_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "secondsToSleep", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, secondsToSleep, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean t_test_thrift_test_client_test_oneway (TTestThriftTestIf * iface, const gint32 secondsToSleep, GError ** error)
{
  if (!t_test_thrift_test_client_send_test_oneway (iface, secondsToSleep, error))
    return FALSE;
  return TRUE;
}

static void
t_test_thrift_test_if_interface_init (TTestThriftTestIfInterface *iface)
{
  iface->test_void = t_test_thrift_test_client_test_void;
  iface->test_string = t_test_thrift_test_client_test_string;
  iface->test_bool = t_test_thrift_test_client_test_bool;
  iface->test_byte = t_test_thrift_test_client_test_byte;
  iface->test_i32 = t_test_thrift_test_client_test_i32;
  iface->test_i64 = t_test_thrift_test_client_test_i64;
  iface->test_double = t_test_thrift_test_client_test_double;
  iface->test_binary = t_test_thrift_test_client_test_binary;
  iface->test_struct = t_test_thrift_test_client_test_struct;
  iface->test_nest = t_test_thrift_test_client_test_nest;
  iface->test_map = t_test_thrift_test_client_test_map;
  iface->test_string_map = t_test_thrift_test_client_test_string_map;
  iface->test_set = t_test_thrift_test_client_test_set;
  iface->test_list = t_test_thrift_test_client_test_list;
  iface->test_enum = t_test_thrift_test_client_test_enum;
  iface->test_typedef = t_test_thrift_test_client_test_typedef;
  iface->test_map_map = t_test_thrift_test_client_test_map_map;
  iface->test_insanity = t_test_thrift_test_client_test_insanity;
  iface->test_multi = t_test_thrift_test_client_test_multi;
  iface->test_exception = t_test_thrift_test_client_test_exception;
  iface->test_multi_exception = t_test_thrift_test_client_test_multi_exception;
  iface->test_oneway = t_test_thrift_test_client_test_oneway;
}

static void
t_test_thrift_test_client_init (TTestThriftTestClient *client)
{
  client->input_protocol = NULL;
  client->output_protocol = NULL;
}

static void
t_test_thrift_test_client_class_init (TTestThriftTestClientClass *cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  GParamSpec *param_spec;

  gobject_class->set_property = t_test_thrift_test_client_set_property;
  gobject_class->get_property = t_test_thrift_test_client_get_property;

  param_spec = g_param_spec_object ("input_protocol",
                                    "input protocol (construct)",
                                    "Set the client input protocol",
                                    THRIFT_TYPE_PROTOCOL,
                                    G_PARAM_READWRITE);
  g_object_class_install_property (gobject_class,
                                   PROP_T_TEST_THRIFT_TEST_CLIENT_INPUT_PROTOCOL, param_spec);

  param_spec = g_param_spec_object ("output_protocol",
                                    "output protocol (construct)",
                                    "Set the client output protocol",
                                    THRIFT_TYPE_PROTOCOL,
                                    G_PARAM_READWRITE);
  g_object_class_install_property (gobject_class,
                                   PROP_T_TEST_THRIFT_TEST_CLIENT_OUTPUT_PROTOCOL, param_spec);
}

static void
t_test_thrift_test_handler_thrift_test_if_interface_init (TTestThriftTestIfInterface *iface);

G_DEFINE_TYPE_WITH_CODE (TTestThriftTestHandler, 
                         t_test_thrift_test_handler,
                         G_TYPE_OBJECT,
                         G_IMPLEMENT_INTERFACE (T_TEST_TYPE_THRIFT_TEST_IF,
                                                t_test_thrift_test_handler_thrift_test_if_interface_init))

gboolean t_test_thrift_test_handler_test_void (TTestThriftTestIf * iface, GError ** error)
{
  g_return_val_if_fail (T_TEST_IS_THRIFT_TEST_HANDLER (iface), FALSE);

  return T_TEST_THRIFT_TEST_HANDLER_GET_CLASS (iface)->test_void (iface, error);
}

gboolean t_test_thrift_test_handler_test_string (TTestThriftTestIf * iface, gchar ** _return, const gchar * thing, GError ** error)
{
  g_return_val_if_fail (T_TEST_IS_THRIFT_TEST_HANDLER (iface), FALSE);

  return T_TEST_THRIFT_TEST_HANDLER_GET_CLASS (iface)->test_string (iface, _return, thing, error);
}

gboolean t_test_thrift_test_handler_test_bool (TTestThriftTestIf * iface, gboolean* _return, const gboolean thing, GError ** error)
{
  g_return_val_if_fail (T_TEST_IS_THRIFT_TEST_HANDLER (iface), FALSE);

  return T_TEST_THRIFT_TEST_HANDLER_GET_CLASS (iface)->test_bool (iface, _return, thing, error);
}

gboolean t_test_thrift_test_handler_test_byte (TTestThriftTestIf * iface, gint8* _return, const gint8 thing, GError ** error)
{
  g_return_val_if_fail (T_TEST_IS_THRIFT_TEST_HANDLER (iface), FALSE);

  return T_TEST_THRIFT_TEST_HANDLER_GET_CLASS (iface)->test_byte (iface, _return, thing, error);
}

gboolean t_test_thrift_test_handler_test_i32 (TTestThriftTestIf * iface, gint32* _return, const gint32 thing, GError ** error)
{
  g_return_val_if_fail (T_TEST_IS_THRIFT_TEST_HANDLER (iface), FALSE);

  return T_TEST_THRIFT_TEST_HANDLER_GET_CLASS (iface)->test_i32 (iface, _return, thing, error);
}

gboolean t_test_thrift_test_handler_test_i64 (TTestThriftTestIf * iface, gint64* _return, const gint64 thing, GError ** error)
{
  g_return_val_if_fail (T_TEST_IS_THRIFT_TEST_HANDLER (iface), FALSE);

  return T_TEST_THRIFT_TEST_HANDLER_GET_CLASS (iface)->test_i64 (iface, _return, thing, error);
}

gboolean t_test_thrift_test_handler_test_double (TTestThriftTestIf * iface, gdouble* _return, const gdouble thing, GError ** error)
{
  g_return_val_if_fail (T_TEST_IS_THRIFT_TEST_HANDLER (iface), FALSE);

  return T_TEST_THRIFT_TEST_HANDLER_GET_CLASS (iface)->test_double (iface, _return, thing, error);
}

gboolean t_test_thrift_test_handler_test_binary (TTestThriftTestIf * iface, GByteArray ** _return, const GByteArray * thing, GError ** error)
{
  g_return_val_if_fail (T_TEST_IS_THRIFT_TEST_HANDLER (iface), FALSE);

  return T_TEST_THRIFT_TEST_HANDLER_GET_CLASS (iface)->test_binary (iface, _return, thing, error);
}

gboolean t_test_thrift_test_handler_test_struct (TTestThriftTestIf * iface, TTestXtruct ** _return, const TTestXtruct * thing, GError ** error)
{
  g_return_val_if_fail (T_TEST_IS_THRIFT_TEST_HANDLER (iface), FALSE);

  return T_TEST_THRIFT_TEST_HANDLER_GET_CLASS (iface)->test_struct (iface, _return, thing, error);
}

gboolean t_test_thrift_test_handler_test_nest (TTestThriftTestIf * iface, TTestXtruct2 ** _return, const TTestXtruct2 * thing, GError ** error)
{
  g_return_val_if_fail (T_TEST_IS_THRIFT_TEST_HANDLER (iface), FALSE);

  return T_TEST_THRIFT_TEST_HANDLER_GET_CLASS (iface)->test_nest (iface, _return, thing, error);
}

gboolean t_test_thrift_test_handler_test_map (TTestThriftTestIf * iface, GHashTable ** _return, const GHashTable * thing, GError ** error)
{
  g_return_val_if_fail (T_TEST_IS_THRIFT_TEST_HANDLER (iface), FALSE);

  return T_TEST_THRIFT_TEST_HANDLER_GET_CLASS (iface)->test_map (iface, _return, thing, error);
}

gboolean t_test_thrift_test_handler_test_string_map (TTestThriftTestIf * iface, GHashTable ** _return, const GHashTable * thing, GError ** error)
{
  g_return_val_if_fail (T_TEST_IS_THRIFT_TEST_HANDLER (iface), FALSE);

  return T_TEST_THRIFT_TEST_HANDLER_GET_CLASS (iface)->test_string_map (iface, _return, thing, error);
}

gboolean t_test_thrift_test_handler_test_set (TTestThriftTestIf * iface, GHashTable ** _return, const GHashTable * thing, GError ** error)
{
  g_return_val_if_fail (T_TEST_IS_THRIFT_TEST_HANDLER (iface), FALSE);

  return T_TEST_THRIFT_TEST_HANDLER_GET_CLASS (iface)->test_set (iface, _return, thing, error);
}

gboolean t_test_thrift_test_handler_test_list (TTestThriftTestIf * iface, GArray ** _return, const GArray * thing, GError ** error)
{
  g_return_val_if_fail (T_TEST_IS_THRIFT_TEST_HANDLER (iface), FALSE);

  return T_TEST_THRIFT_TEST_HANDLER_GET_CLASS (iface)->test_list (iface, _return, thing, error);
}

gboolean t_test_thrift_test_handler_test_enum (TTestThriftTestIf * iface, TTestNumberz* _return, const TTestNumberz thing, GError ** error)
{
  g_return_val_if_fail (T_TEST_IS_THRIFT_TEST_HANDLER (iface), FALSE);

  return T_TEST_THRIFT_TEST_HANDLER_GET_CLASS (iface)->test_enum (iface, _return, thing, error);
}

gboolean t_test_thrift_test_handler_test_typedef (TTestThriftTestIf * iface, TTestUserId* _return, const TTestUserId thing, GError ** error)
{
  g_return_val_if_fail (T_TEST_IS_THRIFT_TEST_HANDLER (iface), FALSE);

  return T_TEST_THRIFT_TEST_HANDLER_GET_CLASS (iface)->test_typedef (iface, _return, thing, error);
}

gboolean t_test_thrift_test_handler_test_map_map (TTestThriftTestIf * iface, GHashTable ** _return, const gint32 hello, GError ** error)
{
  g_return_val_if_fail (T_TEST_IS_THRIFT_TEST_HANDLER (iface), FALSE);

  return T_TEST_THRIFT_TEST_HANDLER_GET_CLASS (iface)->test_map_map (iface, _return, hello, error);
}

gboolean t_test_thrift_test_handler_test_insanity (TTestThriftTestIf * iface, GHashTable ** _return, const TTestInsanity * argument, GError ** error)
{
  g_return_val_if_fail (T_TEST_IS_THRIFT_TEST_HANDLER (iface), FALSE);

  return T_TEST_THRIFT_TEST_HANDLER_GET_CLASS (iface)->test_insanity (iface, _return, argument, error);
}

gboolean t_test_thrift_test_handler_test_multi (TTestThriftTestIf * iface, TTestXtruct ** _return, const gint8 arg0, const gint32 arg1, const gint64 arg2, const GHashTable * arg3, const TTestNumberz arg4, const TTestUserId arg5, GError ** error)
{
  g_return_val_if_fail (T_TEST_IS_THRIFT_TEST_HANDLER (iface), FALSE);

  return T_TEST_THRIFT_TEST_HANDLER_GET_CLASS (iface)->test_multi (iface, _return, arg0, arg1, arg2, arg3, arg4, arg5, error);
}

gboolean t_test_thrift_test_handler_test_exception (TTestThriftTestIf * iface, const gchar * arg, TTestXception ** err1, GError ** error)
{
  g_return_val_if_fail (T_TEST_IS_THRIFT_TEST_HANDLER (iface), FALSE);

  return T_TEST_THRIFT_TEST_HANDLER_GET_CLASS (iface)->test_exception (iface, arg, err1, error);
}

gboolean t_test_thrift_test_handler_test_multi_exception (TTestThriftTestIf * iface, TTestXtruct ** _return, const gchar * arg0, const gchar * arg1, TTestXception ** err1, TTestXception2 ** err2, GError ** error)
{
  g_return_val_if_fail (T_TEST_IS_THRIFT_TEST_HANDLER (iface), FALSE);

  return T_TEST_THRIFT_TEST_HANDLER_GET_CLASS (iface)->test_multi_exception (iface, _return, arg0, arg1, err1, err2, error);
}

gboolean t_test_thrift_test_handler_test_oneway (TTestThriftTestIf * iface, const gint32 secondsToSleep, GError ** error)
{
  g_return_val_if_fail (T_TEST_IS_THRIFT_TEST_HANDLER (iface), FALSE);

  return T_TEST_THRIFT_TEST_HANDLER_GET_CLASS (iface)->test_oneway (iface, secondsToSleep, error);
}

static void
t_test_thrift_test_handler_thrift_test_if_interface_init (TTestThriftTestIfInterface *iface)
{
  iface->test_void = t_test_thrift_test_handler_test_void;
  iface->test_string = t_test_thrift_test_handler_test_string;
  iface->test_bool = t_test_thrift_test_handler_test_bool;
  iface->test_byte = t_test_thrift_test_handler_test_byte;
  iface->test_i32 = t_test_thrift_test_handler_test_i32;
  iface->test_i64 = t_test_thrift_test_handler_test_i64;
  iface->test_double = t_test_thrift_test_handler_test_double;
  iface->test_binary = t_test_thrift_test_handler_test_binary;
  iface->test_struct = t_test_thrift_test_handler_test_struct;
  iface->test_nest = t_test_thrift_test_handler_test_nest;
  iface->test_map = t_test_thrift_test_handler_test_map;
  iface->test_string_map = t_test_thrift_test_handler_test_string_map;
  iface->test_set = t_test_thrift_test_handler_test_set;
  iface->test_list = t_test_thrift_test_handler_test_list;
  iface->test_enum = t_test_thrift_test_handler_test_enum;
  iface->test_typedef = t_test_thrift_test_handler_test_typedef;
  iface->test_map_map = t_test_thrift_test_handler_test_map_map;
  iface->test_insanity = t_test_thrift_test_handler_test_insanity;
  iface->test_multi = t_test_thrift_test_handler_test_multi;
  iface->test_exception = t_test_thrift_test_handler_test_exception;
  iface->test_multi_exception = t_test_thrift_test_handler_test_multi_exception;
  iface->test_oneway = t_test_thrift_test_handler_test_oneway;
}

static void
t_test_thrift_test_handler_init (TTestThriftTestHandler *self)
{
  THRIFT_UNUSED_VAR (self);
}

static void
t_test_thrift_test_handler_class_init (TTestThriftTestHandlerClass *cls)
{
  cls->test_void = NULL;
  cls->test_string = NULL;
  cls->test_bool = NULL;
  cls->test_byte = NULL;
  cls->test_i32 = NULL;
  cls->test_i64 = NULL;
  cls->test_double = NULL;
  cls->test_binary = NULL;
  cls->test_struct = NULL;
  cls->test_nest = NULL;
  cls->test_map = NULL;
  cls->test_string_map = NULL;
  cls->test_set = NULL;
  cls->test_list = NULL;
  cls->test_enum = NULL;
  cls->test_typedef = NULL;
  cls->test_map_map = NULL;
  cls->test_insanity = NULL;
  cls->test_multi = NULL;
  cls->test_exception = NULL;
  cls->test_multi_exception = NULL;
  cls->test_oneway = NULL;
}

enum _TTestThriftTestProcessorProperties
{
  PROP_T_TEST_THRIFT_TEST_PROCESSOR_0,
  PROP_T_TEST_THRIFT_TEST_PROCESSOR_HANDLER
};

G_DEFINE_TYPE (TTestThriftTestProcessor,
               t_test_thrift_test_processor,
               THRIFT_TYPE_DISPATCH_PROCESSOR)

typedef gboolean (* TTestThriftTestProcessorProcessFunction) (TTestThriftTestProcessor *, 
                                                              gint32,
                                                              ThriftProtocol *,
                                                              ThriftProtocol *,
                                                              GError **);

typedef struct
{
  gchar *name;
  TTestThriftTestProcessorProcessFunction function;
} t_test_thrift_test_processor_process_function_def;

static gboolean
t_test_thrift_test_processor_process_test_void (TTestThriftTestProcessor *,
                                                gint32,
                                                ThriftProtocol *,
                                                ThriftProtocol *,
                                                GError **);
static gboolean
t_test_thrift_test_processor_process_test_string (TTestThriftTestProcessor *,
                                                  gint32,
                                                  ThriftProtocol *,
                                                  ThriftProtocol *,
                                                  GError **);
static gboolean
t_test_thrift_test_processor_process_test_bool (TTestThriftTestProcessor *,
                                                gint32,
                                                ThriftProtocol *,
                                                ThriftProtocol *,
                                                GError **);
static gboolean
t_test_thrift_test_processor_process_test_byte (TTestThriftTestProcessor *,
                                                gint32,
                                                ThriftProtocol *,
                                                ThriftProtocol *,
                                                GError **);
static gboolean
t_test_thrift_test_processor_process_test_i32 (TTestThriftTestProcessor *,
                                               gint32,
                                               ThriftProtocol *,
                                               ThriftProtocol *,
                                               GError **);
static gboolean
t_test_thrift_test_processor_process_test_i64 (TTestThriftTestProcessor *,
                                               gint32,
                                               ThriftProtocol *,
                                               ThriftProtocol *,
                                               GError **);
static gboolean
t_test_thrift_test_processor_process_test_double (TTestThriftTestProcessor *,
                                                  gint32,
                                                  ThriftProtocol *,
                                                  ThriftProtocol *,
                                                  GError **);
static gboolean
t_test_thrift_test_processor_process_test_binary (TTestThriftTestProcessor *,
                                                  gint32,
                                                  ThriftProtocol *,
                                                  ThriftProtocol *,
                                                  GError **);
static gboolean
t_test_thrift_test_processor_process_test_struct (TTestThriftTestProcessor *,
                                                  gint32,
                                                  ThriftProtocol *,
                                                  ThriftProtocol *,
                                                  GError **);
static gboolean
t_test_thrift_test_processor_process_test_nest (TTestThriftTestProcessor *,
                                                gint32,
                                                ThriftProtocol *,
                                                ThriftProtocol *,
                                                GError **);
static gboolean
t_test_thrift_test_processor_process_test_map (TTestThriftTestProcessor *,
                                               gint32,
                                               ThriftProtocol *,
                                               ThriftProtocol *,
                                               GError **);
static gboolean
t_test_thrift_test_processor_process_test_string_map (TTestThriftTestProcessor *,
                                                      gint32,
                                                      ThriftProtocol *,
                                                      ThriftProtocol *,
                                                      GError **);
static gboolean
t_test_thrift_test_processor_process_test_set (TTestThriftTestProcessor *,
                                               gint32,
                                               ThriftProtocol *,
                                               ThriftProtocol *,
                                               GError **);
static gboolean
t_test_thrift_test_processor_process_test_list (TTestThriftTestProcessor *,
                                                gint32,
                                                ThriftProtocol *,
                                                ThriftProtocol *,
                                                GError **);
static gboolean
t_test_thrift_test_processor_process_test_enum (TTestThriftTestProcessor *,
                                                gint32,
                                                ThriftProtocol *,
                                                ThriftProtocol *,
                                                GError **);
static gboolean
t_test_thrift_test_processor_process_test_typedef (TTestThriftTestProcessor *,
                                                   gint32,
                                                   ThriftProtocol *,
                                                   ThriftProtocol *,
                                                   GError **);
static gboolean
t_test_thrift_test_processor_process_test_map_map (TTestThriftTestProcessor *,
                                                   gint32,
                                                   ThriftProtocol *,
                                                   ThriftProtocol *,
                                                   GError **);
static gboolean
t_test_thrift_test_processor_process_test_insanity (TTestThriftTestProcessor *,
                                                    gint32,
                                                    ThriftProtocol *,
                                                    ThriftProtocol *,
                                                    GError **);
static gboolean
t_test_thrift_test_processor_process_test_multi (TTestThriftTestProcessor *,
                                                 gint32,
                                                 ThriftProtocol *,
                                                 ThriftProtocol *,
                                                 GError **);
static gboolean
t_test_thrift_test_processor_process_test_exception (TTestThriftTestProcessor *,
                                                     gint32,
                                                     ThriftProtocol *,
                                                     ThriftProtocol *,
                                                     GError **);
static gboolean
t_test_thrift_test_processor_process_test_multi_exception (TTestThriftTestProcessor *,
                                                           gint32,
                                                           ThriftProtocol *,
                                                           ThriftProtocol *,
                                                           GError **);
static gboolean
t_test_thrift_test_processor_process_test_oneway (TTestThriftTestProcessor *,
                                                  gint32,
                                                  ThriftProtocol *,
                                                  ThriftProtocol *,
                                                  GError **);

static t_test_thrift_test_processor_process_function_def
t_test_thrift_test_processor_process_function_defs[22] = {
  {
    "testVoid",
    t_test_thrift_test_processor_process_test_void
  },
  {
    "testString",
    t_test_thrift_test_processor_process_test_string
  },
  {
    "testBool",
    t_test_thrift_test_processor_process_test_bool
  },
  {
    "testByte",
    t_test_thrift_test_processor_process_test_byte
  },
  {
    "testI32",
    t_test_thrift_test_processor_process_test_i32
  },
  {
    "testI64",
    t_test_thrift_test_processor_process_test_i64
  },
  {
    "testDouble",
    t_test_thrift_test_processor_process_test_double
  },
  {
    "testBinary",
    t_test_thrift_test_processor_process_test_binary
  },
  {
    "testStruct",
    t_test_thrift_test_processor_process_test_struct
  },
  {
    "testNest",
    t_test_thrift_test_processor_process_test_nest
  },
  {
    "testMap",
    t_test_thrift_test_processor_process_test_map
  },
  {
    "testStringMap",
    t_test_thrift_test_processor_process_test_string_map
  },
  {
    "testSet",
    t_test_thrift_test_processor_process_test_set
  },
  {
    "testList",
    t_test_thrift_test_processor_process_test_list
  },
  {
    "testEnum",
    t_test_thrift_test_processor_process_test_enum
  },
  {
    "testTypedef",
    t_test_thrift_test_processor_process_test_typedef
  },
  {
    "testMapMap",
    t_test_thrift_test_processor_process_test_map_map
  },
  {
    "testInsanity",
    t_test_thrift_test_processor_process_test_insanity
  },
  {
    "testMulti",
    t_test_thrift_test_processor_process_test_multi
  },
  {
    "testException",
    t_test_thrift_test_processor_process_test_exception
  },
  {
    "testMultiException",
    t_test_thrift_test_processor_process_test_multi_exception
  },
  {
    "testOneway",
    t_test_thrift_test_processor_process_test_oneway
  }
};

static gboolean
t_test_thrift_test_processor_process_test_void (TTestThriftTestProcessor *self,
                                                gint32 sequence_id,
                                                ThriftProtocol *input_protocol,
                                                ThriftProtocol *output_protocol,
                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  TTestThriftTestTestVoidArgs * args =
    g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_VOID_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TTestThriftTestTestVoidResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_VOID_RESULT, NULL);

    if (t_test_thrift_test_handler_test_void (T_TEST_THRIFT_TEST_IF (self->handler),
                                              error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testVoid",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("ThriftTest.testVoid implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testVoid",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
t_test_thrift_test_processor_process_test_string (TTestThriftTestProcessor *self,
                                                  gint32 sequence_id,
                                                  ThriftProtocol *input_protocol,
                                                  ThriftProtocol *output_protocol,
                                                  GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  TTestThriftTestTestStringArgs * args =
    g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_STRING_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * thing;
    gchar * return_value;
    TTestThriftTestTestStringResult * result_struct;

    g_object_get (args,
                  "thing", &thing,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_STRING_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (t_test_thrift_test_handler_test_string (T_TEST_THRIFT_TEST_IF (self->handler),
                                                &return_value,
                                                thing,
                                                error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_free (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testString",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("ThriftTest.testString implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testString",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thing != NULL)
      g_free (thing);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
t_test_thrift_test_processor_process_test_bool (TTestThriftTestProcessor *self,
                                                gint32 sequence_id,
                                                ThriftProtocol *input_protocol,
                                                ThriftProtocol *output_protocol,
                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  TTestThriftTestTestBoolArgs * args =
    g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_BOOL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gboolean thing;
    gboolean return_value;
    TTestThriftTestTestBoolResult * result_struct;

    g_object_get (args,
                  "thing", &thing,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_BOOL_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (t_test_thrift_test_handler_test_bool (T_TEST_THRIFT_TEST_IF (self->handler),
                                              &return_value,
                                              thing,
                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testBool",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("ThriftTest.testBool implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testBool",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
t_test_thrift_test_processor_process_test_byte (TTestThriftTestProcessor *self,
                                                gint32 sequence_id,
                                                ThriftProtocol *input_protocol,
                                                ThriftProtocol *output_protocol,
                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  TTestThriftTestTestByteArgs * args =
    g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_BYTE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint thing;
    gint return_value;
    TTestThriftTestTestByteResult * result_struct;

    g_object_get (args,
                  "thing", &thing,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_BYTE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (t_test_thrift_test_handler_test_byte (T_TEST_THRIFT_TEST_IF (self->handler),
                                              (gint8 *)&return_value,
                                              thing,
                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testByte",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("ThriftTest.testByte implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testByte",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
t_test_thrift_test_processor_process_test_i32 (TTestThriftTestProcessor *self,
                                               gint32 sequence_id,
                                               ThriftProtocol *input_protocol,
                                               ThriftProtocol *output_protocol,
                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  TTestThriftTestTestI32Args * args =
    g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_I32_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint thing;
    gint return_value;
    TTestThriftTestTestI32Result * result_struct;

    g_object_get (args,
                  "thing", &thing,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_I32_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (t_test_thrift_test_handler_test_i32 (T_TEST_THRIFT_TEST_IF (self->handler),
                                             (gint32 *)&return_value,
                                             thing,
                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testI32",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("ThriftTest.testI32 implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testI32",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
t_test_thrift_test_processor_process_test_i64 (TTestThriftTestProcessor *self,
                                               gint32 sequence_id,
                                               ThriftProtocol *input_protocol,
                                               ThriftProtocol *output_protocol,
                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  TTestThriftTestTestI64Args * args =
    g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_I64_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint64 thing;
    gint64 return_value;
    TTestThriftTestTestI64Result * result_struct;

    g_object_get (args,
                  "thing", &thing,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_I64_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (t_test_thrift_test_handler_test_i64 (T_TEST_THRIFT_TEST_IF (self->handler),
                                             &return_value,
                                             thing,
                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testI64",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("ThriftTest.testI64 implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testI64",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
t_test_thrift_test_processor_process_test_double (TTestThriftTestProcessor *self,
                                                  gint32 sequence_id,
                                                  ThriftProtocol *input_protocol,
                                                  ThriftProtocol *output_protocol,
                                                  GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  TTestThriftTestTestDoubleArgs * args =
    g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_DOUBLE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gdouble thing;
    gdouble return_value;
    TTestThriftTestTestDoubleResult * result_struct;

    g_object_get (args,
                  "thing", &thing,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_DOUBLE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (t_test_thrift_test_handler_test_double (T_TEST_THRIFT_TEST_IF (self->handler),
                                                &return_value,
                                                thing,
                                                error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testDouble",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("ThriftTest.testDouble implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testDouble",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
t_test_thrift_test_processor_process_test_binary (TTestThriftTestProcessor *self,
                                                  gint32 sequence_id,
                                                  ThriftProtocol *input_protocol,
                                                  ThriftProtocol *output_protocol,
                                                  GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  TTestThriftTestTestBinaryArgs * args =
    g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_BINARY_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GByteArray * thing;
    GByteArray * return_value;
    TTestThriftTestTestBinaryResult * result_struct;

    g_object_get (args,
                  "thing", &thing,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_BINARY_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (t_test_thrift_test_handler_test_binary (T_TEST_THRIFT_TEST_IF (self->handler),
                                                &return_value,
                                                thing,
                                                error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_byte_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testBinary",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("ThriftTest.testBinary implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testBinary",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thing != NULL)
      g_byte_array_unref (thing);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
t_test_thrift_test_processor_process_test_struct (TTestThriftTestProcessor *self,
                                                  gint32 sequence_id,
                                                  ThriftProtocol *input_protocol,
                                                  ThriftProtocol *output_protocol,
                                                  GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  TTestThriftTestTestStructArgs * args =
    g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_STRUCT_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TTestXtruct * thing;
    TTestXtruct * return_value;
    TTestThriftTestTestStructResult * result_struct;

    g_object_get (args,
                  "thing", &thing,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_STRUCT_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (t_test_thrift_test_handler_test_struct (T_TEST_THRIFT_TEST_IF (self->handler),
                                                &return_value,
                                                thing,
                                                error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testStruct",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("ThriftTest.testStruct implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testStruct",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thing != NULL)
      g_object_unref (thing);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
t_test_thrift_test_processor_process_test_nest (TTestThriftTestProcessor *self,
                                                gint32 sequence_id,
                                                ThriftProtocol *input_protocol,
                                                ThriftProtocol *output_protocol,
                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  TTestThriftTestTestNestArgs * args =
    g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_NEST_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TTestXtruct2 * thing;
    TTestXtruct2 * return_value;
    TTestThriftTestTestNestResult * result_struct;

    g_object_get (args,
                  "thing", &thing,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_NEST_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (t_test_thrift_test_handler_test_nest (T_TEST_THRIFT_TEST_IF (self->handler),
                                              &return_value,
                                              thing,
                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testNest",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("ThriftTest.testNest implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testNest",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thing != NULL)
      g_object_unref (thing);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
t_test_thrift_test_processor_process_test_map (TTestThriftTestProcessor *self,
                                               gint32 sequence_id,
                                               ThriftProtocol *input_protocol,
                                               ThriftProtocol *output_protocol,
                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  TTestThriftTestTestMapArgs * args =
    g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_MAP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GHashTable * thing;
    GHashTable * return_value;
    TTestThriftTestTestMapResult * result_struct;

    g_object_get (args,
                  "thing", &thing,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_MAP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (t_test_thrift_test_handler_test_map (T_TEST_THRIFT_TEST_IF (self->handler),
                                             &return_value,
                                             thing,
                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_hash_table_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testMap",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("ThriftTest.testMap implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testMap",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thing != NULL)
      g_hash_table_unref (thing);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
t_test_thrift_test_processor_process_test_string_map (TTestThriftTestProcessor *self,
                                                      gint32 sequence_id,
                                                      ThriftProtocol *input_protocol,
                                                      ThriftProtocol *output_protocol,
                                                      GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  TTestThriftTestTestStringMapArgs * args =
    g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_STRING_MAP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GHashTable * thing;
    GHashTable * return_value;
    TTestThriftTestTestStringMapResult * result_struct;

    g_object_get (args,
                  "thing", &thing,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_STRING_MAP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (t_test_thrift_test_handler_test_string_map (T_TEST_THRIFT_TEST_IF (self->handler),
                                                    &return_value,
                                                    thing,
                                                    error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_hash_table_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testStringMap",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("ThriftTest.testStringMap implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testStringMap",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thing != NULL)
      g_hash_table_unref (thing);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
t_test_thrift_test_processor_process_test_set (TTestThriftTestProcessor *self,
                                               gint32 sequence_id,
                                               ThriftProtocol *input_protocol,
                                               ThriftProtocol *output_protocol,
                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  TTestThriftTestTestSetArgs * args =
    g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_SET_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GHashTable * thing;
    GHashTable * return_value;
    TTestThriftTestTestSetResult * result_struct;

    g_object_get (args,
                  "thing", &thing,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_SET_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (t_test_thrift_test_handler_test_set (T_TEST_THRIFT_TEST_IF (self->handler),
                                             &return_value,
                                             thing,
                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_hash_table_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testSet",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("ThriftTest.testSet implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testSet",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thing != NULL)
      g_hash_table_unref (thing);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
t_test_thrift_test_processor_process_test_list (TTestThriftTestProcessor *self,
                                                gint32 sequence_id,
                                                ThriftProtocol *input_protocol,
                                                ThriftProtocol *output_protocol,
                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  TTestThriftTestTestListArgs * args =
    g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_LIST_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GArray * thing;
    GArray * return_value;
    TTestThriftTestTestListResult * result_struct;

    g_object_get (args,
                  "thing", &thing,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_LIST_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (t_test_thrift_test_handler_test_list (T_TEST_THRIFT_TEST_IF (self->handler),
                                              &return_value,
                                              thing,
                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testList",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("ThriftTest.testList implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testList",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thing != NULL)
      g_array_unref (thing);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
t_test_thrift_test_processor_process_test_enum (TTestThriftTestProcessor *self,
                                                gint32 sequence_id,
                                                ThriftProtocol *input_protocol,
                                                ThriftProtocol *output_protocol,
                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  TTestThriftTestTestEnumArgs * args =
    g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_ENUM_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TTestNumberz thing;
    TTestNumberz return_value;
    TTestThriftTestTestEnumResult * result_struct;

    g_object_get (args,
                  "thing", &thing,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_ENUM_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (t_test_thrift_test_handler_test_enum (T_TEST_THRIFT_TEST_IF (self->handler),
                                              &return_value,
                                              thing,
                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testEnum",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("ThriftTest.testEnum implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testEnum",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
t_test_thrift_test_processor_process_test_typedef (TTestThriftTestProcessor *self,
                                                   gint32 sequence_id,
                                                   ThriftProtocol *input_protocol,
                                                   ThriftProtocol *output_protocol,
                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  TTestThriftTestTestTypedefArgs * args =
    g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_TYPEDEF_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TTestUserId thing;
    TTestUserId return_value;
    TTestThriftTestTestTypedefResult * result_struct;

    g_object_get (args,
                  "thing", &thing,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_TYPEDEF_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (t_test_thrift_test_handler_test_typedef (T_TEST_THRIFT_TEST_IF (self->handler),
                                                 &return_value,
                                                 thing,
                                                 error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testTypedef",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("ThriftTest.testTypedef implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testTypedef",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
t_test_thrift_test_processor_process_test_map_map (TTestThriftTestProcessor *self,
                                                   gint32 sequence_id,
                                                   ThriftProtocol *input_protocol,
                                                   ThriftProtocol *output_protocol,
                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  TTestThriftTestTestMapMapArgs * args =
    g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_MAP_MAP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint hello;
    GHashTable * return_value;
    TTestThriftTestTestMapMapResult * result_struct;

    g_object_get (args,
                  "hello", &hello,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_MAP_MAP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (t_test_thrift_test_handler_test_map_map (T_TEST_THRIFT_TEST_IF (self->handler),
                                                 &return_value,
                                                 hello,
                                                 error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_hash_table_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testMapMap",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("ThriftTest.testMapMap implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testMapMap",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
t_test_thrift_test_processor_process_test_insanity (TTestThriftTestProcessor *self,
                                                    gint32 sequence_id,
                                                    ThriftProtocol *input_protocol,
                                                    ThriftProtocol *output_protocol,
                                                    GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  TTestThriftTestTestInsanityArgs * args =
    g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_INSANITY_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TTestInsanity * argument;
    GHashTable * return_value;
    TTestThriftTestTestInsanityResult * result_struct;

    g_object_get (args,
                  "argument", &argument,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_INSANITY_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (t_test_thrift_test_handler_test_insanity (T_TEST_THRIFT_TEST_IF (self->handler),
                                                  &return_value,
                                                  argument,
                                                  error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_hash_table_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testInsanity",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("ThriftTest.testInsanity implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testInsanity",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (argument != NULL)
      g_object_unref (argument);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
t_test_thrift_test_processor_process_test_multi (TTestThriftTestProcessor *self,
                                                 gint32 sequence_id,
                                                 ThriftProtocol *input_protocol,
                                                 ThriftProtocol *output_protocol,
                                                 GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  TTestThriftTestTestMultiArgs * args =
    g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_MULTI_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint arg0;
    gint arg1;
    gint64 arg2;
    GHashTable * arg3;
    TTestNumberz arg4;
    TTestUserId arg5;
    TTestXtruct * return_value;
    TTestThriftTestTestMultiResult * result_struct;

    g_object_get (args,
                  "arg0", &arg0,
                  "arg1", &arg1,
                  "arg2", &arg2,
                  "arg3", &arg3,
                  "arg4", &arg4,
                  "arg5", &arg5,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_MULTI_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (t_test_thrift_test_handler_test_multi (T_TEST_THRIFT_TEST_IF (self->handler),
                                               &return_value,
                                               arg0,
                                               arg1,
                                               arg2,
                                               arg3,
                                               arg4,
                                               arg5,
                                               error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testMulti",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("ThriftTest.testMulti implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testMulti",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (arg3 != NULL)
      g_hash_table_unref (arg3);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
t_test_thrift_test_processor_process_test_exception (TTestThriftTestProcessor *self,
                                                     gint32 sequence_id,
                                                     ThriftProtocol *input_protocol,
                                                     ThriftProtocol *output_protocol,
                                                     GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  TTestThriftTestTestExceptionArgs * args =
    g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_EXCEPTION_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * arg;
    TTestXception * err1 = NULL;
    TTestThriftTestTestExceptionResult * result_struct;

    g_object_get (args,
                  "arg", &arg,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_EXCEPTION_RESULT, NULL);

    if (t_test_thrift_test_handler_test_exception (T_TEST_THRIFT_TEST_IF (self->handler),
                                                   arg,
                                                   &err1,
                                                   error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testException",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (err1 != NULL)
      {
        g_object_set (result_struct,
                      "err1", err1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "testException",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ThriftTest.testException implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "testException",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (arg != NULL)
      g_free (arg);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
t_test_thrift_test_processor_process_test_multi_exception (TTestThriftTestProcessor *self,
                                                           gint32 sequence_id,
                                                           ThriftProtocol *input_protocol,
                                                           ThriftProtocol *output_protocol,
                                                           GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  TTestThriftTestTestMultiExceptionArgs * args =
    g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_MULTI_EXCEPTION_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * arg0;
    gchar * arg1;
    TTestXception * err1 = NULL;
    TTestXception2 * err2 = NULL;
    TTestXtruct * return_value;
    TTestThriftTestTestMultiExceptionResult * result_struct;

    g_object_get (args,
                  "arg0", &arg0,
                  "arg1", &arg1,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_MULTI_EXCEPTION_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (t_test_thrift_test_handler_test_multi_exception (T_TEST_THRIFT_TEST_IF (self->handler),
                                                         &return_value,
                                                         arg0,
                                                         arg1,
                                                         &err1,
                                                         &err2,
                                                         error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testMultiException",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (err1 != NULL)
      {
        g_object_set (result_struct,
                      "err1", err1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "testMultiException",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (err2 != NULL)
      {
        g_object_set (result_struct,
                      "err2", err2,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "testMultiException",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ThriftTest.testMultiException implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "testMultiException",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (arg0 != NULL)
      g_free (arg0);
    if (arg1 != NULL)
      g_free (arg1);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
t_test_thrift_test_processor_process_test_oneway (TTestThriftTestProcessor *self,
                                                  gint32 sequence_id,
                                                  ThriftProtocol *input_protocol,
                                                  ThriftProtocol *output_protocol,
                                                  GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  TTestThriftTestTestOnewayArgs * args =
    g_object_new (T_TEST_TYPE_THRIFT_TEST_TEST_ONEWAY_ARGS, NULL);

  THRIFT_UNUSED_VAR (sequence_id);
  THRIFT_UNUSED_VAR (output_protocol);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint secondsToSleep;

    g_object_get (args,
                  "secondsToSleep", &secondsToSleep,
                  NULL);

    if (t_test_thrift_test_handler_test_oneway (T_TEST_THRIFT_TEST_IF (self->handler),
                                                secondsToSleep,
                                                error) == TRUE)
    {
    }
    else
    {
      if (*error == NULL)
        g_warning ("ThriftTest.testOneway implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "testOneway",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
t_test_thrift_test_processor_dispatch_call (ThriftDispatchProcessor *dispatch_processor,
                                            ThriftProtocol *input_protocol,
                                            ThriftProtocol *output_protocol,
                                            gchar *method_name,
                                            gint32 sequence_id,
                                            GError **error)
{
  t_test_thrift_test_processor_process_function_def *process_function_def;
  gboolean dispatch_result = FALSE;

  TTestThriftTestProcessor *self = T_TEST_THRIFT_TEST_PROCESSOR (dispatch_processor);
  ThriftDispatchProcessorClass *parent_class =
    g_type_class_peek_parent (T_TEST_THRIFT_TEST_PROCESSOR_GET_CLASS (self));

  process_function_def = g_hash_table_lookup (self->process_map, method_name);
  if (process_function_def != NULL)
  {
    dispatch_result = (*process_function_def->function) (self,
                                                         sequence_id,
                                                         input_protocol,
                                                         output_protocol,
                                                         error);
  }
  else
  {
    dispatch_result = parent_class->dispatch_call (dispatch_processor,
                                                   input_protocol,
                                                   output_protocol,
                                                   method_name,
                                                   sequence_id,
                                                   error);
  }

  return dispatch_result;
}

static void
t_test_thrift_test_processor_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  TTestThriftTestProcessor *self = T_TEST_THRIFT_TEST_PROCESSOR (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_PROCESSOR_HANDLER:
      if (self->handler != NULL)
        g_object_unref (self->handler);
      self->handler = g_value_get_object (value);
      g_object_ref (self->handler);
      break;
    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_processor_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  TTestThriftTestProcessor *self = T_TEST_THRIFT_TEST_PROCESSOR (object);

  switch (property_id)
  {
    case PROP_T_TEST_THRIFT_TEST_PROCESSOR_HANDLER:
      g_value_set_object (value, self->handler);
      break;
    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_test_thrift_test_processor_dispose (GObject *gobject)
{
  TTestThriftTestProcessor *self = T_TEST_THRIFT_TEST_PROCESSOR (gobject);

  if (self->handler != NULL)
  {
    g_object_unref (self->handler);
    self->handler = NULL;
  }

  G_OBJECT_CLASS (t_test_thrift_test_processor_parent_class)->dispose (gobject);
}

static void
t_test_thrift_test_processor_finalize (GObject *gobject)
{
  TTestThriftTestProcessor *self = T_TEST_THRIFT_TEST_PROCESSOR (gobject);

  g_hash_table_destroy (self->process_map);

  G_OBJECT_CLASS (t_test_thrift_test_processor_parent_class)->finalize (gobject);
}

static void
t_test_thrift_test_processor_init (TTestThriftTestProcessor *self)
{
  guint index;

  self->handler = NULL;
  self->process_map = g_hash_table_new (g_str_hash, g_str_equal);

  for (index = 0; index < 22; index += 1)
    g_hash_table_insert (self->process_map,
                         t_test_thrift_test_processor_process_function_defs[index].name,
                         &t_test_thrift_test_processor_process_function_defs[index]);
}

static void
t_test_thrift_test_processor_class_init (TTestThriftTestProcessorClass *cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftDispatchProcessorClass *dispatch_processor_class =
    THRIFT_DISPATCH_PROCESSOR_CLASS (cls);
  GParamSpec *param_spec;

  gobject_class->dispose = t_test_thrift_test_processor_dispose;
  gobject_class->finalize = t_test_thrift_test_processor_finalize;
  gobject_class->set_property = t_test_thrift_test_processor_set_property;
  gobject_class->get_property = t_test_thrift_test_processor_get_property;

  dispatch_processor_class->dispatch_call = t_test_thrift_test_processor_dispatch_call;
  cls->dispatch_call = t_test_thrift_test_processor_dispatch_call;

  param_spec = g_param_spec_object ("handler",
                                    "Service handler implementation",
                                    "The service handler implementation "
                                    "to which method calls are dispatched.",
                                    T_TEST_TYPE_THRIFT_TEST_HANDLER,
                                    G_PARAM_READWRITE);
  g_object_class_install_property (gobject_class,
                                   PROP_T_TEST_THRIFT_TEST_PROCESSOR_HANDLER,
                                   param_spec);
}
